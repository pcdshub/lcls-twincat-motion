PLC Project (1): Library
========================

    Project path: /home/travis/build/pcdshub/lcls-twincat-motion/lcls-twincat-motion/Library/Library.plcproj
    TMC path:     /home/travis/build/pcdshub/lcls-twincat-motion/lcls-twincat-motion/Library/Library.tmc
    AMS ID:       
    IP Address:    (* based on AMS ID)
    Port:         851

    Source files:
        1.) /home/travis/build/pcdshub/lcls-twincat-motion/lcls-twincat-motion/Library/DUTs/DUT_MotionStage.TcDUT
        2.) /home/travis/build/pcdshub/lcls-twincat-motion/lcls-twincat-motion/Library/DUTs/DUT_PositionState.TcDUT
        3.) /home/travis/build/pcdshub/lcls-twincat-motion/lcls-twincat-motion/Library/DUTs/EL5042_Status.TcDUT
        4.) /home/travis/build/pcdshub/lcls-twincat-motion/lcls-twincat-motion/Library/DUTs/ENUM_EpicsHomeCmd.TcDUT
        5.) /home/travis/build/pcdshub/lcls-twincat-motion/lcls-twincat-motion/Library/DUTs/ENUM_EpicsMotorCmd.TcDUT
        6.) /home/travis/build/pcdshub/lcls-twincat-motion/lcls-twincat-motion/Library/DUTs/ENUM_StageBrakeMode.TcDUT
        7.) /home/travis/build/pcdshub/lcls-twincat-motion/lcls-twincat-motion/Library/DUTs/ENUM_StageEnableMode.TcDUT
        8.) /home/travis/build/pcdshub/lcls-twincat-motion/lcls-twincat-motion/Library/DUTs/ST_RenishawAbsEnc.TcDUT
        9.) /home/travis/build/pcdshub/lcls-twincat-motion/lcls-twincat-motion/Library/PlcTask.TcTTO
        10.) /home/travis/build/pcdshub/lcls-twincat-motion/lcls-twincat-motion/Library/POUs/Motion/FB_MotionStage.TcPOU
        11.) /home/travis/build/pcdshub/lcls-twincat-motion/lcls-twincat-motion/Library/POUs/Motion/FB_SetEnables.TcPOU
        12.) /home/travis/build/pcdshub/lcls-twincat-motion/lcls-twincat-motion/Library/POUs/Motion/FB_StatePTPMove.TcPOU
        13.) /home/travis/build/pcdshub/lcls-twincat-motion/lcls-twincat-motion/Library/POUs/Motion/Gantry/FB_GantryAutoCoupling.TcPOU
        14.) /home/travis/build/pcdshub/lcls-twincat-motion/lcls-twincat-motion/Library/POUs/Motion/Gantry/FB_GantryDiffVirtualLimitSwitch.TcPOU
        15.) /home/travis/build/pcdshub/lcls-twincat-motion/lcls-twincat-motion/Library/POUs/MotorTesting/FB_MicroStepCountTest.TcPOU
        16.) /home/travis/build/pcdshub/lcls-twincat-motion/lcls-twincat-motion/Library/tc_mca_std_lib/DUTs/DUT_AxisStatus_v0_01.TcDUT
        17.) /home/travis/build/pcdshub/lcls-twincat-motion/lcls-twincat-motion/Library/tc_mca_std_lib/GVLs/GVL.TcGVL
        18.) /home/travis/build/pcdshub/lcls-twincat-motion/lcls-twincat-motion/Library/tc_mca_std_lib/POUs/ChangeConfig/FB_ReadFloatParameter.TcPOU
        19.) /home/travis/build/pcdshub/lcls-twincat-motion/lcls-twincat-motion/Library/tc_mca_std_lib/POUs/ChangeConfig/FB_ReadParameterInNc_v1_00.TcPOU
        20.) /home/travis/build/pcdshub/lcls-twincat-motion/lcls-twincat-motion/Library/tc_mca_std_lib/POUs/ChangeConfig/FB_WriteFloatParameter.TcPOU
        21.) /home/travis/build/pcdshub/lcls-twincat-motion/lcls-twincat-motion/Library/tc_mca_std_lib/POUs/ChangeConfig/FB_WriteParameterInNc_v1_00.TcPOU
        22.) /home/travis/build/pcdshub/lcls-twincat-motion/lcls-twincat-motion/Library/tc_mca_std_lib/POUs/ErrorHandling/DUT_ErrorState.TcDUT
        23.) /home/travis/build/pcdshub/lcls-twincat-motion/lcls-twincat-motion/Library/tc_mca_std_lib/POUs/ErrorHandling/DUT_TerminalError.TcDUT
        24.) /home/travis/build/pcdshub/lcls-twincat-motion/lcls-twincat-motion/Library/tc_mca_std_lib/POUs/ErrorHandling/FB_ErrorList.TcPOU
        25.) /home/travis/build/pcdshub/lcls-twincat-motion/lcls-twincat-motion/Library/tc_mca_std_lib/POUs/ErrorHandling/FB_TerminalError.TcPOU
        26.) /home/travis/build/pcdshub/lcls-twincat-motion/lcls-twincat-motion/Library/tc_mca_std_lib/POUs/ErrorHandling/GVL_ErrorSystem.TcGVL
        27.) /home/travis/build/pcdshub/lcls-twincat-motion/lcls-twincat-motion/Library/tc_mca_std_lib/POUs/ErrorHandling/ST_ErrorSystem.TcDUT
        28.) /home/travis/build/pcdshub/lcls-twincat-motion/lcls-twincat-motion/Library/tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/Analog_Inputs/EL3174_0002.TcPOU
        29.) /home/travis/build/pcdshub/lcls-twincat-motion/lcls-twincat-motion/Library/tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/Analog_Inputs/EL3214.TcPOU
        30.) /home/travis/build/pcdshub/lcls-twincat-motion/lcls-twincat-motion/Library/tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/Analog_Inputs/EL3255.TcPOU
        31.) /home/travis/build/pcdshub/lcls-twincat-motion/lcls-twincat-motion/Library/tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/Analog_Inputs/FB_CalculateFrequency_3702_v0_01.TcPOU
        32.) /home/travis/build/pcdshub/lcls-twincat-motion/lcls-twincat-motion/Library/tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/Digital_Inputs/EL1008.TcPOU
        33.) /home/travis/build/pcdshub/lcls-twincat-motion/lcls-twincat-motion/Library/tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/Digital_Inputs/EL1018.TcPOU
        34.) /home/travis/build/pcdshub/lcls-twincat-motion/lcls-twincat-motion/Library/tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/Digital_Inputs/EL1808.TcPOU
        35.) /home/travis/build/pcdshub/lcls-twincat-motion/lcls-twincat-motion/Library/tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/Digital_Inputs/EL1809.TcPOU
        36.) /home/travis/build/pcdshub/lcls-twincat-motion/lcls-twincat-motion/Library/tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/Digital_Inputs/EL1819.TcPOU
        37.) /home/travis/build/pcdshub/lcls-twincat-motion/lcls-twincat-motion/Library/tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/Digital_Inputs/FB_EL1252ASM_v1_00.TcPOU
        38.) /home/travis/build/pcdshub/lcls-twincat-motion/lcls-twincat-motion/Library/tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/Digital_Outputs/EL2014.TcPOU
        39.) /home/travis/build/pcdshub/lcls-twincat-motion/lcls-twincat-motion/Library/tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/Digital_Outputs/EL2252.TcPOU
        40.) /home/travis/build/pcdshub/lcls-twincat-motion/lcls-twincat-motion/Library/tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/Digital_Outputs/EL2808.TcPOU
        41.) /home/travis/build/pcdshub/lcls-twincat-motion/lcls-twincat-motion/Library/tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/Digital_Outputs/EL2819.TcPOU
        42.) /home/travis/build/pcdshub/lcls-twincat-motion/lcls-twincat-motion/Library/tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/Digital_Outputs/External_Types/dutEL2521_Ctrl.TcDUT
        43.) /home/travis/build/pcdshub/lcls-twincat-motion/lcls-twincat-motion/Library/tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/Digital_Outputs/External_Types/dutEL2521_Status.TcDUT
        44.) /home/travis/build/pcdshub/lcls-twincat-motion/lcls-twincat-motion/Library/tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/Measuring_Terminals/EL5002.TcPOU
        45.) /home/travis/build/pcdshub/lcls-twincat-motion/lcls-twincat-motion/Library/tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/Measuring_Terminals/EL5021.TcPOU
        46.) /home/travis/build/pcdshub/lcls-twincat-motion/lcls-twincat-motion/Library/tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/Measuring_Terminals/EL5042.TcPOU
        47.) /home/travis/build/pcdshub/lcls-twincat-motion/lcls-twincat-motion/Library/tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/Measuring_Terminals/EL5101.TcPOU
        48.) /home/travis/build/pcdshub/lcls-twincat-motion/lcls-twincat-motion/Library/tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/Motion/EL7211_v1_00.TcPOU
        49.) /home/travis/build/pcdshub/lcls-twincat-motion/lcls-twincat-motion/Library/tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/Motion/EL9576_v1_00.TcPOU
        50.) /home/travis/build/pcdshub/lcls-twincat-motion/lcls-twincat-motion/Library/tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/System/EL9410.TcPOU
        51.) /home/travis/build/pcdshub/lcls-twincat-motion/lcls-twincat-motion/Library/tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/System/EL9505.TcPOU
        52.) /home/travis/build/pcdshub/lcls-twincat-motion/lcls-twincat-motion/Library/tc_mca_std_lib/POUs/Hardware/Other/EK1200.TcPOU
        53.) /home/travis/build/pcdshub/lcls-twincat-motion/lcls-twincat-motion/Library/tc_mca_std_lib/POUs/Motion/FB_DriveVirtual.TcPOU
        54.) /home/travis/build/pcdshub/lcls-twincat-motion/lcls-twincat-motion/Library/tc_mca_std_lib/POUs/Motion/FB_NcAxis.TcPOU
        55.) /home/travis/build/pcdshub/lcls-twincat-motion/lcls-twincat-motion/Library/tc_mca_std_lib/POUs/Motion/Homing/FB_HomeDirect.TcPOU
        56.) /home/travis/build/pcdshub/lcls-twincat-motion/lcls-twincat-motion/Library/tc_mca_std_lib/POUs/Motion/Homing/FB_HomeFinish.TcPOU
        57.) /home/travis/build/pcdshub/lcls-twincat-motion/lcls-twincat-motion/Library/tc_mca_std_lib/POUs/Motion/Homing/FB_HomePrepare.TcPOU
        58.) /home/travis/build/pcdshub/lcls-twincat-motion/lcls-twincat-motion/Library/tc_mca_std_lib/POUs/Motion/Homing/FB_HomeReadNcVelocities.TcPOU
        59.) /home/travis/build/pcdshub/lcls-twincat-motion/lcls-twincat-motion/Library/tc_mca_std_lib/POUs/Motion/Homing/FB_HomeReadSoftLimEnable.TcPOU
        60.) /home/travis/build/pcdshub/lcls-twincat-motion/lcls-twincat-motion/Library/tc_mca_std_lib/POUs/Motion/Homing/FB_HomeToSwitch.TcPOU
        61.) /home/travis/build/pcdshub/lcls-twincat-motion/lcls-twincat-motion/Library/tc_mca_std_lib/POUs/Motion/Homing/FB_HomeVirtual.TcPOU
        62.) /home/travis/build/pcdshub/lcls-twincat-motion/lcls-twincat-motion/Library/tc_mca_std_lib/POUs/Motion/Homing/FB_HomeWriteNcVelocities.TcPOU
        63.) /home/travis/build/pcdshub/lcls-twincat-motion/lcls-twincat-motion/Library/tc_mca_std_lib/POUs/Motion/Homing/FB_HomeWriteSoftLimEnable.TcPOU
        64.) /home/travis/build/pcdshub/lcls-twincat-motion/lcls-twincat-motion/Library/UnitTests/Interactive.TcPOU
        65.) /home/travis/build/pcdshub/lcls-twincat-motion/lcls-twincat-motion/Library/Version/Global_Version.TcGVL

    POUs:
        1.) Interactive

    GVLs:
        1.) GVL
        2.) GVL_ErrorSystem
        3.) Global_Version

DUTs/DUT_MotionStage.TcDUT (TcPlcObject)
----------------------------------------

### DUT_MotionStage: Declaration

```vhdl
TYPE DUT_MotionStage :
STRUCT
	(* Hardware *)
	
	// PLC Axis Reference
	Axis: AXIS_REF;
	// NC Forward Limit Switch: TRUE if ok to move
	{attribute 'pytmc' := '
		pv: PLC:bLimitForwardEnable
		io: i
	'}
	bLimitForwardEnable AT %I*: BOOL;
	// NC Backward Limit Switch: TRUE if ok to move
	{attribute 'pytmc' := '
		pv: PLC:bLimitBackwardEnable
		io: i
	'}
	bLimitBackwardEnable AT %I*: BOOL;
	// NO Home Switch: TRUE if at home
	{attribute 'pytmc' := '
		pv: PLC:bHome
		io: i
	'}
	bHome AT %I*: BOOL;
	// NC Brake Output: TRUE to release brake
	{attribute 'pytmc' := '
		pv: PLC:bBrakeRelease
		io: i
	'}
	bBrakeRelease AT %Q*: BOOL;
	// NC STO Input: TRUE if ok to move
	{attribute 'pytmc' := '
		pv: PLC:bHardwareEnable
		io: i
	'}
	bHardwareEnable AT %I*: BOOL;

	(* Psuedo-hardware *)
	
	// Forward enable EPS summary
	{attribute 'pytmc' := '
		pv: PLC:bAllForwardEnable
		io: i
	'}
	bAllForwardEnable: BOOL:=FALSE;
	// Backward enable EPS summary
	{attribute 'pytmc' := '
		pv: PLC:bAllBackwardEnable
		io: i
	'}
	bAllBackwardEnable: BOOL:=FALSE; 
	// Enable EPS summary encapsulating emergency stop button and any additional motion preventive hardware
	{attribute 'pytmc' := '
		pv: PLC:bAllEnable
		io: i
	'}
	bAllEnable: BOOL:=FALSE;
	// Forward virtual gantry limit switch
	{attribute 'pytmc' := '
		pv: PLC:bGantryForwardEnable
		io: i
	'}
	bGantryForwardEnable: BOOL:=FALSE;
	// Backward virtual gantry limit switch
	{attribute 'pytmc' := '
		pv: PLC:bGantryBackwardEnable
		io: i
	'}
	bGantryBackwardEnable: BOOL:=FALSE;
	
	(* Settings *)
	// Change to FALSE if MC_POWER is somewhere else in the project
	{attribute 'pytmc' := '
		pv: PLC:bPowerSelf
		io: i
	'}
	bPowerSelf: BOOL:=TRUE;
	// Determines when we automatically enable the motor
	{attribute 'pytmc' := '
		pv: PLC:nEnableMode
		io: i
	'}
	nEnableMode: INT:=ENUM_StageEnableMode.STAGE_ENABLE_MOTION;
	// Determines when we automatically disengage the brake
	{attribute 'pytmc' := '
		pv: PLC:nBrakeMode
		io: i
	'}
	nBrakeMode: INT:=ENUM_StageBrakeMode.STAGE_BRAKE_DISABLED;
	// Determines our encoder homing strategy
	{attribute 'pytmc' := '
		pv: PLC:nHomingMode
		io: i
	'}
	nHomingMode: INT:=ENUM_EpicsHomeCmd.EPICS_MOTOR_HOME_NONE;
	// Set true to activate gantry EPS
	{attribute 'pytmc' := '
		pv: PLC:bGantryAxis
		io: i
	'}
	bGantryAxis: BOOL:=FALSE;
	// Set to gantry difference tolerance
	{attribute 'pytmc' := '
		pv: PLC:nGantryTol
		io: i
	'}
	nGantryTol: LINT:=0;
	// Encoder count at which this axis is aligned with other axis
	{attribute 'pytmc' := '
		pv: PLC:nEncRef
		io: i
	'}
	nEncRef: ULINT:=0;
	
	(* Commands *)
	// Used internally to request enables
	{attribute 'pytmc' := '
		pv: PLC:bEnable
		io: io
	'}
	bEnable: BOOL;
	// Used internally to reset errors and other state
	{attribute 'pytmc' := '
		pv: PLC:bReset
		io: io
	'}
	bReset: BOOL;
	// Used internally and by the IOC to start or stop a move
	{attribute 'pytmc' := '
		pv: PLC:bExecute
		io: io
	'}
	bExecute: BOOL;
	
	(* Command Args *)
	// Used internally and by the IOC to pick what kind of move to do
	{attribute 'pytmc' := '
		pv: PLC:nCommand
		io: io
	'}
	nCommand: INT;
	// Used internally and by the IOC to pass additional data to some commands
	{attribute 'pytmc' := '
		pv: PLC:nCmdData
		io: io
	'}
	nCmdData: INT;
	// Used internally and by the IOC to pick a destination for the move
	{attribute 'pytmc' := '
		pv: PLC:fPosition
		io: io
	'}
	fPosition: LREAL;
	// Used internally and by the IOC to pick a move velocity
	{attribute 'pytmc' := '
		pv: PLC:fVelocity
		io: io
	'}
	fVelocity: LREAL;
	// Used internally and by the IOC to pick a move acceleration
	{attribute 'pytmc' := '
		pv: PLC:fAcceleration
		io: io
	'}
	fAcceleration: LREAL;
	// Used internally and by the IOC to pick a move deceleration
	{attribute 'pytmc' := '
		pv: PLC:fDeceleration
		io: io
	'}
	fDeceleration: LREAL;
	// Used internally and by the IOC to pick a home position
	{attribute 'pytmc' := '
		pv: PLC:fHomePosition
		io: io
	'}
	fHomePosition: LREAL;
	
	(* Info *)
	// Unique ID assigned to each axis in the NC
	{attribute 'pytmc' := '
		pv: PLC:nMotionAxisID
		io: i
	'}
	nMotionAxisID: UDINT:=0;
	
	(* Returns *)
	// TRUE if done enabling
	{attribute 'pytmc' := '
		pv: PLC:bEnableDone
		io: i
	'}
	bEnableDone: BOOL;
	// TRUE if in the middle of a command
	{attribute 'pytmc' := '
		pv: PLC:bBusy
		io: i
	'}
	bBusy: BOOL;
	// TRUE if we've done a command and it has finished
	{attribute 'pytmc' := '
		pv: PLC:bDone
		io: i
	'}
	bDone: BOOL;
	// TRUE if we're in an error state
	{attribute 'pytmc' := '
		pv: PLC:bError
		io: i
	'}
	bError: BOOL;
	// Message to identify the error state
	{attribute 'pytmc' := '
		pv: PLC:sErrorMessage
		io: i
	'}
	sErrorMessage: STRING;
	// Misc axis status information for the IOC
	stAxisStatus: DUT_AxisStatus_v0_01;
END_STRUCT
END_TYPE
```


DUTs/DUT_PositionState.TcDUT (TcPlcObject)
------------------------------------------

### DUT_PositionState: Declaration

```vhdl
TYPE DUT_PositionState :
// Include io: input on things that should never be mutable in EPICS.
// Omit io on things that may or may not need to be mutable, allow engineer to decide in their pragma.
// Currently: some installations would want position and delta to be mutable.
STRUCT
	{attribute 'pytmc' := '
		pv: NAME
		io: input
	'}
	sName: STRING;

	{attribute 'pytmc' := '
		pv: SETPOINT
		io: io
	'}
	fPosition: LREAL;
	
	{attribute 'pytmc' := '
		pv: DELTA
		io: io
	'}
	fDelta: LREAL;
	
	{attribute 'pytmc' := '
		pv: VELO
		io: io
	'}
	fVelocity: LREAL;
	
	{attribute 'pytmc' := '
		pv: ACCL
		io: io
	'}
	fAccel: LREAL;
	
	{attribute 'pytmc' := '
		pv: DCCL
		io: io
	'}
	fDecel: LREAL;
END_STRUCT
END_TYPE
```


DUTs/EL5042_Status.TcDUT (TcPlcObject)
--------------------------------------

### EL5042_Status: Declaration

```vhdl
TYPE EL5042_Status :
STRUCT
END_STRUCT
END_TYPE
```


DUTs/ENUM_EpicsHomeCmd.TcDUT (TcPlcObject)
------------------------------------------

### ENUM_EpicsHomeCmd: Declaration

```vhdl
{attribute 'qualified_only'}
{attribute 'strict'}
TYPE ENUM_EpicsHomeCmd :
(
	EPICS_MOTOR_HOME_LLS := 1, // Low limit switch
	EPICS_MOTOR_HOME_HLS := 2, // High limit switch
	EPICS_MOTOR_HOME_LHS := 3, // Home switch via low switch
	EPICS_MOTOR_HOME_HHS := 4, // Home switch via high switch
	EPICS_MOTOR_HOME_ABS := 15, // Set here to be fHomePosition
	EPICS_MOTOR_HOME_NONE := -1 // Do not home, ever
);
END_TYPE
```


DUTs/ENUM_EpicsMotorCmd.TcDUT (TcPlcObject)
-------------------------------------------

### ENUM_EpicsMotorCmd: Declaration

```vhdl
{attribute 'qualified_only'}
{attribute 'strict'}
TYPE ENUM_EpicsMotorCmd :
(
	EPICS_MOTOR_JOG := 0,
	EPICS_MOTOR_MOVE_VEL := 1,
	EPICS_MOTOR_MOVE_REL := 2,
	EPICS_MOTOR_MOVE_ABS := 3,
	EPICS_MOTOR_MOVE_MOD := 4,
	EPICS_MOTOR_HOME := 10,
	EPICS_MOTOR_GEAR := 30
);
END_TYPE
```


DUTs/ENUM_StageBrakeMode.TcDUT (TcPlcObject)
--------------------------------------------

### ENUM_StageBrakeMode: Declaration

```vhdl
{attribute 'qualified_only'}
{attribute 'strict'}
TYPE ENUM_StageBrakeMode :
(
	STAGE_BRAKE_DISABLED,
	STAGE_BRAKE_STANDSTILL
);
END_TYPE
```


DUTs/ENUM_StageEnableMode.TcDUT (TcPlcObject)
---------------------------------------------

### ENUM_StageEnableMode: Declaration

```vhdl
{attribute 'qualified_only'}
{attribute 'strict'}
TYPE ENUM_StageEnableMode :
(
	STAGE_ENABLE_ALWAYS, // Always set bEnable to TRUE
	STAGE_ENABLE_NEVER,  // Only change bEnable on errors
	STAGE_ENABLE_MOTION  // Enable before motion, disable after motion
);
END_TYPE
```


DUTs/ST_RenishawAbsEnc.TcDUT (TcPlcObject)
------------------------------------------

### ST_RenishawAbsEnc: Declaration

```vhdl
// Renishaw BiSS-C absolute encoder used with an EL5042 
TYPE ST_RenishawAbsEnc :
STRUCT
	Count AT %I*: ULINT; // Connect to encoder "Position" input
	Status: EL5042_Status; // Status struct placeholder
	Ref: ULINT; // Encoder zero position (useful for aligned position with gantries)
END_STRUCT
END_TYPE
```


PlcTask.TcTTO (TcPlcObject)
---------------------------


POUs/Motion/FB_MotionStage.TcPOU (TcPlcObject)
----------------------------------------------

### FB_MotionStage: Declaration

```vhdl
FUNCTION_BLOCK FB_MotionStage
VAR_IN_OUT
	stMotionStage: DUT_MotionStage;
END_VAR
VAR
	fbDriveVirtual: FB_DriveVirtual;
	bExecute: BOOL;
	bFwdHit: BOOL;
	bBwdHit: BOOL;
	fbExecFallingEdge: F_TRIG;
	fbSetEnables: FB_SetEnables;
END_VAR
```

### FB_MotionStage: ST

```vhdl
// Start with an accurate status
stMotionStage.Axis.ReadStatus();

// Handle auto-enable timing
CASE stMotionStage.nEnableMode OF
	ENUM_StageEnableMode.STAGE_ENABLE_ALWAYS:
		stMotionStage.bEnable := TRUE;
		bExecute := stMotionStage.bExecute;
	ENUM_StageEnableMode.STAGE_ENABLE_NEVER:
		bExecute := stMotionStage.bExecute;
	ENUM_StageEnableMode.STAGE_ENABLE_MOTION:
		IF stMotionStage.bExecute THEN
			stMotionStage.bEnable := TRUE;
		END_IF
		bExecute := stMotionStage.bExecute AND stMotionStage.bEnableDone;
END_CASE

// Automatically fill the correct nCmdData for homing
IF stMotionStage.nCommand = ENUM_EpicsMotorCmd.EPICS_MOTOR_HOME THEN
	stMotionStage.nCmdData := stMotionStage.nHomingMode;
END_IF

fbSetEnables(stMotionStage:=stMotionStage);

// Handle standard commands using ESS's FB
fbDriveVirtual(En:=TRUE,
	bEnable:=stMotionStage.bAllEnable,
	bReset:=stMotionStage.bReset,
	bExecute:=bExecute,
	nCommand:=INT_TO_UINT(stMotionStage.nCommand),
	nCmdData:=INT_TO_UINT(stMotionStage.nCmdData),
	fVelocity:=stMotionStage.fVelocity,
	fPosition:=stMotionStage.fPosition,
	fAcceleration:=stMotionStage.fAcceleration,
	fDeceleration:=stMotionStage.fDeceleration,
	bLimitFwd:=stMotionStage.bAllForwardEnable,
	bLimitBwd:=stMotionStage.bAllBackwardEnable,
	bHomeSensor:=stMotionStage.bHome,
	fHomePosition:=stMotionStage.fHomePosition,
	bPowerSelf:=stMotionStage.bPowerSelf,
	nMotionAxisID=>stMotionStage.nMotionAxisID,
	bError=>stMotionStage.bError,
	sErrorMessage=>stMotionStage.sErrorMessage,
	Axis:=stMotionStage.Axis);

IF fbDriveVirtual.bBusy THEN
	stMotionStage.bBusy := TRUE;
	stMotionStage.bDone := FALSE;
END_IF

IF stMotionStage.bError THEN
	stMotionStage.bBusy := FALSE;
	stMotionStage.bDone := FALSE;
	stMotionStage.bEnable := FALSE;
END_IF

// Check the limits and cancel execution if appropriate. Without this block we have infinite error spam
bFwdHit := stMotionStage.Axis.Status.PositiveDirection AND NOT stMotionStage.bAllForwardEnable;
bBwdHit := stMotionStage.Axis.Status.NegativeDirection AND NOT stMotionStage.bAllBackwardEnable;
IF bFwdHit OR bBwdHit THEN
	stMotionStage.bExecute := FALSE;
END_IF

// Mark done if settled or if unexpected stop, then reset the FB if there is no error
fbExecFallingEdge(CLK:=stMotionStage.bExecute);
IF (stMotionStage.Axis.Status.InTargetPosition AND NOT fbDriveVirtual.bBusy) OR fbExecFallingEdge.Q THEN
	IF NOT stMotionStage.bDone THEN
		stMotionStage.bDone := TRUE;
		stMotionStage.bBusy := FALSE;
		IF NOT stMotionStage.Axis.Status.Error THEN
			bExecute := FALSE;
			stMotionStage.bExecute := FALSE;
		END_IF
	END_IF
END_IF
IF stMotionStage.nEnableMode = ENUM_StageEnableMode.STAGE_ENABLE_MOTION AND NOT bExecute THEN
	IF stMotionStage.Axis.Status.MotionState = MC_AXISSTATE_STANDSTILL THEN
		stMotionStage.bEnable := FALSE;
	END_IF
END_IF

// Get a definitive bEnabled reading
CASE stMotionStage.Axis.Status.MotionState OF
	// We are not enabled if there is an issue
	MC_AXISSTATE_UNDEFINED, MC_AXISSTATE_DISABLED, MC_AXISSTATE_ERRORSTOP:
		stMotionStage.bEnableDone := FALSE;
	ELSE
		stMotionStage.bEnableDone := TRUE;
END_CASE

// Handle the brake. TRUE means brake disabled.
CASE stMotionStage.nBrakeMode OF
	ENUM_StageBrakeMode.STAGE_BRAKE_DISABLED:
		stMotionStage.bBrakeRelease := stMotionStage.bEnableDone AND stMotionStage.bExecute;
	ENUM_StageBrakeMode.STAGE_BRAKE_STANDSTILL:
		IF stMotionStage.Axis.Status.MotionState = MC_AXISSTATE_STANDSTILL THEN
			stMotionStage.bBrakeRelease := FALSE;
		ELSE
			stMotionStage.bBrakeRelease := TRUE;
		END_IF
END_CASE
CASE stMotionStage.Axis.Status.MotionState OF
	MC_AXISSTATE_UNDEFINED, MC_AXISSTATE_ERRORSTOP:
		stMotionStage.bBrakeRelease := FALSE;
END_CASE

// Sync the epics status struct
stMotionStage.stAxisStatus := fbDriveVirtual.stAxisStatus;
stMotionStage.stAxisStatus.bEnabled := stMotionStage.bEnableDone;

// Reset everything when bReset is flagged
IF stMotionStage.bReset THEN
	stMotionStage.bEnable := FALSE;
	stMotionStage.bReset := FALSE;
	stMotionStage.bExecute := FALSE;
	bExecute := FALSE;
END_IF

// Ignore homing if we have the setting for it
// e.g. for pre-calibrated absolute encoders
IF stMotionStage.nHomingMode = ENUM_EpicsHomeCmd.EPICS_MOTOR_HOME_NONE THEN
	stMotionStage.stAxisStatus.bHomed := TRUE;
END_IF
```


POUs/Motion/FB_SetEnables.TcPOU (TcPlcObject)
---------------------------------------------

### FB_SetEnables: Declaration

```vhdl
FUNCTION_BLOCK FB_SetEnables
VAR_IN_OUT
	stMotionStage: DUT_MotionStage;
END_VAR
```

### FB_SetEnables: ST

```vhdl
stMotionStage.bAllForwardEnable := stMotionStage.bLimitForwardEnable AND (stMotionStage.bGantryForwardEnable OR NOT stMotionStage.bGantryAxis);
stMotionStage.bAllBackwardEnable := stMotionStage.bLimitBackwardEnable AND (stMotionStage.bGantryBackwardEnable OR NOT stMotionStage.bGantryAxis);

stMotionStage.bAllEnable := stMotionStage.bEnable AND stMotionStage.bHardwareEnable;
```


POUs/Motion/FB_StatePTPMove.TcPOU (TcPlcObject)
-----------------------------------------------

### FB_StatePTPMove: Declaration

```vhdl
FUNCTION_BLOCK FB_StatePTPMove
// For your pytmc pragma on this block, specify io accordingly:
// 1. use input or i if you want the set position to be immutable
// 2. use io if you want to set position to be mutable from epics
VAR_INPUT
	{attribute 'pytmc' := '
		pv:
	'}
	stPositionState: DUT_PositionState;
	
	{attribute 'pytmc' := '
		pv: GO
		io: io
		field: ZNAM False
		field: ONAM True
	'}
	bExecute: BOOL;
	
	{attribute 'pytmc' := '
		pv: MOVE_OK
		io: input
		field: ZNAM False
		field: ONAM True
	'}
	bMoveOk: BOOL;
END_VAR
VAR_IN_OUT
	stMotionStage: DUT_MotionStage;
END_VAR
VAR_OUTPUT
	{attribute 'pytmc' := '
		pv: AT_STATE
		io: input
		field: ZNAM False
		field: ONAM True
	'}
	bAtState: BOOL;
	
	{attribute 'pytmc' := '
		pv: DMOV
		io: input
		field: ZNAM False
		field: ONAM True
	'}
	bDone: BOOL;
	
	{attribute 'pytmc' := '
		pv: BUSY
		io: input
		field: ZNAM False
		field: ONAM True
	'}
	bBusy: BOOL;
	
	{attribute 'pytmc' := '
		pv: ERR
		io: input
		field: ZNAM False
		field: ONAM True
	'}
	bError: BOOL;
	
	{attribute 'pytmc' := '
		pv: ERRMSG
		io: input
	'}
	sError: STRING;
END_VAR
VAR
	bExecTrig: R_TRIG;
	bExecEnd: F_TRIG;
	fActPosition: LREAL;
	fLowPos: LREAL;
	fHighPos: LREAL;
END_VAR
```

### FB_StatePTPMove: ST

```vhdl
bExecTrig(CLK:=bExecute);
IF bExecTrig.Q AND bMoveOk THEN
	IF NOT stMotionStage.bBusy AND NOT stMotionStage.bError THEN
		stMotionStage.bExecute := TRUE;
		stMotionStage.nCommand := ENUM_EpicsMotorCmd.EPICS_MOTOR_MOVE_ABS;
		stMotionStage.fPosition := stPositionState.fPosition;
		stMotionStage.fVelocity := stPositionState.fVelocity;
		stMotionStage.fAcceleration := stPositionState.fAccel;
		stMotionStage.fDeceleration := stPositionState.fDecel;
		bDone := FALSE;
		bBusy := TRUE;
	END_IF
END_IF
bError := stMotionStage.bError;
sError := stMotionStage.sErrorMessage;

fActPosition := stMotionStage.stAxisStatus.fActPosition;
fLowPos := stPositionState.fPosition - stPositionState.fDelta;
fHighPos := stPositionState.fPosition + stPositionState.fDelta;
IF (fLowPos < fActPosition) AND (fHighPos > fActPosition) THEN
	bAtState := TRUE;
	IF NOT stMotionStage.bBusy THEN
		bDone := TRUE;
		bBusy := FALSE;
		bExecute := FALSE;
	END_IF
ELSE
	bAtState := FALSE;
END_IF

bExecEnd(CLK:=bExecute);
IF bExecEnd.Q AND bBusy THEN
	stMotionStage.bExecute := FALSE;
END_IF

IF NOT stMotionStage.bExecute OR NOT bExecute THEN
	bDone := TRUE;
	bBusy := FALSE;
	bExecute := FALSE;
END_IF
```


POUs/Motion/Gantry/FB_GantryAutoCoupling.TcPOU (TcPlcObject)
------------------------------------------------------------

### FB_GantryAutoCoupling: Declaration

```vhdl
FUNCTION_BLOCK FB_GantryAutoCoupling
VAR_INPUT
	nGantryTol : LINT;
END_VAR
VAR_OUTPUT
	bGantryAlreadyCoupled : BOOL;
END_VAR
VAR_IN_OUT
	Master : DUT_MotionStage;
	MasterEnc : ST_RenishawAbsEnc;
	Slave : DUT_MotionStage;
	SlaveEnc : ST_RenishawAbsEnc;
	bExecuteCouple : BOOL;
	bExecuteDecouple : BOOL;
END_VAR
VAR
	gantry_diff_limit : FB_GantryDiffVirtualLimitSwitch;
	couple : MC_GEARIN;
	decouple : MC_GEAROUT;
	bInitComplete : BOOL;
	fbSetEnables : FB_SetEnables;
END_VAR
```

### FB_GantryAutoCoupling: ST

```vhdl
// Designate Master and SLave Axes
Master.bGantryAxis := TRUE;
Slave.bGantryAxis := TRUE;

Master.nGantryTol := nGantryTol;
Slave.nGantryTol := Master.nGantryTol;

// Activate Gantry Virtual Limit Switch
gantry_diff_limit(Penc:=MasterEnc, SEnc:=SlaveEnc, GantDiffTol:=Master.nGantryTol,
				  PLimFwd=>Master.bGantryForwardEnable, PLimBwd=>Master.bGantryBackwardEnable,
				  SLimFwd=>Slave.bGantryForwardEnable, SLimBwd=>Slave.bGantryBackwardEnable);

// Coupling Status Bit
bGantryAlreadyCoupled := Master.Axis.NcToPlc.CoupleState=1 AND Slave.Axis.NcToPlc.CoupleState=3;

fbSetEnables(stMotionStage:=Master);
fbSetEnables(stMotionStage:=Slave);

IF bGantryAlreadyCoupled THEN
	Master.bGantryForwardEnable := Master.bGantryForwardEnable AND Slave.bAllForwardEnable;
	Slave.bGantryForwardEnable := Master.bAllForwardEnable AND Slave.bGantryForwardEnable;
	
	Master.bGantryBackwardEnable := Master.bGantryBackwardEnable AND Slave.bAllBackwardEnable;
	Slave.bGantryBackwardEnable := Master.bAllBackwardEnable AND Slave.bGantryBackwardEnable;
END_IF


// Coupling states
// Auto-coupling at init and auto-reset of coupling boolean
bExecuteCouple S= NOT bInitComplete;

bExecuteCouple R= couple.Busy OR bGantryAlreadyCoupled;
couple(Master:=Master.Axis, Slave:=Slave.Axis, Execute:=bExecuteCouple);

bInitComplete S= bGantryAlreadyCoupled;

// Decoupling with auto-reset of coupling boolean
bExecuteDecouple R= decouple.Busy OR NOT bGantryAlreadyCoupled;
decouple(Slave:=Slave.Axis, Execute:=bExecuteDecouple);
```


POUs/Motion/Gantry/FB_GantryDiffVirtualLimitSwitch.TcPOU (TcPlcObject)
----------------------------------------------------------------------

### FB_GantryDiffVirtualLimitSwitch: Declaration

```vhdl
FUNCTION_BLOCK FB_GantryDiffVirtualLimitSwitch
VAR_INPUT
	PEnc: ST_RenishawAbsEnc; // Primary axis encoder (usually the upstream one)
	SEnc: ST_RenishawAbsEnc; // Secondary axis encoder (couples to the primary)
	
	GantDiffTol: LINT;		// Gantry differenace tolerance in encoder counts
END_VAR
VAR_OUTPUT
	PLimFwd: BOOL; // Primary axis forward direction enable
	PLimBwd: BOOL; // Primary axis reverse direction enable
	SLimFwd: BOOL; // Secondary axis forward direction enable
	SLimBwd: BOOL; // Secondary axis reverse direction enable
END_VAR
VAR
	GantryDiff: LINT;
END_VAR
```

### FB_GantryDiffVirtualLimitSwitch: ST

```vhdl
(* Gantry Difference Virtual Limit Switch
A. Wallace 2017-2-15

Determines which direction is disabled due to it increasing the gantry difference.
Refer to the ESD for actual conventions.

A positive gantry error refers to a CCW clocked assembly:
eg. for X
X1 upstream, X2 downstream. Primary axis is always upstream.
Gantry difference > 0 when
X2>X1
Therefore
X2 positive direction disabled
X1 negative direction disabled

Call before FB_MotionStage fb calls for the gantry axes.
*)

GantryDiff := ( ULINT_TO_LINT(PEnc.Count) - ULINT_TO_LINT(PEnc.Ref) ) - ( ULINT_TO_LINT(SEnc.Count) - ULINT_TO_LINT(SEnc.Ref) );

IF ABS(GantryDiff) > GantDiffTol THEN
	IF GantryDiff < 0  THEN
		PLimBwd := FALSE;
		SLimFwd := FALSE;
	ELSE	
		PLimBwd := TRUE;
		SLimFwd := TRUE;
	END_IF
	IF GantryDiff > 0 THEN
		PLimFwd := FALSE;
		SLimBwd := FALSE;
	ELSE
		PLimFwd := TRUE;
		SLimBwd := TRUE;
	END_IF
ELSE
	//If there is no fault, all directions are enabled
	PLimFwd := TRUE;
	PLimBwd := TRUE;
	SLimFwd := TRUE;
	SLimBwd := TRUE;
END_IF
```


POUs/MotorTesting/FB_MicroStepCountTest.TcPOU (TcPlcObject)
-----------------------------------------------------------

### FB_MicroStepCountTest: Declaration

```vhdl
FUNCTION_BLOCK FB_MicroStepCountTest
VAR_INPUT
	bExecute: BOOL;
	fStepSize: LREAL;
	nSteps: UINT;
	fMicroStep: LREAL;
	fVelocity: LREAL;
	tSettleTime: TIME;
END_VAR
VAR_IN_OUT
	Axis: AXIS_REF;
END_VAR
VAR_OUTPUT
	nStepsCounted: UINT;
	nTheorySteps: UINT;
	fPercent: LREAL;
	fEstMicroSize: LREAL;
END_VAR
VAR
	fbMoveRel: MC_MoveRelative;
	fbSettleTimer: TON;
	bDoMove: BOOL;
	nStepCounter: UINT;
	
	arrPosBuffer: ARRAY [0..99] OF LREAL;
	fAvgPos: LREAL;
	nArrIndex: UINT;
	nLoopIndex: UINT;
	
	fStartPos: LREAL;
	fPrevPos: LREAL;
	fStepChange: LREAL;
	
	fStepSum: LREAL;
END_VAR
```

### FB_MicroStepCountTest: ST

```vhdl
// Motion FB
fbMoveRel(Axis:=Axis,
	Execute:=bDoMove,
	Distance:=fStepSize,
	Velocity:=fVelocity);
	
// Settle time
fbSettleTimer(IN:=fbMoveRel.Done,
	PT:=tSettleTime);
	
// Re-enable the move for next cycle
bDoMove := bExecute AND nStepCounter < nSteps;

// Calculate rolling average
arrPosBuffer[nArrIndex] := Axis.NcToPlc.ActPos;
fAvgPos := 0;
FOR nLoopIndex := 0 TO 99 DO
	fAvgPos := fAvgPos + arrPosBuffer[nLoopIndex];
END_FOR;
fAvgPos := fAvgPos / 100;
nArrIndex := (nArrIndex + 1) MOD 100;

// Initialize starting variables
IF NOT bExecute THEN
	fStartPos := fAvgPos;
	fPrevPos := fAvgPos;
END_IF

// Check results
IF fbSettleTimer.Q THEN
	fStepChange := fAvgPos - fPrevPos;
	// Invert fStepChange if we were doing negative steps
	IF fStepSize < 0 THEN
		fStepChange := fStepChange * -1;
	END_IF
	IF fStepChange > fMicroStep * 0.5 THEN
		nStepsCounted := nStepsCounted + 1;
		fStepSum := fStepSum + fStepChange;
		fEstMicroSize := fStepSum / nStepsCounted;
	END_IF
	nTheorySteps := DINT_TO_UINT(TRUNC(ABS((fStartPos - fAvgPos) / fMicroStep)));
	IF nTheorySteps > 0 THEN
		fPercent := 100 * nStepsCounted / nTheorySteps;
	END_IF
	fPrevPos := fAvgPos;
	nStepCounter := nStepCounter + 1;
	// Reset the move block
	bDoMove := FALSE;
END_IF
```


tc_mca_std_lib/DUTs/DUT_AxisStatus_v0_01.TcDUT (TcPlcObject)
------------------------------------------------------------

### DUT_AxisStatus_v0_01: Declaration

```vhdl
TYPE DUT_AxisStatus_v0_01 :
STRUCT
	bEnable: BOOL;
	bReset: BOOL;
	bExecute: BOOL;
	nCommand: UINT;
	nCmdData: UINT;
	fVelocity: LREAL;
	fPosition: LREAL;
	fAcceleration: LREAL;
	fDeceleration: LREAL;
	bJogFwd: BOOL;
	bJogBwd: BOOL;
	bLimitFwd: BOOL;
	bLimitBwd: BOOL;
	fOverride: LREAL := 100;
	bHomeSensor: BOOL;
	bEnabled: BOOL;
	bError: BOOL;
	nErrorId: UDINT;
	fActVelocity: LREAL;
	fActPosition: LREAL;
	fActDiff: LREAL;
	bHomed:BOOL;
	bBusy:BOOL;
END_STRUCT
END_TYPE
```


tc_mca_std_lib/GVLs/GVL.TcGVL (TcPlcObject)
-------------------------------------------

### GVL: Declaration

```vhdl
VAR_GLOBAL
	nHomingError:UDINT:=16#14D00;
END_VAR
```


tc_mca_std_lib/POUs/ChangeConfig/FB_ReadFloatParameter.TcPOU (TcPlcObject)
--------------------------------------------------------------------------

### FB_ReadFloatParameter: Declaration

```vhdl
FUNCTION_BLOCK FB_ReadFloatParameter
VAR_INPUT
	bExecute: BOOL;
	///16#4000=Axisdata, 16#5000=Encoderdata, 16#6000=Controldata, 16#7000=Drivedata
	nDeviceGroup: UDINT;
	nIndexOffset: UDINT;
END_VAR
VAR_OUTPUT
	nData: LREAL;
	bBusy: BOOL;
	bDone: BOOL;
	bError: BOOL;
	nErrorId: UDINT;
END_VAR
VAR_IN_OUT
	Axis: AXIS_REF;
END_VAR
VAR
	nState: UINT;
	fbADSREAD: ADSREAD;
END_VAR
```

### FB_ReadFloatParameter: ST

```vhdl
(*Sequence to read parameter in Nc*)
CASE nState OF
0:  (*Start sequence. Wait until bExecute is TRUE*)
	IF bExecute THEN
		bBusy:=TRUE;
		bError:=FALSE;
		nErrorId:=0;
		nState:=10;
	END_IF

10: (*Read parameter in Nc*)
	fbADSREAD(
		PORT:=500,
		IDXGRP:=nDeviceGroup+Axis.NcToPlc.AxisId,
		IDXOFFS:=nIndexOffset,
		LEN:=SIZEOF(nData),
		DESTADDR:=ADR(nData),
		READ:=TRUE);

	(*Wait until it's done or if an error occurs*)
	IF NOT fbADSREAD.ERR THEN
		IF NOT fbADSREAD.BUSY THEN
			fbADSREAD(READ:=FALSE);
			nState:=20;
		END_IF
	ELSE
		nErrorId:=fbADSREAD.ERRID;
		nState:=999;
	END_IF

20: (*Sequense is done. Waits until bExecute is FALSE*)
	bBusy:=FALSE;
	bDone:=TRUE;
	IF NOT bExecute THEN
		bDone:=FALSE;
		nState:=0;
	END_IF

999: (*Error in sequence*)
	bError:=TRUE;
	bBusy:=FALSE;
	bDone:=FALSE;
	fbADSREAD(READ:=FALSE);
	IF NOT bExecute THEN
		nState:=0;
	END_IF

END_CASE
```


tc_mca_std_lib/POUs/ChangeConfig/FB_ReadParameterInNc_v1_00.TcPOU (TcPlcObject)
-------------------------------------------------------------------------------

### FB_ReadParameterInNc_v1_00: Declaration

```vhdl
///#########################################################
///Function block to read parameter in Nc.
///
///	Library:		
///	Tc2_MC2.lib
/// Tc2_System.lib
///
///	Global Variables:
///	
///	Data types:
///	
///	External functions:
///
///	History:
///	2014-02-05	v1.00	NB	Release code.
///
///	Known bugs:
///
///
///
///###########################################################
FUNCTION_BLOCK FB_ReadParameterInNc_v1_00
VAR_INPUT
	bExecute: BOOL;
	///16#4000=Axisdata, 16#5000=Encoderdata, 16#6000=Controldata, 16#7000=Drivedata
	nDeviceGroup: UDINT;
	nIndexOffset: UDINT;
END_VAR
VAR_OUTPUT
	nData: DWORD;
	bBusy: BOOL;
	bDone: BOOL;
	bError: BOOL;
	nErrorId: UDINT;
END_VAR
VAR_IN_OUT
	Axis: AXIS_REF;
END_VAR
VAR
	nState: UINT;
	fbADSREAD: ADSREAD;
END_VAR
```

### FB_ReadParameterInNc_v1_00: ST

```vhdl
(*Sequence to read parameter in Nc*)
CASE nState OF
0:  (*Start sequence. Wait until bExecute is TRUE*)
	IF bExecute THEN
		bBusy:=TRUE;
		bError:=FALSE;
		nErrorId:=0;
		nState:=10;
	END_IF

10: (*Read parameter in Nc*)
	fbADSREAD(
		PORT:=500,
		IDXGRP:=nDeviceGroup+Axis.NcToPlc.AxisId,
		IDXOFFS:=nIndexOffset,
		LEN:=SIZEOF(nData),
		DESTADDR:=ADR(nData),
		READ:=TRUE);

	(*Wait until it's done or if an error occurs*)
	IF NOT fbADSREAD.ERR THEN
		IF NOT fbADSREAD.BUSY THEN
			fbADSREAD(READ:=FALSE);
			nState:=20;
		END_IF
	ELSE
		nErrorId:=fbADSREAD.ERRID;
		nState:=999;
	END_IF

20: (*Sequense is done. Waits until bExecute is FALSE*)
	bBusy:=FALSE;
	bDone:=TRUE;
	IF NOT bExecute THEN
		bDone:=FALSE;
		nState:=0;
	END_IF

999: (*Error in sequence*)
	bError:=TRUE;
	bBusy:=FALSE;
	bDone:=FALSE;
	fbADSREAD(READ:=FALSE);
	IF NOT bExecute THEN
		nState:=0;
	END_IF

END_CASE
```


tc_mca_std_lib/POUs/ChangeConfig/FB_WriteFloatParameter.TcPOU (TcPlcObject)
---------------------------------------------------------------------------

### FB_WriteFloatParameter: Declaration

```vhdl
///#########################################################
///Function block to write parameter in Nc.
///
///	Library:		
///	Tc2_MC2.lib
/// Tc2_System.lib
///
///	Global Variables:
///	
///	Data types:
///	
///	External functions:
///
///	History:
///	2014-02-05	v1.00	NB	Release code.
///
///	Known bugs:
///
///
///
///###########################################################
FUNCTION_BLOCK FB_WriteFloatParameter
VAR_INPUT
	bExecute: BOOL;
	///16#4000=Axisdata, 16#5000=Encoderdata, 16#6000=Controldata, 16#7000=Drivedata
	nDeviceGroup: UDINT;
	nIndexOffset: UDINT;
	nData: LREAL;
END_VAR
VAR_OUTPUT
	bBusy: BOOL;
	bDone: BOOL;
	bError: BOOL;
	nErrorId: UDINT;
END_VAR
VAR_IN_OUT
	Axis: AXIS_REF;
END_VAR
VAR
	nState: UINT;
	fbADSWRITE: ADSWRITE;
END_VAR
```

### FB_WriteFloatParameter: ST

```vhdl
(*Sequence to write parameter in Nc*)
CASE nState OF
0:  (*Start sequence. Wait until bExecute is TRUE*)
	IF bExecute THEN
		bBusy:=TRUE;
		bError:=FALSE;
		nErrorId:=0;
		nState:=10;
	END_IF

10: (*Write parameter in Nc*)
	fbADSWRITE(
		PORT:=500,
		IDXGRP:=nDeviceGroup+Axis.NcToPlc.AxisId,
		IDXOFFS:=nIndexOffset,
		LEN:=SIZEOF(nData),
		SRCADDR:=ADR(nData),
		WRITE:=TRUE);

	(*Wait until it's done or if an error occurs*)
	IF NOT fbADSWRITE.ERR THEN
		IF NOT fbADSWRITE.BUSY THEN
			fbADSWRITE(WRITE:=FALSE);
			nState:=20;
		END_IF
	ELSE
		nErrorId:=fbADSWRITE.ERRID;
		nState:=999;
	END_IF

20: (*Sequense is done. Waits until bExecute is FALSE*)
	bBusy:=FALSE;
	bDone:=TRUE;
	IF NOT bExecute THEN
		bDone:=FALSE;
		nState:=0;
	END_IF

999: (*Error in sequence*)
	bError:=TRUE;
	bBusy:=FALSE;
	bDone:=FALSE;
	fbADSWRITE(WRITE:=FALSE);
	IF NOT bExecute THEN
		nState:=0;
	END_IF

END_CASE
```


tc_mca_std_lib/POUs/ChangeConfig/FB_WriteParameterInNc_v1_00.TcPOU (TcPlcObject)
--------------------------------------------------------------------------------

### FB_WriteParameterInNc_v1_00: Declaration

```vhdl
///#########################################################
///Function block to write parameter in Nc.
///
///	Library:		
///	Tc2_MC2.lib
/// Tc2_System.lib
///
///	Global Variables:
///	
///	Data types:
///	
///	External functions:
///
///	History:
///	2014-02-05	v1.00	NB	Release code.
///
///	Known bugs:
///
///
///
///###########################################################
FUNCTION_BLOCK FB_WriteParameterInNc_v1_00
VAR_INPUT
	bExecute: BOOL;
	///16#4000=Axisdata, 16#5000=Encoderdata, 16#6000=Controldata, 16#7000=Drivedata
	nDeviceGroup: UDINT;
	nIndexOffset: UDINT;
	nData: DWORD;
END_VAR
VAR_OUTPUT
	bBusy: BOOL;
	bDone: BOOL;
	bError: BOOL;
	nErrorId: UDINT;
END_VAR
VAR_IN_OUT
	Axis: AXIS_REF;
END_VAR
VAR
	nState: UINT;
	fbADSWRITE: ADSWRITE;
END_VAR
```

### FB_WriteParameterInNc_v1_00: ST

```vhdl
(*Sequence to write parameter in Nc*)
CASE nState OF
0:  (*Start sequence. Wait until bExecute is TRUE*)
	IF bExecute THEN
		bBusy:=TRUE;
		bError:=FALSE;
		nErrorId:=0;
		nState:=10;
	END_IF

10: (*Write parameter in Nc*)
	fbADSWRITE(
		PORT:=500,
		IDXGRP:=nDeviceGroup+Axis.NcToPlc.AxisId,
		IDXOFFS:=nIndexOffset,
		LEN:=SIZEOF(nData),
		SRCADDR:=ADR(nData),
		WRITE:=TRUE);

	(*Wait until it's done or if an error occurs*)
	IF NOT fbADSWRITE.ERR THEN
		IF NOT fbADSWRITE.BUSY THEN
			fbADSWRITE(WRITE:=FALSE);
			nState:=20;
		END_IF
	ELSE
		nErrorId:=fbADSWRITE.ERRID;
		nState:=999;
	END_IF

20: (*Sequense is done. Waits until bExecute is FALSE*)
	bBusy:=FALSE;
	bDone:=TRUE;
	IF NOT bExecute THEN
		bDone:=FALSE;
		nState:=0;
	END_IF

999: (*Error in sequence*)
	bError:=TRUE;
	bBusy:=FALSE;
	bDone:=FALSE;
	fbADSWRITE(WRITE:=FALSE);
	IF NOT bExecute THEN
		nState:=0;
	END_IF

END_CASE
```


tc_mca_std_lib/POUs/ErrorHandling/DUT_ErrorState.TcDUT (TcPlcObject)
--------------------------------------------------------------------

### DUT_ErrorState: Declaration

```vhdl
{attribute 'qualified_only'}
{attribute 'strict'}
TYPE DUT_ErrorState :
(
	None,
	Active,
	Inactive,
	Acknowledged
);
END_TYPE
```


tc_mca_std_lib/POUs/ErrorHandling/DUT_TerminalError.TcDUT (TcPlcObject)
-----------------------------------------------------------------------

### DUT_TerminalError: Declaration

```vhdl
TYPE DUT_TerminalError :
STRUCT
	//Error system related
	iTerminalID : INT;					//ID of the terminal
	Error_ID : ULINT := 0;				//ID for the Error entry
	ErrorState : DUT_ErrorState;		//State of the error
	
	//Error related
	nDateTimeOn : ULINT;				//Date and time when the error occured. Raw data
	sDateTimeOn : STRING(24);			//Date and time when the error occured. Readable format
	nDateTimeOff : ULINT;				//Date and time when the error disapeared. Raw data
	sDateTimeOff : STRING(24);			//Date and time when the error disapeared. Readable format
	bWcState : BOOL;					//WcState variable of the terminal
	uiInfoDataState : UINT;				//InfoData.State variable of the terminal
	sErrorMessage : STRING (128);		//Error message corresponding to WcState and InfoData.State
	ErrorType : INT; 					//Error types (priorities) need to be developed
END_STRUCT
END_TYPE
```


tc_mca_std_lib/POUs/ErrorHandling/FB_ErrorList.TcPOU (TcPlcObject)
------------------------------------------------------------------

### FB_ErrorList: Declaration

```vhdl
FUNCTION_BLOCK FB_ErrorList

VAR_INPUT
	En : BOOL;											//Enable input
	bReset : BOOL;										//Delete all Error entry
	lErrorID : ULINT;									//ErrorID to be acknoledged
	bACK : BOOL;										//Acknoledge the given error and delete it from the list
END_VAR
	
VAR_OUTPUT
	EnO : BOOL;											//Enable output
	nNoError: UINT;										//Number of Errors
	nNoOverflow : INT;									//Number of Overflows
	pErrorSystem : POINTER TO ST_ErrorSystem;			//Pointer to ErrorSystem
END_VAR

VAR
	nFreePos : UINT;									//Number of free position in the list
	nListCnt1 : UINT;									//work variable
	ErrorSystem : ST_ErrorSystem;						//Data structure of the Error list
END_VAR
```

### FB_ErrorList: ST

```vhdl
(*
* ================================================================================
*                                   DESCRIPTION
* ================================================================================
* This Function Block implements the core structure of the Error/Warning Handling
* system. It realizes the datastructure containing every Error Entry, collect
* statistics about the usage and manage the Error Entries.
* Note: The system is under development, most of the functionalities are not
* implemented or existing functionalities may change with time.
* ================================================================================
*)
EnO := En;

//Ponter to ErrorSystem
pErrorSystem := ADR(ErrorSystem);

//Number of overflows
nNoOverflow := ErrorSystem.nNoOverflows;

IF bReset THEN
	MEMSET ( ADR(ErrorSystem.aErrorData[0]), 0, GVL_ErrorSystem.cSizeOfErrorData * SIZEOF(DUT_TerminalError));
	ErrorSystem.lNextErrorID := 1;
END_IF

//Number of errors in the system
nNoError := 0;
FOR nListCnt1 := 0 TO GVL_ErrorSystem.cSizeOfErrorData - 1 DO
	IF ErrorSystem.aErrorData[nListCnt1].Error_ID <> 0  THEN
		nNoError := nNoError+1; 
	END_IF
END_FOR
ErrorSystem.nNoErrors := nNoError;

//Number of free position in the list
nFreePos := GVL_ErrorSystem.cSizeOfErrorData - nNoError;

//Acknoledge specified Error entry
IF bACK THEN
	FOR nListCnt1 := 0 TO GVL_ErrorSystem.cSizeOfErrorData - 1 DO
		IF ErrorSystem.aErrorData[nListCnt1].Error_ID = lErrorID THEN
			ErrorSystem.aErrorData[nListCnt1].ErrorState := DUT_ErrorState.Acknowledged;
		END_IF
	END_FOR
END_IF

//Deleting acknoledged errors
FOR nListCnt1 := 0 TO GVL_ErrorSystem.cSizeOfErrorData - 1 DO
	IF ErrorSystem.aErrorData[nListCnt1].ErrorState = DUT_ErrorState.Acknowledged THEN
		MEMMOVE (ADR(ErrorSystem.aErrorData[nListCnt1]), ADR(ErrorSystem.aErrorData[nListCnt1+1]), (GVL_ErrorSystem.cSizeOfErrorData - 1 - nListCnt1) * SIZEOF(DUT_TerminalError));
		MEMSET(ADR(ErrorSystem.aErrorData[GVL_ErrorSystem.cSizeOfErrorData - 1]), 0, SIZEOF(DUT_TerminalError));
	END_IF
END_FOR
```


tc_mca_std_lib/POUs/ErrorHandling/FB_TerminalError.TcPOU (TcPlcObject)
----------------------------------------------------------------------

### FB_TerminalError: Declaration

```vhdl
FUNCTION_BLOCK FB_TerminalError

VAR_INPUT
	En					: BOOL;
	iTerminal_ID		: INT;
	bWcState			: BOOL;
	uiInfoData_State	: UINT;
	pErrorSystem		: POINTER TO ST_ErrorSystem;					//Pointer to the error system
END_VAR

VAR_OUTPUT
	EnO : BOOL;
	bError : BOOL := FALSE;
END_VAR

VAR
	iStateError : UINT;
	iOtherError : UINT;
	ErrorData	: DUT_TerminalError;
	nErrSysCNT	: UINT;
	
	//testing
	bStateChanged : BOOL;						//Indicate if state change happened
	uiInfoData_State_Prev : UINT := 16#8;		//Previous value of Infodata.State
	bWcState_Prev : BOOL := FALSE;				//Previous state of WcState
	
	//FB-s
	
END_VAR
```

### FB_TerminalError: ST

```vhdl
(*
Currently:

Problem:

TODO:

*)

//Connect EN to EnO
EnO:=En;

//Check if pointer is OK
IF pErrorSystem=0 THEN RETURN; END_IF

//Any difference from normal state creates an error
IF En AND (bWcState OR uiInfoData_State<>16#8) THEN
	bError:=TRUE;
ELSE
	bError:=FALSE;
END_IF

//Change detection
IF uiInfoData_State <> uiInfoData_State_Prev OR bWcState <> bWcState_Prev THEN
	bStateChanged := TRUE;
ELSE
	bStateChanged := FALSE;
END_IF

//Update previous values
uiInfoData_State_Prev := uiInfoData_State;
bWcState_Prev := bWcState;

//Decision tree
IF bStateChanged THEN
	IF bError THEN
		IF ErrorData.ErrorState = DUT_ErrorState.Active THEN
			//Close active error
			//Read system time
			ErrorData.nDateTimeOff := Tc2_EtherCAT.F_GetActualDcTime64();
			ErrorData.sDateTimeOff := Tc2_EtherCat.DCTIME64_TO_STRING(ErrorData.nDateTimeOff);
			ErrorData.ErrorState := DUT_ErrorState.Inactive;
			//Write Off-time to Error System
			FOR nErrSysCNT := 0 TO GVL_ErrorSystem.cSizeOfErrorData - 1 DO
				IF pErrorSystem^.aErrorData[nErrSysCNT].Error_ID = ErrorData.Error_ID THEN
					pErrorSystem^.aErrorData[nErrSysCNT].nDateTimeOff := ErrorData.nDateTimeOff;
					pErrorSystem^.aErrorData[nErrSysCNT].sDateTimeOff := ErrorData.sDateTimeOff;
					pErrorSystem^.aErrorData[nErrSysCNT].ErrorState := DUT_ErrorState.Inactive;
					EXIT;
				END_IF
			END_FOR
				
			//Clear ErrorData
			MEMSET(ADR(ErrorData), 0, SIZEOF(ErrorData));
		END_IF
		
		//Open a new error
		ErrorData.ErrorState := DUT_ErrorState.Active;												//Set Error State
		ErrorData.nDateTimeOn := Tc2_EtherCAT.F_GetActualDcTime64();								//Get system time
		ErrorData.sDateTimeOn := Tc2_EtherCat.DCTIME64_TO_STRING(ErrorData.nDateTimeOn);			//Convert to string
		ErrorData.iTerminalID := iTerminal_ID;														//Terminal_ID
		ErrorData.bWcState := bWcState;																//WcState bit
		ErrorData.uiInfoDataState := uiInfoData_State;												//uiInfoData_State
		
		//Error message according to uiInfoData_State and WcState
		iStateError := (uiInfoData_State AND 16#000F);												//Mask for operation state 
		iOtherError := (uiInfoData_State AND 16#00F0);												//Mask for the other 3 kind of errors
		//Error messages according to the least significant digit
		CASE iStateError OF
			16#0001 : ErrorData.sErrorMessage := 'Slave in INIT state;   ';
			16#0002 : ErrorData.sErrorMessage := 'Slave in PREOP state;   ';
			16#0003 : ErrorData.sErrorMessage := 'Slave in BOOT state;   ';
			16#0004 : ErrorData.sErrorMessage := 'Slave in SAFEOP state;   ';
			16#0008 : ;																			//Normal operation state
		ELSE
			ErrorData.sErrorMessage := 'Undefined State of operation;   ';						//I hope we will never see this message
			ErrorData.sErrorMessage := CONCAT (ErrorData.sErrorMessage, UINT_TO_STRING(iStateError));
			ErrorData.sErrorMessage := CONCAT (ErrorData.sErrorMessage, '   ');
		END_CASE
		
		//Error messages according to the second least significant digit
		CASE iOtherError OF
			16#0000 : ;																			//No error case
			16#0010 : ErrorData.sErrorMessage := CONCAT (ErrorData.sErrorMessage, 'Slave signals error;   ');
			16#0020 : ErrorData.sErrorMessage := CONCAT (ErrorData.sErrorMessage, 'Invalid vendorID/productCode read;   ');
			16#0040 : ErrorData.sErrorMessage := CONCAT (ErrorData.sErrorMessage, 'Initialisation error occured;   ');
		ELSE
			ErrorData.sErrorMessage := CONCAT (ErrorData.sErrorMessage, 'Undefined Error ID: ');
			ErrorData.sErrorMessage := CONCAT (ErrorData.sErrorMessage, UINT_TO_STRING(iOtherError));
			ErrorData.sErrorMessage := CONCAT (ErrorData.sErrorMessage, '   ');
		END_CASE
	
		//Errormessage according to WcState bit
		IF bWcState THEN
			ErrorData.sErrorMessage := CONCAT (ErrorData.sErrorMessage, 'Invalid Data;');
		END_IF
		
		//Check for overflow
		IF pErrorSystem^.nNoErrors = GVL_ErrorSystem.cSizeOfErrorData THEN
			pErrorSystem^.nNoOverflows := pErrorSystem^.nNoOverflows+1;
		END_IF
		
		//Write Error Data into Error System
		ErrorData.Error_ID := pErrorSystem^.lNextErrorID ;
		MEMMOVE( ADR(pErrorSystem^.aErrorData[1]), ADR(pErrorSystem^.aErrorData[0]), (GVL_ErrorSystem.cSizeOfErrorData-1) * SIZEOF(DUT_TerminalError));
		pErrorSystem^.aErrorData[0] := ErrorData;
		pErrorSystem^.lNextErrorID := pErrorSystem^.lNextErrorID+1;
		
	ELSE
		//Close Active Error
		//Read system time
		ErrorData.nDateTimeOff := Tc2_EtherCAT.F_GetActualDcTime64();
		ErrorData.sDateTimeOff := Tc2_EtherCat.DCTIME64_TO_STRING(ErrorData.nDateTimeOff);
		ErrorData.ErrorState := DUT_ErrorState.Inactive;
		
		//Write Off time to Error System
		FOR nErrSysCNT := 0 TO GVL_ErrorSystem.cSizeOfErrorData - 1 DO
			IF pErrorSystem^.aErrorData[nErrSysCNT].Error_ID = ErrorData.Error_ID THEN
				pErrorSystem^.aErrorData[nErrSysCNT].nDateTimeOff := ErrorData.nDateTimeOff;
				pErrorSystem^.aErrorData[nErrSysCNT].sDateTimeOff := ErrorData.sDateTimeOff;
				pErrorSystem^.aErrorData[nErrSysCNT].ErrorState := DUT_ErrorState.Inactive;
				EXIT;
			END_IF
		END_FOR
			
		//Clear ErrorData
		MEMSET(ADR(ErrorData), 0, SIZEOF(ErrorData));
	END_IF
END_IF
```


tc_mca_std_lib/POUs/ErrorHandling/GVL_ErrorSystem.TcGVL (TcPlcObject)
---------------------------------------------------------------------

### GVL_ErrorSystem: Declaration

```vhdl
{attribute 'qualified_only'}
VAR_GLOBAL CONSTANT
	cSizeOfErrorData : UINT := 128;
	
END_VAR
```


tc_mca_std_lib/POUs/ErrorHandling/ST_ErrorSystem.TcDUT (TcPlcObject)
--------------------------------------------------------------------

### ST_ErrorSystem: Declaration

```vhdl
TYPE ST_ErrorSystem :
STRUCT
	//Array of error data. Size = cSizeOfErrorData in the GVL
	aErrorData : ARRAY [0..GVL_ErrorSystem.cSizeOfErrorData - 1] OF DUT_TerminalError;
	lNextErrorID : ULINT := 1;					//ErrorID for the next error entry
	nNoErrors : UINT;							//Number of errors in the list
	nNoOverflows : INT := 0;					//Number of overflows. How many error entries have been lost
END_STRUCT
END_TYPE
```


tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/Analog_Inputs/EL3174_0002.TcPOU (TcPlcObject)
---------------------------------------------------------------------------------------------

### EL3174_0002: Declaration

```vhdl
//EL3174-0002 | 4-channel analog input, -10/0...+10V, -20/0/+4...20mA, 16 bit, differential
FUNCTION_BLOCK EL3174_0002

VAR_INPUT
	En: BOOL;
	iTerminal_ID : INT;
	ErrorSystem : POINTER TO ST_ErrorSystem;
END_VAR
	
VAR_OUTPUT
	EnO: BOOL;
	iAi_Ch1_Value : INT;
	iAi_Ch2_Value : INT;
	iAi_Ch3_Value : INT;
	iAi_Ch4_Value : INT;
	bError: BOOL;
END_VAR

VAR
	//Channels
	AI_Std_Ch_1_Status	AT %I* : WORD;
	AI_Std_Ch_1_Value 	AT %I* : INT;
	AI_Std_Ch_2_Status 	AT %I* : WORD;
	AI_Std_Ch_2_Value 	AT %I* : INT;
	AI_Std_Ch_3_Status 	AT %I* : WORD;
	AI_Std_Ch_3_Value 	AT %I* : INT;
	AI_Std_Ch_4_Status 	AT %I* : WORD;
	AI_Std_Ch_4_Value 	AT %I* : INT;
	
	//Terminal status
	WcState_WcState AT %I*: BOOL;
	InfoData_State AT %I*: UINT;
	
	//FB-s
	EL3174_0002_Error : FB_TerminalError;
END_VAR
```

### EL3174_0002: ST

```vhdl
(*
* TODO:
* Status words of the channels
*)

EnO := En;

//Error FB instance
EL3174_0002_Error(
	En := TRUE,
	iTerminal_ID := iTerminal_ID,
	bWcState := WcState_WcState,
	uiInfoData_State := InfoData_State,
	pErrorSystem := ErrorSystem,
	bError => bError,
);

IF En THEN
	IF bError = FALSE THEN
		iAi_Ch1_Value := AI_Std_Ch_1_Value;
		iAi_Ch2_Value := AI_Std_Ch_2_Value;
		iAi_Ch3_Value := AI_Std_Ch_3_Value;
		iAi_Ch4_Value := AI_Std_Ch_4_Value;
	ELSE
		iAi_Ch1_Value := 0;
		iAi_Ch2_Value := 0;
		iAi_Ch3_Value := 0;
		iAi_Ch4_Value := 0;
	END_IF
END_IF
```


tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/Analog_Inputs/EL3214.TcPOU (TcPlcObject)
----------------------------------------------------------------------------------------

### EL3214: Declaration

```vhdl
//EL3214 | 4-channel analog input terminal, PT100 (RTD)
FUNCTION_BLOCK EL3214

VAR_INPUT
	En: BOOL;
	iTerminal_ID : INT;
	ErrorSystem : POINTER TO ST_ErrorSystem;
END_VAR

VAR_OUTPUT
	EnO: BOOL;
	iAi_Ch1_Value : INT;
	iAi_Ch2_Value : INT;
	iAi_Ch3_Value : INT;
	iAi_Ch4_Value : INT;
	bError: BOOL;
END_VAR

VAR
	//Channels
	AI_RTD_Ch_1_Status	AT %I* : WORD;
	AI_RTD_Ch_1_Value 	AT %I* : INT;
	AI_RTD_Ch_2_Status 	AT %I* : WORD;
	AI_RTD_Ch_2_Value 	AT %I* : INT;
	AI_RTD_Ch_3_Status 	AT %I* : WORD;
	AI_RTD_Ch_3_Value 	AT %I* : INT;
	AI_RTD_Ch_4_Status 	AT %I* : WORD;
	AI_RTD_Ch_4_Value 	AT %I* : INT;
	
	//Terminal status
	WcState_WcState AT %I*: BOOL;
	InfoData_State AT %I*: UINT;
	
	//FB-s
	EL3214_Error : FB_TerminalError;
END_VAR
```

### EL3214: ST

```vhdl
(*
* TODO:
* Status words of the channels
*)

EnO := En;

//Error FB instance
EL3214_Error(
	En := TRUE,
	iTerminal_ID := iTerminal_ID,
	bWcState := WcState_WcState,
	uiInfoData_State := InfoData_State,
	pErrorSystem := ErrorSystem,
	bError => bError,
);

IF En THEN
	IF bError = FALSE THEN
		iAi_Ch1_Value := AI_RTD_Ch_1_Value;
		iAi_Ch2_Value := AI_RTD_Ch_2_Value;
		iAi_Ch3_Value := AI_RTD_Ch_3_Value;
		iAi_Ch4_Value := AI_RTD_Ch_4_Value;
	ELSE
		iAi_Ch1_Value := 0;
		iAi_Ch2_Value := 0;
		iAi_Ch3_Value := 0;
		iAi_Ch4_Value := 0;
	END_IF
END_IF
```


tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/Analog_Inputs/EL3255.TcPOU (TcPlcObject)
----------------------------------------------------------------------------------------

### EL3255: Declaration

```vhdl
//EL3255 | 5-channel potentiometer measurement with sensor supply
FUNCTION_BLOCK EL3255

VAR_INPUT
	En: BOOL;
	iTerminal_ID : INT;
	ErrorSystem : POINTER TO ST_ErrorSystem;
END_VAR

VAR_OUTPUT
	EnO : BOOL;	
	Ch1_Value : INT;
	Ch2_Value : INT;
	Ch3_Value : INT;
	Ch4_Value : INT;
	Ch5_Value : INT;
	bError : BOOL;
END_VAR

VAR
	AI_Std_Ch1_Value AT %I* : INT;
	AI_Std_Ch2_Value AT %I* : INT;
	AI_Std_Ch3_Value AT %I* : INT;
	AI_Std_Ch4_Value AT %I* : INT;
	AI_Std_Ch5_Value AT %I* : INT;
	WcState_WcState AT %I*: BOOL;
	InfoData_State AT %I*: UINT;
	
	//FB-s
	EL3255_Error : FB_TerminalError;
END_VAR
```

### EL3255: ST

```vhdl
(*
* TODO:
* Channel Status words
*)

EnO:=En;

//Error FB instance
EL3255_Error(
	En := TRUE,
	iTerminal_ID := iTerminal_ID,
	bWcState := WcState_WcState,
	uiInfoData_State := InfoData_State,
	pErrorSystem := ErrorSystem,
	bError => bError,
);

IF EN THEN
	IF NOT bError THEN
		Ch1_Value := AI_Std_Ch1_Value;
		Ch2_Value := AI_Std_Ch2_Value;
		Ch3_Value := AI_Std_Ch3_Value;
		Ch4_Value := AI_Std_Ch4_Value;
		Ch5_Value := AI_Std_Ch5_Value;
	ELSE
		Ch1_Value := 0;
		Ch2_Value := 0;
		Ch3_Value := 0;
		Ch4_Value := 0;
		Ch5_Value := 0;
	END_IF
END_IF
```


tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/Analog_Inputs/FB_CalculateFrequency_3702_v0_01.TcPOU (TcPlcObject)
------------------------------------------------------------------------------------------------------------------

### FB_CalculateFrequency_3702_v0_01: Declaration

```vhdl
FUNCTION_BLOCK FB_CalculateFrequency_3702_v0_01
VAR CONSTANT
	///200 samples/period
	cBufferSize: INT := 1000;
END_VAR
VAR_INPUT
	En: BOOL;
	bCalculate: BOOL;
	aBufferValue: ARRAY[0..(cBuffersize - 1)] OF INT;
	aBufferDcTime: ARRAY[0..(cBuffersize - 1)] OF UDINT;
	///If curve has a DC offset
	nDCOffset: INT := 0;
END_VAR
VAR_OUTPUT
	EnO: BOOL;
	bError: BOOL;
	fActFrequency: LREAL;
END_VAR
VAR
	nIndex: INT;
	nFirstZeroCrossing: INT;
	nLastZeroCrossing: INT;
	rTimeFirst: REAL := 0;
	rTimeLast: REAL := 0;
	rTimeRes: REAL := 0;
	nCrossings: INT := 0;
END_VAR
VAR_TEMP
	rRange: REAL := 0;
	rTimeSpan: REAL := 0;
END_VAR
```

### FB_CalculateFrequency_3702_v0_01: ST

```vhdl
EnO:=En;
bError:=FALSE;
nCrossings:=0;
IF En AND bCalculate THEN
	//Serach for crossings of nDCOffset
	FOR nIndex:=1 TO cBuffersize-1 DO
		IF((aBufferValue[nIndex]>nDCOffset AND aBufferValue[nIndex-1]<=nDCOffset) OR (aBufferValue[nIndex]<nDCOffset AND aBufferValue[nIndex-1]>=nDCOffset))	THEN
			IF(nCrossings=0) THEN
				nFirstZeroCrossing:=nIndex;
			END_IF
			nLastZeroCrossing:=nIndex;
			nCrossings:=nCrossings+1;
		END_IF
	END_FOR	
	
	IF nFirstZeroCrossing < nLastZeroCrossing  AND  nCrossings>2 THEN
		//interpolate zero crossings for higher accuracy
		rTimeRes:=UDINT_TO_REAL(aBufferDcTime[1]-aBufferDcTime[0]); //Buffer must contain more than 2 values
		rRange:=INT_TO_REAL(ABS(aBufferValue[nFirstZeroCrossing-1]-aBufferValue[nFirstZeroCrossing]));
		rTimeFirst:=UDINT_TO_REAL( aBufferDcTime[nFirstZeroCrossing-1])+ABS(INT_TO_REAL(aBufferValue[nFirstZeroCrossing-1])/rRange*rTimeRes);
		rRange:=INT_TO_REAL(ABS(aBufferValue[nLastZeroCrossing-1]-aBufferValue[nLastZeroCrossing]));
		rTimeLast:=UDINT_TO_REAL( aBufferDcTime[nLastZeroCrossing-1])+ABS(INT_TO_REAL(aBufferValue[nLastZeroCrossing-1])/rRange*rTimeRes);

		//Time span first to last (considering that max one time counter overflow have occured in the total time range of the time buffer)	
		IF rTimeFirst<rTimeLast THEN		
			rTimeSpan:=rTimeLast-rTimeFirst;
		ELSE //overflow of counter once (only 32bit timestamp =4.29seconds)
			rTimeSpan:=4294967296.0-rTimeFirst+rTimeLast;
		END_IF
		
		fActFrequency:=1000000000.0/rTimeSpan*(nCrossings-1)/2; //two crossings per period => Average frequency over buffer.
	ELSE
		fActFrequency:=0;
	END_IF
END_IF
```


tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/Digital_Inputs/EL1008.TcPOU (TcPlcObject)
-----------------------------------------------------------------------------------------

### EL1008: Declaration

```vhdl
///EL1008 | 8-channel digital input terminal 24 V DC, 3 ms
FUNCTION_BLOCK EL1008

VAR_INPUT
	En: BOOL;
	iTerminal_ID : INT;
	ErrorSystem : POINTER TO ST_ErrorSystem;
END_VAR

VAR_OUTPUT
	EnO: BOOL;
	bDi_1: BOOL;
	bDi_2: BOOL;
	bDi_3: BOOL;
	bDi_4: BOOL;
	bDi_5: BOOL;
	bDi_6: BOOL;
	bDi_7: BOOL;
	bDi_8: BOOL;
	bError: BOOL;
END_VAR

VAR
	Channel_1_Input AT %I*: BOOL;
	Channel_2_Input AT %I*: BOOL;
	Channel_3_Input AT %I*: BOOL;
	Channel_4_Input AT %I*: BOOL;
	Channel_5_Input AT %I*: BOOL;
	Channel_6_Input AT %I*: BOOL;
	Channel_7_Input AT %I*: BOOL;
	Channel_8_Input AT %I*: BOOL;
	WcState_WcState AT %I*: BOOL;
	InfoData_State AT %I*: UINT;
	
	//FB-s
	EL1008_Error : FB_TerminalError;
END_VAR
```

### EL1008: ST

```vhdl
EnO:=En;

//Error FB instance
EL1008_Error(
	En := TRUE,
	iTerminal_ID := iTerminal_ID,
	bWcState := WcState_WcState,
	uiInfoData_State := InfoData_State,
	pErrorSystem := ErrorSystem,
	bError => bError,
);

IF En THEN
	IF bError=FALSE THEN
		bDi_1:=Channel_1_Input;
		bDi_2:=Channel_2_Input;
		bDi_3:=Channel_3_Input;
		bDi_4:=Channel_4_Input;
		bDi_5:=Channel_5_Input;
		bDi_6:=Channel_6_Input;
		bDi_7:=Channel_7_Input;
		bDi_8:=Channel_8_Input;
	ELSE
		bDi_1:=FALSE;
		bDi_2:=FALSE;
		bDi_3:=FALSE;
		bDi_4:=FALSE;
		bDi_5:=FALSE;
		bDi_6:=FALSE;
		bDi_7:=FALSE;
		bDi_8:=FALSE;
	END_IF
END_IF
```


tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/Digital_Inputs/EL1018.TcPOU (TcPlcObject)
-----------------------------------------------------------------------------------------

### EL1018: Declaration

```vhdl
///EL1018 | 8-channel digital input terminal 24 V DC, 10 s
FUNCTION_BLOCK EL1018

VAR_INPUT
	En: BOOL;
	iTerminal_ID : INT;
	ErrorSystem : POINTER TO ST_ErrorSystem;
END_VAR

VAR_OUTPUT
	EnO: BOOL;
	bDi_1: BOOL;
	bDi_2: BOOL;
	bDi_3: BOOL;
	bDi_4: BOOL;
	bDi_5: BOOL;
	bDi_6: BOOL;
	bDi_7: BOOL;
	bDi_8: BOOL;
	bError : BOOL;
END_VAR

VAR
	Channel_1_Input AT %I*: BOOL;
	Channel_2_Input AT %I*: BOOL;
	Channel_3_Input AT %I*: BOOL;
	Channel_4_Input AT %I*: BOOL;
	Channel_5_Input AT %I*: BOOL;
	Channel_6_Input AT %I*: BOOL;
	Channel_7_Input AT %I*: BOOL;
	Channel_8_Input AT %I*: BOOL;
	WcState_WcState AT %I*: BOOL;
	InfoData_State  AT %I*: UINT;
	
	//FB-s
	EL1018_Error : FB_TerminalError;
END_VAR
```

### EL1018: ST

```vhdl
EnO:=En;

//Error FB instance
EL1018_Error(
	En := TRUE,
	iTerminal_ID := iTerminal_ID,
	bWcState := WcState_WcState,
	uiInfoData_State := InfoData_State,
	pErrorSystem := ErrorSystem,
	bError => bError,
);

IF En THEN
	IF bError=FALSE THEN
		bDi_1:=Channel_1_Input;
		bDi_2:=Channel_2_Input;
		bDi_3:=Channel_3_Input;
		bDi_4:=Channel_4_Input;
		bDi_5:=Channel_5_Input;
		bDi_6:=Channel_6_Input;
		bDi_7:=Channel_7_Input;
		bDi_8:=Channel_8_Input;
	ELSE
		bDi_1:=FALSE;
		bDi_2:=FALSE;
		bDi_3:=FALSE;
		bDi_4:=FALSE;
		bDi_5:=FALSE;
		bDi_6:=FALSE;
		bDi_7:=FALSE;
		bDi_8:=FALSE;
	END_IF
END_IF
```


tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/Digital_Inputs/EL1808.TcPOU (TcPlcObject)
-----------------------------------------------------------------------------------------

### EL1808: Declaration

```vhdl
///EL1808 | HD EtherCAT Terminals, 8-channel digital input 24 V DC, 3 ms, 2-wire connection
FUNCTION_BLOCK EL1808

VAR_INPUT
	En: BOOL;
	iTerminal_ID : INT;
	ErrorSystem : POINTER TO ST_ErrorSystem;
END_VAR

VAR_OUTPUT
	EnO: BOOL;
	bDi_1: BOOL;
	bDi_2: BOOL;
	bDi_3: BOOL;
	bDi_4: BOOL;
	bDi_5: BOOL;
	bDi_6: BOOL;
	bDi_7: BOOL;
	bDi_8: BOOL;
	bError: BOOL;
END_VAR

VAR
	Channel_1_Input AT %I*: BOOL;
	Channel_2_Input AT %I*: BOOL;
	Channel_3_Input AT %I*: BOOL;
	Channel_4_Input AT %I*: BOOL;
	Channel_5_Input AT %I*: BOOL;
	Channel_6_Input AT %I*: BOOL;
	Channel_7_Input AT %I*: BOOL;
	Channel_8_Input AT %I*: BOOL;
	WcState_WcState AT %I*: BOOL;
	InfoData_State AT %I*: UINT;
	
	//FB-s
	EL1808_Error : FB_TerminalError;
END_VAR
```

### EL1808: ST

```vhdl
EnO:=En;

//Error FB instance
EL1808_Error(
	En := TRUE,
	iTerminal_ID := iTerminal_ID,
	bWcState := WcState_WcState,
	uiInfoData_State := InfoData_State,
	pErrorSystem := ErrorSystem,
	bError => bError,
);

IF En THEN
	IF bError=FALSE THEN
		bDi_1:=Channel_1_Input;
		bDi_2:=Channel_2_Input;
		bDi_3:=Channel_3_Input;
		bDi_4:=Channel_4_Input;
		bDi_5:=Channel_5_Input;
		bDi_6:=Channel_6_Input;
		bDi_7:=Channel_7_Input;
		bDi_8:=Channel_8_Input;
	ELSE
		bDi_1:=FALSE;
		bDi_2:=FALSE;
		bDi_3:=FALSE;
		bDi_4:=FALSE;
		bDi_5:=FALSE;
		bDi_6:=FALSE;
		bDi_7:=FALSE;
		bDi_8:=FALSE;
	END_IF
END_IF
```


tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/Digital_Inputs/EL1809.TcPOU (TcPlcObject)
-----------------------------------------------------------------------------------------

### EL1809: Declaration

```vhdl
///EL1809 | HD EtherCAT Terminals, 16-channel digital input 24 V DC, 3 ms
FUNCTION_BLOCK EL1809

VAR_INPUT
	En: BOOL;
	iTerminal_ID : INT;
	ErrorSystem : POINTER TO ST_ErrorSystem;
END_VAR

VAR_OUTPUT
	EnO: BOOL;
	bDi_1: BOOL;
	bDi_2: BOOL;
	bDi_3: BOOL;
	bDi_4: BOOL;
	bDi_5: BOOL;
	bDi_6: BOOL;
	bDi_7: BOOL;
	bDi_8: BOOL;
	bDi_9: BOOL;
	bDi_10: BOOL;
	bDi_11: BOOL;
	bDi_12: BOOL;
	bDi_13: BOOL;
	bDi_14: BOOL;
	bDi_15: BOOL;
	bDi_16: BOOL;
	bError: BOOL;
END_VAR

VAR
	Channel_1_Input AT %I*: BOOL;
	Channel_2_Input AT %I*: BOOL;
	Channel_3_Input AT %I*: BOOL;
	Channel_4_Input AT %I*: BOOL;
	Channel_5_Input AT %I*: BOOL;
	Channel_6_Input AT %I*: BOOL;
	Channel_7_Input AT %I*: BOOL;
	Channel_8_Input AT %I*: BOOL;
	Channel_9_Input AT %I*: BOOL;
	Channel_10_Input AT %I*: BOOL;
	Channel_11_Input AT %I*: BOOL;
	Channel_12_Input AT %I*: BOOL;
	Channel_13_Input AT %I*: BOOL;
	Channel_14_Input AT %I*: BOOL;
	Channel_15_Input AT %I*: BOOL;
	Channel_16_Input AT %I*: BOOL;
	WcState_WcState AT %I*: BOOL;
	InfoData_State AT %I*: UINT;
	
	//FB-s
	EL1809_Error : FB_TerminalError;
END_VAR
```

### EL1809: ST

```vhdl
EnO:=En;

//Error FB instance
EL1809_Error(
	En := TRUE,
	iTerminal_ID := iTerminal_ID,
	bWcState := WcState_WcState,
	uiInfoData_State := InfoData_State,
	pErrorSystem := ErrorSystem,
	bError => bError,
);

IF En THEN
	IF bError=FALSE THEN
		bDi_1:=Channel_1_Input;
		bDi_2:=Channel_2_Input;
		bDi_3:=Channel_3_Input;
		bDi_4:=Channel_4_Input;
		bDi_5:=Channel_5_Input;
		bDi_6:=Channel_6_Input;
		bDi_7:=Channel_7_Input;
		bDi_8:=Channel_8_Input;
		bDi_9:=Channel_9_Input;
		bDi_10:=Channel_10_Input;
		bDi_11:=Channel_11_Input;
		bDi_12:=Channel_12_Input;
		bDi_13:=Channel_13_Input;
		bDi_14:=Channel_14_Input;
		bDi_15:=Channel_15_Input;
		bDi_16:=Channel_16_Input;
	ELSE
		bDi_1:=FALSE;
		bDi_2:=FALSE;
		bDi_3:=FALSE;
		bDi_4:=FALSE;
		bDi_5:=FALSE;
		bDi_6:=FALSE;
		bDi_7:=FALSE;
		bDi_8:=FALSE;
		bDi_9:=FALSE;
		bDi_10:=FALSE;
		bDi_11:=FALSE;
		bDi_12:=FALSE;
		bDi_13:=FALSE;
		bDi_14:=FALSE;
		bDi_15:=FALSE;
		bDi_16:=FALSE;
	END_IF
END_IF
```


tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/Digital_Inputs/EL1819.TcPOU (TcPlcObject)
-----------------------------------------------------------------------------------------

### EL1819: Declaration

```vhdl
///EL1819 | HD EtherCAT Terminals, 16-channel digital input 24 V DC, 10 s
FUNCTION_BLOCK EL1819

VAR_INPUT
	En: BOOL;
	iTerminal_ID : INT;
	ErrorSystem : POINTER TO ST_ErrorSystem;
END_VAR

VAR_OUTPUT
	EnO: BOOL;
	bDi_1: BOOL;
	bDi_2: BOOL;
	bDi_3: BOOL;
	bDi_4: BOOL;
	bDi_5: BOOL;
	bDi_6: BOOL;
	bDi_7: BOOL;
	bDi_8: BOOL;
	bDi_9: BOOL;
	bDi_10: BOOL;
	bDi_11: BOOL;
	bDi_12: BOOL;
	bDi_13: BOOL;
	bDi_14: BOOL;
	bDi_15: BOOL;
	bDi_16: BOOL;
	bError: BOOL;
END_VAR

VAR
	Channel_1_Input AT %I*: BOOL;
	Channel_2_Input AT %I*: BOOL;
	Channel_3_Input AT %I*: BOOL;
	Channel_4_Input AT %I*: BOOL;
	Channel_5_Input AT %I*: BOOL;
	Channel_6_Input AT %I*: BOOL;
	Channel_7_Input AT %I*: BOOL;
	Channel_8_Input AT %I*: BOOL;
	Channel_9_Input AT %I*: BOOL;
	Channel_10_Input AT %I*: BOOL;
	Channel_11_Input AT %I*: BOOL;
	Channel_12_Input AT %I*: BOOL;
	Channel_13_Input AT %I*: BOOL;
	Channel_14_Input AT %I*: BOOL;
	Channel_15_Input AT %I*: BOOL;
	Channel_16_Input AT %I*: BOOL;
	WcState_WcState AT %I*: BOOL;
	InfoData_State AT %I*: UINT;
	
	//FB-s
	EL1819_Error : FB_TerminalError;
END_VAR
```

### EL1819: ST

```vhdl
EnO:=En;

//Error FB instance
EL1819_Error(
	En := TRUE,
	iTerminal_ID := iTerminal_ID,
	bWcState := WcState_WcState,
	uiInfoData_State := InfoData_State,
	pErrorSystem := ErrorSystem,
	bError => bError,
);

IF En THEN
	IF bError=FALSE THEN
		bDi_1:=Channel_1_Input;
		bDi_2:=Channel_2_Input;
		bDi_3:=Channel_3_Input;
		bDi_4:=Channel_4_Input;
		bDi_5:=Channel_5_Input;
		bDi_6:=Channel_6_Input;
		bDi_7:=Channel_7_Input;
		bDi_8:=Channel_8_Input;
		bDi_9:=Channel_9_Input;
		bDi_10:=Channel_10_Input;
		bDi_11:=Channel_11_Input;
		bDi_12:=Channel_12_Input;
		bDi_13:=Channel_13_Input;
		bDi_14:=Channel_14_Input;
		bDi_15:=Channel_15_Input;
		bDi_16:=Channel_16_Input;
	ELSE
		bDi_1:=FALSE;
		bDi_2:=FALSE;
		bDi_3:=FALSE;
		bDi_4:=FALSE;
		bDi_5:=FALSE;
		bDi_6:=FALSE;
		bDi_7:=FALSE;
		bDi_8:=FALSE;
		bDi_9:=FALSE;
		bDi_10:=FALSE;
		bDi_11:=FALSE;
		bDi_12:=FALSE;
		bDi_13:=FALSE;
		bDi_14:=FALSE;
		bDi_15:=FALSE;
		bDi_16:=FALSE;
	END_IF
END_IF
```


tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/Digital_Inputs/FB_EL1252ASM_v1_00.TcPOU (TcPlcObject)
-----------------------------------------------------------------------------------------------------

### FB_EL1252ASM_v1_00: Declaration

```vhdl
FUNCTION_BLOCK FB_EL1252ASM_v1_00
VAR_INPUT
	En: BOOL;
END_VAR
VAR_OUTPUT
	EnO: BOOL;
	Di_1: BOOL;
	Di_2: BOOL;
	Di_1_LatchTimePos: ULINT;
	Di_2_LatchTimePos: ULINT;
	Di_1_LatchTimeNeg: ULINT;
	Di_2_LatchTimeNeg: ULINT;
	///Below bits can be used but then they must be enabled in the COE of the card. Nicklas suggested to not use these (since something wss written that you then only were allowed to read the latch time onece (some kkind of auto reset??))	
	///Di_1_LatchNeg:BOOL;
	///	Di_1_LatchPos:BOOL;
	///	Di_2_LatchNeg:BOOL;
	///	Di_2_LatchPos:BOOL;
	Error: BOOL;
END_VAR
VAR
	Channel_1_Input AT %I*: BOOL;
	Channel_2_Input AT %I*: BOOL;
	///Latch_Status1 AT %I*: USINT;
	///	Latch_Status2 AT %I*: USINT;
	Latch_LatchPos1 AT %I*: ULINT;
	Latch_LatchNeg1 AT %I*: ULINT;
	Latch_LatchPos2 AT %I*: ULINT;
	Latch_LatchNeg2 AT %I*: ULINT;
	WcState_WcState AT %I*: BOOL;
	InfoData_State AT %I*: UINT;
END_VAR
```

### FB_EL1252ASM_v1_00: ST

```vhdl
EnO:=En;

IF En AND (WcState_WcState OR InfoData_State<>16#8) THEN //InfoData_State==0 => in OP mode
	Error:=TRUE;
ELSE
	Error:=FALSE;
END_IF

IF En THEN
	IF Error=FALSE THEN
		Di_1:=Channel_1_Input;
		Di_2:=Channel_2_Input;
	(*	Di_1_LatchPos:=Latch_Status1.0;
		Di_1_LatchNeg:=Latch_Status1.1;
		Di_2_LatchPos:=Latch_Status2.0;
		Di_2_LatchNeg:=Latch_Status2.1;*)
		Di_1_LatchTimePos:=Latch_LatchPos1;
		Di_2_LatchTimePos:=Latch_LatchPos2;		
		Di_1_LatchTimeNeg:=Latch_LatchNeg1;		
		Di_2_LatchTimeNeg:=Latch_LatchNeg2;
		
	ELSE
		Di_1:=FALSE;
		Di_2:=FALSE;
	END_IF
END_IF
```


tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/Digital_Outputs/EL2014.TcPOU (TcPlcObject)
------------------------------------------------------------------------------------------

### EL2014: Declaration

```vhdl
FUNCTION_BLOCK EL2014
VAR_INPUT
	En: BOOL;
	iTerminal_ID : INT; 
	bDo_1: BOOL;
	bDo_2: BOOL;
	bDo_3: BOOL;
	bDo_4: BOOL;
	ErrorSystem : POINTER TO ST_ErrorSystem;
END_VAR

VAR_OUTPUT
	EnO : BOOL;
	bError : BOOL;
END_VAR

VAR
	Channel_1_Output AT %Q*: BOOL;
	Channel_2_Output AT %Q*: BOOL;
	Channel_3_Output AT %Q*: BOOL;
	Channel_4_Output AT %Q*: BOOL;
	WcState_WcState AT %I*: BOOL;
	InfoData_State AT %I*: UINT;
	
	//FB-s
	EL2014_Error : FB_TerminalError;
END_VAR
```

### EL2014: ST

```vhdl
(*
* TODO:
* Channel diagnostic variables and device diag variables
*)

EnO:=En;

EL2014_Error(
	En := TRUE,
	iTerminal_ID := iTerminal_ID,
	bWcState := WcState_WcState,
	uiInfoData_State := InfoData_State,
	pErrorSystem := ErrorSystem,
	bError => bError,
);

IF En THEN
	IF bError=FALSE THEN
		Channel_1_Output:=bDo_1;
		Channel_2_Output:=bDo_2;
		Channel_3_Output:=bDo_3;
		Channel_4_Output:=bDo_4;
	ELSE
		Channel_1_Output:=FALSE;
		Channel_2_Output:=FALSE;
		Channel_3_Output:=FALSE;
		Channel_4_Output:=FALSE;
	END_IF
END_IF
```


tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/Digital_Outputs/EL2252.TcPOU (TcPlcObject)
------------------------------------------------------------------------------------------

### EL2252: Declaration

```vhdl
///EL2252 | XFC, 2-channel digital output terminal with time stamp, tri-state
FUNCTION_BLOCK EL2252
VAR_INPUT
	En: BOOL;
	iTerminal_ID : INT; 
	bDo_1: BOOL;
	bDo_2: BOOL;
ErrorSystem : POINTER TO ST_ErrorSystem;
END_VAR

VAR_OUTPUT
	EnO : BOOL;
	bError : BOOL;
END_VAR

VAR
	Channel_1_Output AT %Q*: BOOL;
	Channel_2_Output AT %Q*: BOOL;
	WcState_WcState AT %I*: BOOL;
	InfoData_State AT %I*: UINT;
	
	//FB-s
	EL2252_Error : FB_TerminalError;
END_VAR
```

### EL2252: ST

```vhdl
(*
* TODO:
* Add the DC sync variables
*)

EL2252_Error(
	En := TRUE,
	iTerminal_ID := iTerminal_ID,
	bWcState := WcState_WcState,
	uiInfoData_State := InfoData_State,
	pErrorSystem := ErrorSystem,
	bError => bError,
);

IF En THEN
	IF bError=FALSE THEN
		Channel_1_Output:=bDo_1;
		Channel_2_Output:=bDo_2;
	ELSE
		Channel_1_Output:=FALSE;
		Channel_2_Output:=FALSE;
	END_IF
END_IF
```


tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/Digital_Outputs/EL2808.TcPOU (TcPlcObject)
------------------------------------------------------------------------------------------

### EL2808: Declaration

```vhdl
FUNCTION_BLOCK EL2808

VAR_INPUT
	En: BOOL;
	iTerminal_ID : INT; 
	bDo_1: BOOL;
	bDo_2: BOOL;
	bDo_3: BOOL;
	bDo_4: BOOL;
	bDo_5: BOOL;
	bDo_6: BOOL;
	bDo_7: BOOL;
	bDo_8: BOOL;
	ErrorSystem : POINTER TO ST_ErrorSystem;
END_VAR

VAR_OUTPUT
	EnO : BOOL;
	bError : BOOL;
END_VAR

VAR
	Channel_1_Output AT %Q*: BOOL;
	Channel_2_Output AT %Q*: BOOL;
	Channel_3_Output AT %Q*: BOOL;
	Channel_4_Output AT %Q*: BOOL;
	Channel_5_Output AT %Q*: BOOL;
	Channel_6_Output AT %Q*: BOOL;
	Channel_7_Output AT %Q*: BOOL;
	Channel_8_Output AT %Q*: BOOL;
	WcState_WcState AT %I*: BOOL;
	InfoData_State AT %I*: UINT;
	
	//FB-s
	EL2808_Error : FB_TerminalError;
END_VAR
```

### EL2808: ST

```vhdl
EnO:=En;

EL2808_Error(
	En := TRUE,
	iTerminal_ID := iTerminal_ID,
	bWcState := WcState_WcState,
	uiInfoData_State := InfoData_State,
	pErrorSystem := ErrorSystem,
	bError => bError,
);

IF En THEN
	IF bError=FALSE THEN
		Channel_1_Output:=bDo_1;
		Channel_2_Output:=bDo_2;
		Channel_3_Output:=bDo_3;
		Channel_4_Output:=bDo_4;
		Channel_5_Output:=bDo_5;
		Channel_6_Output:=bDo_6;
		Channel_7_Output:=bDo_7;
		Channel_8_Output:=bDo_8;
	ELSE
		Channel_1_Output:=FALSE;
		Channel_2_Output:=FALSE;
		Channel_3_Output:=FALSE;
		Channel_4_Output:=FALSE;
		Channel_5_Output:=FALSE;
		Channel_6_Output:=FALSE;
		Channel_7_Output:=FALSE;
		Channel_8_Output:=FALSE;
	END_IF
END_IF
```


tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/Digital_Outputs/EL2819.TcPOU (TcPlcObject)
------------------------------------------------------------------------------------------

### EL2819: Declaration

```vhdl
FUNCTION_BLOCK EL2819
VAR_INPUT
	En: BOOL;
	iTerminal_ID : INT; 
	bDo_1: BOOL;
	bDo_2: BOOL;
	bDo_3: BOOL;
	bDo_4: BOOL;
	bDo_5: BOOL;
	bDo_6: BOOL;
	bDo_7: BOOL;
	bDo_8: BOOL;
	bDo_9: BOOL;
	bDo_10: BOOL;
	bDo_11: BOOL;
	bDo_12: BOOL;
	bDo_13: BOOL;
	bDo_14: BOOL;
	bDo_15: BOOL;
	bDo_16: BOOL;
	ErrorSystem : POINTER TO ST_ErrorSystem;
END_VAR

VAR_OUTPUT
	EnO : BOOL;
	bError : BOOL;
END_VAR

VAR
	Channel_1_Output AT %Q*: BOOL;
	Channel_2_Output AT %Q*: BOOL;
	Channel_3_Output AT %Q*: BOOL;
	Channel_4_Output AT %Q*: BOOL;
	Channel_5_Output AT %Q*: BOOL;
	Channel_6_Output AT %Q*: BOOL;
	Channel_7_Output AT %Q*: BOOL;
	Channel_8_Output AT %Q*: BOOL;
	Channel_9_Output AT %Q*: BOOL;
	Channel_10_Output AT %Q*: BOOL;
	Channel_11_Output AT %Q*: BOOL;
	Channel_12_Output AT %Q*: BOOL;
	Channel_13_Output AT %Q*: BOOL;
	Channel_14_Output AT %Q*: BOOL;
	Channel_15_Output AT %Q*: BOOL;
	Channel_16_Output AT %Q*: BOOL;
	
	WcState_WcState AT %I*: BOOL;
	InfoData_State AT %I*: UINT;
	
	//FB-s
	EL2819_Error : FB_TerminalError;
END_VAR
```

### EL2819: ST

```vhdl
(*
* TODO:
* Channel diagnostic variables and device diag variables
*)

EnO:=En;

EL2819_Error(
	En := TRUE,
	iTerminal_ID := iTerminal_ID,
	bWcState := WcState_WcState,
	uiInfoData_State := InfoData_State,
	pErrorSystem := ErrorSystem,
	bError => bError,
);

IF En THEN
	IF bError=FALSE THEN
		Channel_1_Output:=bDo_1;
		Channel_2_Output:=bDo_2;
		Channel_3_Output:=bDo_3;
		Channel_4_Output:=bDo_4;
		Channel_5_Output:=bDo_5;
		Channel_6_Output:=bDo_6;
		Channel_7_Output:=bDo_7;
		Channel_8_Output:=bDo_8;
		Channel_9_Output:=bDo_9;
		Channel_10_Output:=bDo_10;
		Channel_11_Output:=bDo_11;
		Channel_12_Output:=bDo_12;
		Channel_13_Output:=bDo_13;
		Channel_14_Output:=bDo_14;
		Channel_15_Output:=bDo_15;
		Channel_16_Output:=bDo_16;
	ELSE
		Channel_1_Output:=FALSE;
		Channel_2_Output:=FALSE;
		Channel_3_Output:=FALSE;
		Channel_4_Output:=FALSE;
		Channel_5_Output:=FALSE;
		Channel_6_Output:=FALSE;
		Channel_7_Output:=FALSE;
		Channel_8_Output:=FALSE;
		Channel_9_Output:=FALSE;
		Channel_10_Output:=FALSE;
		Channel_11_Output:=FALSE;
		Channel_12_Output:=FALSE;
		Channel_13_Output:=FALSE;
		Channel_14_Output:=FALSE;
		Channel_15_Output:=FALSE;
		Channel_16_Output:=FALSE;
	END_IF
END_IF
```


tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/Digital_Outputs/External_Types/dutEL2521_Ctrl.TcDUT (TcPlcObject)
-----------------------------------------------------------------------------------------------------------------

### dutEL2521_Ctrl: Declaration

```vhdl
TYPE dutEL2521_Ctrl :
STRUCT
	///The control word (CW) is located in the output process image, and is transmitted from the controller to the terminal.
	///CW.0 FREQ_SEL 0bin / 1bin  Rapid change of the base frequency (only if the ramp function is inactive):
	///0bin = Base frequency 1 (object 8001:02)
	///1bin = Base frequency 2 (object 8001:03) 
	FREQ_SEL: BOOL;
	///CW.1 RAMP_DIS 1bin Operation of the ramp function is cancelled, in spite of object 8000:06 being active; if travel distance control is active, it is interrupted by this bit 
	RAMP_DIS: BOOL;
	///CW.2 GO_COUNTER 1bin  If travel distance control is active (object 8000:0A), then a pre-set counter value is approached when the bit is set 
	GO_COUNTER: BOOL;
	///CW.5 CNT_CLR 1bin The contents of the counter is cleared or set (object 8000:0B) by this bit. 
	///Any overflow or underflow bits that might be set are also cleared by this bit. 
	///The process can be edge triggered or level triggered (object 8000:05). 
	CNT_CLR: BOOL;
END_STRUCT
END_TYPE
```


tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/Digital_Outputs/External_Types/dutEL2521_Status.TcDUT (TcPlcObject)
-------------------------------------------------------------------------------------------------------------------

### dutEL2521_Status: Declaration

```vhdl
TYPE dutEL2521_Status :
STRUCT
	///The status word (SW) is located in the input process image, and is transmitted from the terminal to the controller.
	///SW.0 SEL_ACK/END_COUNTER 1bin  Confirms the change of base frequency. At activated travel distance control: target counter value reached 
	SEL_ACK: BOOL;
	///SW.1 RAMP_ACTIVE 1bin Ramp is currently being followed 
	RAMP_ACTIVE: BOOL;
	///SW.2 UNDERFLOW 1bin This bit is set if the 16-bit counter underflows (0 -> 65535). It is reset when the counter drops below two thirds of its measuring range (43690 -> 43689) or immediately an overflow occurs. 
	UNDERFLOW: BOOL;
	///SW.3 OVERFLOW 1bin This bit is set if the 16-bit counter overflows (65535 -> 0). It is reset when the counter exceeds one third of its measuring range (21845 -> 21846) or immediately an underflow occurs 
	OVERFLOW: BOOL;
	///SW.4 INPUT_T 1bin Status of INPUT_T 
	INPUT_T: BOOL;
	///SW.5 INPUT_Z 1bin Status of INPUT_Z 
	INPUT_Z: BOOL;
	///SW.6 ERROR 1bin General error bit, included with overflow/underflow 
	ERROR: BOOL;
END_STRUCT
END_TYPE
```


tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/Measuring_Terminals/EL5002.TcPOU (TcPlcObject)
----------------------------------------------------------------------------------------------

### EL5002: Declaration

```vhdl
//EL5002 | 2-chennel SSI absolute encoder terminal
FUNCTION_BLOCK EL5002

VAR_INPUT
	En: BOOL;
	iTerminal_ID : INT;
	ErrorSystem : POINTER TO ST_ErrorSystem;
END_VAR

VAR_OUTPUT
	EnO: BOOL;
	Ch1_Counter_Value : UDINT;
	Ch2_Counter_Value : UDINT;
	bError: BOOL;
END_VAR

VAR
	udi_Ch1_Cnt_Value AT %I* : UDINT;
	udi_Ch2_Cnt_Value AT %I* : UDINT;
	WcState_WcState AT %I*: BOOL;
	InfoData_State AT %I*: UINT;
	
	//FB-s
	EL5002_Error : FB_TerminalError;
END_VAR
```

### EL5002: ST

```vhdl
(*
* TODO:
* Channel Status words
*)

EnO:=En;

//Error FB instance
EL5002_Error(
	En := TRUE,
	iTerminal_ID := iTerminal_ID,
	bWcState := WcState_WcState,
	uiInfoData_State := InfoData_State,
	pErrorSystem := ErrorSystem,
	bError => bError,
);

IF EN THEN
	IF NOT bError THEN
		Ch1_Counter_Value := udi_Ch1_Cnt_Value;
		Ch2_Counter_Value := udi_Ch2_Cnt_Value;
	ELSE
		Ch1_Counter_Value := 0;
		Ch2_Counter_Value := 0;
	END_IF
END_IF
```


tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/Measuring_Terminals/EL5021.TcPOU (TcPlcObject)
----------------------------------------------------------------------------------------------

### EL5021: Declaration

```vhdl
//EL5021 | 1-channel Sin/Cos encoder
FUNCTION_BLOCK EL5021

VAR_INPUT
	En: BOOL;
	iTerminal_ID : INT;
	ErrorSystem : POINTER TO ST_ErrorSystem;
END_VAR

VAR_OUTPUT
	EnO: BOOL;
	Counter_Value : UDINT;
	Latch_Value : UDINT;
	bError: BOOL;
END_VAR

VAR
	udiCounter_Value AT %I* : UDINT;
	udiLatch_Value AT %I* : UDINT;
	WcState_WcState AT %I*: BOOL;
	InfoData_State AT %I*: UINT;
	
	//FB-s
	EL5021_Error : FB_TerminalError;
END_VAR
```

### EL5021: ST

```vhdl
(*
* TODO:
* Channel Status words, control words
*)

EnO:=En;

//Error FB instance
EL5021_Error(
	En := TRUE,
	iTerminal_ID := iTerminal_ID,
	bWcState := WcState_WcState,
	uiInfoData_State := InfoData_State,
	pErrorSystem := ErrorSystem,
	bError => bError,
);

IF EN THEN
	IF NOT bError THEN
		Counter_Value := udiCounter_Value;
		Latch_Value := udiLatch_Value;
	ELSE
		Counter_Value := 0;
		Latch_Value := 0;
	END_IF
END_IF
```


tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/Measuring_Terminals/EL5042.TcPOU (TcPlcObject)
----------------------------------------------------------------------------------------------

### EL5042: Declaration

```vhdl
//EL5042 | 2-channel BiSS-C absolute encoder terminal
FUNCTION_BLOCK EL5042

VAR_INPUT
	En: BOOL;
	iTerminal_ID : INT;
	ErrorSystem : POINTER TO ST_ErrorSystem;
END_VAR

VAR_OUTPUT
	EnO: BOOL;
	Ch1_Position : ULINT;
	Ch2_Position : ULINT;
	bError: BOOL;
END_VAR

VAR
	FB_Inputs_ch1_Position AT %I* : ULINT;
	FB_Inputs_ch2_Position AT %I* : ULINT;
	WcState_WcState AT %I*: BOOL;
	InfoData_State AT %I*: UINT;
	
	//FB-s
	EL5042_Error : FB_TerminalError;
END_VAR
```

### EL5042: ST

```vhdl
(*
* TODO:
* Channel Status words
*)

EnO:=En;

//Error FB instance
EL5042_Error(
	En := TRUE,
	iTerminal_ID := iTerminal_ID,
	bWcState := WcState_WcState,
	uiInfoData_State := InfoData_State,
	pErrorSystem := ErrorSystem,
	bError => bError,
);

IF EN THEN
	IF NOT bError THEN
		Ch1_Position := FB_Inputs_ch1_Position;
		Ch2_Position := FB_Inputs_ch2_Position;
	ELSE
		Ch1_Position := 0;
		Ch2_Position := 0;
	END_IF
END_IF
```


tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/Measuring_Terminals/EL5101.TcPOU (TcPlcObject)
----------------------------------------------------------------------------------------------

### EL5101: Declaration

```vhdl
// EL5101 | 1-channel incremental encoder terminal, 5V, RS422
FUNCTION_BLOCK EL5101

VAR_INPUT
	En: BOOL;
	iTerminal_ID : INT;
	ErrorSystem : POINTER TO ST_ErrorSystem;
END_VAR

VAR_OUTPUT
	EnO: BOOL;
	Counter_Value : UINT;
	Latch_Value : UINT;
	bError: BOOL;
END_VAR

VAR
	uiCounter_Value AT %I* : UINT;
	uiLatch_Value AT %I* : UINT;
	WcState_WcState AT %I*: BOOL;
	InfoData_State AT %I*: UINT;
	
	//FB-s
	EL5101_Error : FB_TerminalError;
END_VAR
```

### EL5101: ST

```vhdl
(*
* TODO:
* Channel Status word, control words
*)

EnO:=En;

//Error FB instance
EL5101_Error(
	En := TRUE,
	iTerminal_ID := iTerminal_ID,
	bWcState := WcState_WcState,
	uiInfoData_State := InfoData_State,
	pErrorSystem := ErrorSystem,
	bError => bError,
);

IF EN THEN
	IF NOT bError THEN
		Counter_Value := uiCounter_Value;
		Latch_Value := uiLatch_Value;
	ELSE
		Counter_Value := 0;
		Latch_Value := 0;
	END_IF
END_IF
```


tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/Motion/EL7211_v1_00.TcPOU (TcPlcObject)
---------------------------------------------------------------------------------------

### EL7211_v1_00: Declaration

```vhdl
///EL7211 | Servo motor termional 5 A
FUNCTION_BLOCK EL7211_v1_00
VAR_INPUT
	En: BOOL;
END_VAR
VAR_OUTPUT
	EnO: BOOL;

	bError: BOOL;
END_VAR
VAR
	WcState_WcState AT %I*: BOOL;
	InfoData_State AT %I*: UINT;
END_VAR
```

### EL7211_v1_00: ST

```vhdl
EnO:=En;

IF En AND (WcState_WcState OR InfoData_State<>16#8) THEN
	bError:=TRUE;
ELSE
	bError:=FALSE;
END_IF
```


tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/Motion/EL9576_v1_00.TcPOU (TcPlcObject)
---------------------------------------------------------------------------------------

### EL9576_v1_00: Declaration

```vhdl
///EL9576 | Brake terminal (vap and resistor)
FUNCTION_BLOCK EL9576_v1_00
VAR_INPUT
	En: BOOL;
END_VAR
VAR_OUTPUT
	EnO: BOOL;
	bError: BOOL;	
	OverTemperature: BOOL;
	I2TError : BOOL;
	I2TWarning : BOOL;
	OverVoltage  : BOOL;
	UnderVoltage : BOOL;
	ChopperOn : BOOL;
	DCLinkVoltage : LREAL;
	DutyCycle  : LREAL;
	ResistorCurrent : LREAL;
	
END_VAR
VAR
	BCTOverTemperature AT %I*: BOOL;
	BCTI2TError AT %I*: BOOL;
	BCTI2TWarning AT %I*: BOOL;
	BCTOverVoltage  AT %I*: BOOL;
	BCTUnderVoltage  AT %I*: BOOL;
	BCTChopperOn  AT %I*: BOOL;
	BCTDCLinkVoltage AT %I*: UDINT;
	BCTDutyCycle  AT %I*: USINT;
	BCTResistorCurrent AT %I*: UDINT;
	WcState_WcState AT %I*: BOOL;
	InfoData_State AT %I*: UINT;
	
END_VAR
```

### EL9576_v1_00: ST

```vhdl
EnO:=En;

IF En AND (WcState_WcState OR InfoData_State<>16#8 OR BCTI2TError OR BCTI2TWarning OR BCTOverTemperature OR BCTOverVoltage OR BCTUnderVoltage) THEN
	bError:=TRUE;
ELSE
	bError:=FALSE;
END_IF

OverTemperature:=BCTOverTemperature;
I2TError:=BCTI2TError;
I2TWarning:=BCTI2TWarning;
OverVoltage:=BCTOverVoltage;
UnderVoltage:=bctUnderVoltage;
ChopperOn:=bctChopperOn;
DCLinkVoltage:=UDINT_TO_LREAL(bctDCLinkVoltage);
DutyCycle:=USINT_TO_LREAL(BCTDutyCycle);
ResistorCurrent:=UDINT_TO_LREAL(BCTResistorCurrent);
```


tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/System/EL9410.TcPOU (TcPlcObject)
---------------------------------------------------------------------------------

### EL9410: Declaration

```vhdl
//EL9410 | E-Bus power supplier and refresher, diagnostics
FUNCTION_BLOCK EL9410

VAR_INPUT
	En: BOOL;
	iTerminal_ID : INT;
	ErrorSystem : POINTER TO ST_ErrorSystem;
END_VAR

VAR_OUTPUT
	EnO: BOOL;
	bError: BOOL;
END_VAR

VAR
	bStatus_Us_UV AT %I* : BOOL;
	bStatus_Up_UV AT %I* : BOOL;
	WcState_WcState AT %I*: BOOL;
	InfoData_State AT %I*: UINT;
	
	//FB-s
	EL9410_Error : FB_TerminalError;
END_VAR
```

### EL9410: ST

```vhdl
(*
* TODO:
* Status bits
*)

EnO:=En;

//Error FB instance
EL9410_Error(
	En := TRUE,
	iTerminal_ID := iTerminal_ID,
	bWcState := WcState_WcState,
	uiInfoData_State := InfoData_State,
	pErrorSystem := ErrorSystem,
	bError => bError,
);
```


tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/System/EL9505.TcPOU (TcPlcObject)
---------------------------------------------------------------------------------

### EL9505: Declaration

```vhdl
//EL9505 | Power supply terminal 5V
FUNCTION_BLOCK EL9505

VAR_INPUT
	En: BOOL;
	iTerminal_ID : INT;
	ErrorSystem : POINTER TO ST_ErrorSystem;
END_VAR

VAR_OUTPUT
	EnO: BOOL;
	bError: BOOL;
END_VAR

VAR
	bStatus_Uo_Power_OK AT %I* : BOOL;
	bStatus_Uo_Overload AT %I* : BOOL;
	WcState_WcState AT %I*: BOOL;
	InfoData_State AT %I*: UINT;
	
	//FB-s
	EL9505_Error : FB_TerminalError;
END_VAR
```

### EL9505: ST

```vhdl
(*
* TODO:
* Status bits
*)
EnO:=En;

//Error FB instance
EL9505_Error(
	En := TRUE,
	iTerminal_ID := iTerminal_ID,
	bWcState := WcState_WcState,
	uiInfoData_State := InfoData_State,
	pErrorSystem := ErrorSystem,
	bError => bError,
);
```


tc_mca_std_lib/POUs/Hardware/Other/EK1200.TcPOU (TcPlcObject)
-------------------------------------------------------------

### EK1200: Declaration

```vhdl
FUNCTION_BLOCK EK1200
VAR_INPUT
	En: BOOL;
END_VAR
VAR_OUTPUT
	EnO: BOOL;
END_VAR
```

### EK1200: ST

```vhdl
EnO:=En;
```


tc_mca_std_lib/POUs/Motion/FB_DriveVirtual.TcPOU (TcPlcObject)
--------------------------------------------------------------

### FB_DriveVirtual: Declaration

```vhdl
///#########################################################
///Function block to run a virtual drive with Nc
///	Library:		
///	Tc2_MC2.lib
///
///	Global Variables:
///	
///	Data types:
///	
///	External functions:
///
///###########################################################
FUNCTION_BLOCK FB_DriveVirtual
VAR
	sVersion: STRING:='1.0.3';	
END_VAR
VAR_INPUT
	En: BOOL;
	bEnable: BOOL;
	bReset: BOOL;
	bExecute: BOOL;
	/////	nCommandLocal...
	/////	0 = Jog
	/////	1 = MoveVelocity
	/////	2 = MoveRelative
	/////	3 = MoveAbsolut
	/////	4 = MoveModulo
	/////	10 = Homing
	/////	20 = SuperInp >>>ToBe
	/////	30 = Gear
	nCommand: UINT;
	nCmdData: UINT;
	fVelocity: LREAL;
	fPosition: LREAL;
	fAcceleration: LREAL;
	fDeceleration: LREAL;
	bJogFwd: BOOL;
	bJogBwd: BOOL;
	bLimitFwd: BOOL;
	bLimitBwd: BOOL;	
	fOverride: LREAL := 100;
	bHomeSensor: BOOL;
	fHomePosition:LREAL;
	nHomeRevOffset: UINT;
	MasterAxis: AXIS_REF;
	bPowerSelf: BOOL;
END_VAR
VAR_OUTPUT
	EnO: BOOL;
	bEnabled: BOOL;
	bBusy: BOOL;
	bDone: BOOL;
	bError: BOOL;
	bHomed: BOOL;
	nErrorId: UDINT;
	nMotionAxisID:UDINT:=0;  //Axis id in Motion (NC)
	Status: ST_AxisStatus;
	fActVelocity: LREAL;
	fActPosition: LREAL;
	fActDiff: LREAL;
    sErrorMessage:STRING;
END_VAR
VAR_IN_OUT
	Axis: AXIS_REF;
END_VAR
VAR	
	nCommandLocal: UINT;
	nCmdDataLocal: UINT;
	bFirstScan: BOOL := TRUE;
	fbReset: MC_Reset;
	fbPower: MC_Power;
	fbHalt: MC_Halt;
	fbJog: MC_Jog;
	fbMoveVelocity: MC_MoveVelocity;
	fbMoveRelative: MC_MoveRelative;
	fbMoveAbsolute: MC_MoveAbsolute;
	fbMoveModulo: MC_MoveModulo;	
	fbHomeVirtual:FB_HomeVirtual;
	fbGearInDyn: MC_GearInDyn;
	fbGearOut: MC_GearOut;
	fbExecuteRiseEdge: R_TRIG;
	stAxisStatus: DUT_AxisStatus_v0_01;	
END_VAR
```

### FB_DriveVirtual: ST

```vhdl
EnO:=En;

// Transfer nCommand and nCmdData to local copies at rising edge of bExecute (avoid issues if nCommand or nCmdData are changed during a command) 
fbExecuteRiseEdge(CLK:=bExecute);
IF fbExecuteRiseEdge.Q THEN
  nCmdDataLocal:=nCmdData;
  nCommandLocal:=nCommand;
END_IF

bHomed:=fbHomeVirtual.bHomed; //Add in DUT_AxisStatus later
bDone:=FALSE;

(*Reset*)
fbReset(
	Execute:=bReset AND Axis.Status.Error,
	Axis:=Axis,
	Done=> ,
	Busy=> ,
	Error=> ,
	ErrorID=> );

(*Power*)
IF bPowerSelf THEN
fbPower(
	Axis:=Axis,
	Enable:=bEnable,	
	Enable_Positive:=bEnable AND bLimitFwd,	
	Enable_Negative:=bEnable AND bLimitBwd,	
	Override:=fOverride,
	BufferMode:= ,
	Status=> ,
	Busy=> ,
	Active=> ,
	Error=> ,
	ErrorID=> );
END_IF

(*Halt*)
fbHalt(
	Execute:=NOT bExecute  AND (((fbMoveVelocity.Busy OR fbPower.Busy) AND (nCommandLocal=1)) OR (fbMoveRelative.Busy AND (nCommandLocal=2)) OR (fbMoveAbsolute.Busy AND (nCommandLocal=3)) OR (fbMoveModulo.Busy AND (nCommandLocal=4)) OR (fbHomeVirtual.bBusy AND (nCommandLocal=10))),
	Deceleration:=fDeceleration,
	Jerk:=0,
	BufferMode:= ,
	Options:= ,
	Axis:=Axis ,
	Done=> ,
	Busy=> ,
	Active=> ,
	CommandAborted=> ,
	Error=> ,
	ErrorID=> );

(*Jog (Command = 0)*)
fbJog(
	JogForward:=bJogFwd AND (nCommandLocal=0) ,
	JogBackwards:=bJogBwd AND (nCommandLocal=0) ,
	Mode:=UINT_TO_INT(nCmdDataLocal),
	Position:= ,
	Velocity:=fVelocity,
	Acceleration:=fAcceleration,
	Deceleration:=fDeceleration,
	Jerk:=0,
	Axis:=Axis,
	Done=> ,
	Busy=> ,
	Active=> ,
	CommandAborted=> ,
	Error=> ,
	ErrorID=> );

(*MoveVelocity (Command = 1)*)
fbMoveVelocity(
	Execute:=bExecute AND (nCommandLocal=1),
	Velocity:=ABS(fVelocity),
	Acceleration:=fAcceleration,
	Deceleration:=fDeceleration,
	Jerk:=0,
	Direction:=SEL(fVelocity<0, MC_Positive_Direction, MC_Negative_Direction),
	BufferMode:= ,
	Options:= ,
	Axis:=Axis,
	InVelocity=> ,
	Busy=> ,
	Active=> ,
	CommandAborted=> ,
	Error=> ,
	ErrorID=> );

(*MoveRelative (Command = 2)*)
fbMoveRelative(
	Execute:=bExecute AND (nCommandLocal=2), 
	Distance:=fPosition, 
	Velocity:=ABS(fVelocity), 
	Acceleration:=fAcceleration,
	Deceleration:=fDeceleration,
	Jerk:=0,
	BufferMode:= , 
	Options:= , 
	Axis:=Axis, 
	Done=> , 
	Busy=> , 
	Active=> , 
	CommandAborted=> , 
	Error=> , 
	ErrorID=> );
	
IF nCommandLocal=2 THEN
	bDone:=fbMoveRelative.Done;
END_IF
	
(*MoveAbsolute (Command = 3)*)
fbMoveAbsolute(
	Execute:=bExecute AND (nCommandLocal=3),
	Position:=fPosition,
	Velocity:=ABS(fVelocity),
	Acceleration:=fAcceleration,
	Deceleration:=fDeceleration,
	Jerk:=0,
	BufferMode:= ,
	Options:= ,
	Axis:=Axis,
	Done=> ,
	Busy=> ,
	Active=> ,
	CommandAborted=> ,
	Error=> ,
	ErrorID=> );

IF nCommandLocal=3 THEN
	bDone:=fbMoveAbsolute.Done;
END_IF

(*MoveModulo (Command = 4)*)
fbMoveModulo(
	Execute:=bExecute AND (nCommandLocal=4), 
	Position:=fPosition, 
	Velocity:=ABS(fVelocity), 
	Acceleration:=fAcceleration, 
	Deceleration:=fDeceleration, 
	Jerk:=0, 
	Direction:=UINT_TO_INT(nCmdDataLocal), 
	BufferMode:= , 
	Options:= , 
	Axis:=Axis, 
	Done=> , 
	Busy=> , 
	Active=> , 
	CommandAborted=> , 
	Error=> , 
	ErrorID=> );

IF nCommandLocal=4 THEN
	bDone:=fbMoveModulo.Done;
END_IF
	
(*Home (Command = 10)*)
fbHomeVirtual(	
	bExecute:= nCommandLocal=10 AND bExecute,
	fHomePosition:=fHomePosition,
	bHomeSensor:=bHomeSensor,
	bLimitBwd:=bLimitBwd,
	bLimitFwd:=bLimitFwd,
	nCmdData:=nCmdDataLocal,
	bReset:=bReset,
	nHomeRevOffset:=nHomeRevOffset,
	Axis:=Axis
	);
	
IF nCommandLocal=10 THEN
	bDone:=fbHomeVirtual.bDone;
END_IF
	
(*Gear (Command = 30)*)
fbGearInDyn(
	Enable:=bExecute  AND (nCommandLocal=30),
	GearRatio:=SEL(nCmdDataLocal>0, 1,fVelocity),
	Acceleration:=fAcceleration,
	Deceleration:=fDeceleration,
	Jerk:=0.0,
	BufferMode:= , 
	Options:= , 
	Master:=MasterAxis,
	Slave:=Axis,
	InGear=> , 
	Busy=> , 
	Active=> , 
	CommandAborted=> , 
	Error=> , 
	ErrorID=> );
	
fbGearOut(
	Execute:=NOT bExecute AND Axis.Status.NotMoving AND (nCommandLocal=30),
	Slave:=Axis,
	Error=>,
	Done=>,
	ErrorID=>);


IF nCommandLocal=30 THEN
	bDone:=Axis.Status.Coupled;
END_IF

(*Busy*)
bBusy:=Axis.Status.HasJob OR Axis.Status.HomingBusy OR fbHomeVirtual.bBusy;

(*Enabled*)
bEnabled:=fbPower.Status;

(*Error from functions and Nc*)
IF fbPower.Error AND fbPower.Active THEN
	bError:=fbPower.Enable;
	nErrorId:=fbPower.ErrorID;
ELSIF fbHalt.Error AND fbHalt.Active THEN
	bError:=fbHalt.Execute;
	nErrorId:=fbHalt.ErrorID;
ELSIF fbJog.Error AND nCommandLocal=0 (*fbJog.Active*) THEN
	bError:=fbJog.JogForward OR fbJog.JogBackwards;
	nErrorId:=fbJog.ErrorID;
ELSIF fbMoveVelocity.Error AND nCommandLocal=1(*fbMoveVelocity.Active*) THEN
	bError:=fbMoveVelocity.Execute;
	nErrorId:=fbMoveVelocity.ErrorID;
ELSIF fbMoveRelative.Error AND nCommandLocal=2 (*fbMoveRelative.Active*) THEN
	bError:=fbMoveRelative.Execute;
	nErrorId:=fbMoveRelative.ErrorID;
ELSIF fbMoveAbsolute.Error AND nCommandLocal=3 (*fbMoveAbsolute.Active*) THEN
	bError:=fbMoveAbsolute.Execute;
	nErrorId:=fbMoveAbsolute.ErrorID;
ELSIF fbMoveModulo.Error AND nCommandLocal=4 (*fbMoveModulo.Active*) THEN
	bError:=fbMoveModulo.Execute;
	nErrorId:=fbMoveModulo.ErrorID;
ELSIF fbHomeVirtual.bError AND nCommandLocal=10 (*fbHome.Active*) THEN
	bError:=fbHomeVirtual.bError;
	nErrorId:=fbHomeVirtual.nErrorID;
ELSIF fbGearInDyn.Error AND nCommandLocal=30 (*fbGearInDyn.Active*) THEN
	bError:=fbGearInDyn.Enable;
	nErrorId:=fbGearInDyn.ErrorID;
ELSIF fbGearOut.Error AND nCommandLocal=30 AND Axis.Status.Coupled THEN
	bError:=fbGearOut.Execute;
	nErrorId:=fbGearOut.ErrorID;
ELSIF Axis.Status.Error  THEN
	bError:=TRUE;
	nErrorId:=Axis.Status.ErrorID;
ELSIF fbHomeVirtual.bError THEN
	bError:=TRUE;
	nErrorId:=fbHomeVirtual.nErrorId;
ELSE
	bError:=FALSE;
	nErrorId:=0;
END_IF;

(*Converese nErrorID to string*)
sErrorMessage:=WORD_TO_HEXSTR(in:=TO_WORD(nErrorID) , iPrecision:= 4, bLoCase:=0 );

(*Status from Nc*)
Status:=Axis.Status;

(*Axis id in motion "motor"*)
nMotionAxisID:=axis.NcToPlc.AxisId;

(*Actual Velocity*)
fActVelocity:=Axis.NcToPlc.ActVelo;

(*Actual Position*)
IF Axis.Status.OpMode.Modulo THEN
	fActPosition:=Axis.NcToPlc.ModuloActPos;
ELSE
	fActPosition:=Axis.NcToPlc.ActPos;
END_IF

(*Actual Position*)
fActDiff:=Axis.NcToPlc.PosDiff;


//Status struct for EPICS communication
stAxisStatus.bEnable:=bEnable;
stAxisStatus.bEnabled:=bEnabled;
stAxisStatus.bError:=bError;
stAxisStatus.bExecute:=bExecute;
stAxisStatus.bHomeSensor:=bHomeSensor;
stAxisStatus.bJogBwd:=bJogBwd;
stAxisStatus.bJogFwd:=bJogFwd;
stAxisStatus.bLimitBwd:=bLimitBwd;
stAxisStatus.bLimitFwd:=bLimitFwd;
stAxisStatus.bReset:=bReset;
stAxisStatus.fAcceleration:=fAcceleration;
stAxisStatus.fActDiff:=fActDiff;
stAxisStatus.fActPosition:=fActPosition;
stAxisStatus.fActVelocity:=fActVelocity;
stAxisStatus.fDeceleration:=fDeceleration;
stAxisStatus.fOverride:=fOverride;
stAxisStatus.fPosition:=fPosition;
stAxisStatus.fVelocity:=fVelocity;
stAxisStatus.nCmdData:=nCmdData;  //Or nCmdDataLocal
stAxisStatus.nCommand:=nCommand;  //Or nCommandLocal
stAxisStatus.nErrorId:=nErrorId;
stAxisStatus.bBusy:=bBusy;
stAxisStatus.bHomed:=bHomed;

IF bFirstScan THEN
	bFirstScan:=FALSE;
END_IF
```


tc_mca_std_lib/POUs/Motion/FB_NcAxis.TcPOU (TcPlcObject)
--------------------------------------------------------

### FB_NcAxis: Declaration

```vhdl
///#########################################################
///Function block to communicate between Nc and Plc.
///
///	Library:		
///	Tc2_MC2.lib
///
///	Global Variables:
///	
///	Data types:
///	
///	External functions:
///
///###########################################################
FUNCTION_BLOCK FB_NcAxis
VAR
	sVersion: STRING:='1.0.0';
END_VAR
VAR_INPUT
	En: BOOL;
END_VAR
VAR_OUTPUT
	EnO: BOOL;
	bError: BOOL;
	Status: ST_AxisStatus;
END_VAR
VAR
	Axis: AXIS_REF;
	InfoData_State AT %I*: UINT;
END_VAR
```

### FB_NcAxis: ST

```vhdl
EnO:=En;

IF En AND InfoData_State<>16#8 THEN
	bError:=TRUE;
ELSE
	bError:=FALSE;
END_IF

IF En THEN
	Axis.ReadStatus();
	Status:=Axis.Status;
END_IF
```


tc_mca_std_lib/POUs/Motion/Homing/FB_HomeDirect.TcPOU (TcPlcObject)
-------------------------------------------------------------------

### FB_HomeDirect: Declaration

```vhdl
FUNCTION_BLOCK FB_HomeDirect
VAR_INPUT
	En: BOOL;
	bReset: BOOL;
    bExecute: BOOL;	
	fHomePosition:LREAL;	
END_VAR
VAR_IN_OUT
	Axis: AXIS_REF;
END_VAR
VAR_OUTPUT
	EnO: BOOL;	
	bBusy: BOOL;
	bDone: BOOL;
	bHomed:BOOL;
	bError: BOOL;
	nErrorId: UDINT;
END_VAR
VAR
	fbHome: MC_Home;	
END_VAR
```

### FB_HomeDirect: ST

```vhdl
En:=EnO;
IF bReset THEN
	bError:=FALSE;
	nErrorId:=0;
END_IF 

fbHome(
	Execute:=bExecute,
	Position:=fHomePosition,
	HomingMode:=MC_Direct,
	bCalibrationCam:=FALSE,
	Axis:=Axis
	);
	
bBusy:=fbHome.Busy;
bDone:=fbHome.Done;
bHomed:=Axis.Status.Homed;

bError:=fbHome.Error; 

IF fbHome.Error THEN
  nErrorId:=fbHome.ErrorID;
END_IF
```


tc_mca_std_lib/POUs/Motion/Homing/FB_HomeFinish.TcPOU (TcPlcObject)
-------------------------------------------------------------------

### FB_HomeFinish: Declaration

```vhdl
FUNCTION_BLOCK FB_HomeFinish
VAR_INPUT
	En: BOOL;
	bReset: BOOL;
    bExecute: BOOL;	
    nCmdData: UINT;
	bSofLimEnableLow: BOOL:=TRUE;
	bSofLimEnableHigh: BOOL:=TRUE;			
END_VAR
VAR_IN_OUT
	Axis: AXIS_REF;
END_VAR
VAR_OUTPUT
	EnO: BOOL;	
	bBusy: BOOL;
	bDone: BOOL;
	bError: BOOL;
	nErrorId: UDINT;
END_VAR
VAR		
	fbHomewriteSoftLimEnable:FB_HomeWriteSoftLimEnable;	
	fbExecuteRiseEdge: R_TRIG;	
	bExecuteWriteNC:BOOL:=FALSE;
	nState:INT:=0;
END_VAR
```

### FB_HomeFinish: ST

```vhdl
En:=EnO;
IF bReset THEN
	bError:=FALSE;
	nErrorId:=0;
END_IF 

IF NOT bExecute THEN
  bExecuteWriteNC:=FALSE;
  fbHomewriteSoftLimEnable.bSofLimEnableLow:=bSofLimEnableLow;
  fbHomewriteSoftLimEnable.bSofLimEnableHigh:=bSofLimEnableHigh;   
  nState:=0;
END_IF

fbExecuteRiseEdge(CLK:=bExecute);
IF fbExecuteRiseEdge.Q THEN
  bExecuteWriteNC:=TRUE;  
  fbHomewriteSoftLimEnable.bSofLimEnableLow:=bSofLimEnableLow;
  fbHomewriteSoftLimEnable.bSofLimEnableHigh:=bSofLimEnableHigh;
END_IF

// Write to NC (disable soft limits)
fbHomewriteSoftLimEnable(
	En:=En,
	bExecute:=bExecuteWriteNC AND bExecute,
	Axis:=Axis,
	bReset:=bReset,	
);

bBusy:=fbHomewriteSoftLimEnable.bBusy;
bDone:=fbHomewriteSoftLimEnable.bDone;

bError:=fbHomewriteSoftLimEnable.bError;
IF fbHomewriteSoftLimEnable.bError THEN
  nErrorId:=fbHomewriteSoftLimEnable.nErrorId;
END_IF
```


tc_mca_std_lib/POUs/Motion/Homing/FB_HomePrepare.TcPOU (TcPlcObject)
--------------------------------------------------------------------

### FB_HomePrepare: Declaration

```vhdl
FUNCTION_BLOCK FB_HomePrepare
VAR_INPUT
	En: BOOL;
	bReset: BOOL;
    bExecute: BOOL;	
    nCmdData: UINT;		
END_VAR
VAR_IN_OUT
	Axis: AXIS_REF;
END_VAR
VAR_OUTPUT
	EnO: BOOL;	
	bBusy: BOOL;
	bDone: BOOL;
	bError: BOOL;
	nErrorId: UDINT;
	bSofLimEnableLowOriginal: BOOL:=TRUE;
	bSofLimEnableHighOriginal: BOOL:=TRUE;	
	fVelocityToCam: LREAL:=0;
	fVelocityFromCam: LREAL:=0;		
END_VAR
VAR
	fbHomeReadSoftLimEnable:FB_HomeReadSoftLimEnable;	
	fbHomeDisableSoftLimEnable:FB_HomeWriteSoftLimEnable;
	fbHomeReadNCVelocities: FB_HomeReadNcVelocities;
	fbHomeResetCalibrationFlag:MC_Home;   //Only used for reset of calibration flag
	fbExecuteRiseEdge: R_TRIG;
	bExecuteReadNC:BOOL:=FALSE;
	bExecuteWriteNC:BOOL:=FALSE;
	nState:INT:=0;
END_VAR
```

### FB_HomePrepare: ST

```vhdl
En:=EnO;
IF bReset THEN
	bError:=FALSE;
	nErrorId:=0;
END_IF 

IF NOT bExecute THEN
  bExecuteReadNC:=FALSE;
  bExecuteWriteNC:=FALSE;   
  nState:=0;
END_IF

fbExecuteRiseEdge(CLK:=bExecute);
IF fbExecuteRiseEdge.Q THEN
  bExecuteReadNC:=TRUE;  
END_IF

// Read from NC
fbHomeReadNCVelocities(
  En:=En,
  bExecute:=bExecuteReadNC, // Actualy not needed for sequence 15 (set position only, no movement))
  bReset:=bReset,
  Axis:=Axis,
);

fbHomeReadSoftLimEnable(
	En:=En,
	bExecute:=bExecuteReadNC AND bExecute,
	Axis:=Axis,
	bReset:=bReset,	
);

// Reset calibration flag
fbHomeResetCalibrationFlag(
  Execute:=bExecuteReadNC,
  HomingMode:=MC_ResetCalibration,
  Axis:=Axis
);

bSofLimEnableLowOriginal:=fbHomeReadSoftLimEnable.bSofLimEnableLow;
bSofLimEnableHighOriginal:=fbHomeReadSoftLimEnable.bSofLimEnableHigh;	

fVelocityToCam:=fbHomeReadNCVelocities.fVelocityToCam;
fVelocityFromCam:=fbHomeReadNCVelocities.fVelocityFromCam;

IF bExecuteReadNC AND bExecute AND fbHomeReadSoftLimEnable.bDone THEN
	fbHomeDisableSoftLimEnable.bSofLimEnableHigh:=FALSE;
	fbHomeDisableSoftLimEnable.bSofLimEnableLow:=FALSE;
	bExecuteWriteNC:=TRUE; //Always write (only needed if enabled actually)
END_IF

// Write to NC (disable soft limits)
fbHomeDisableSoftLimEnable(
	En:=En,
	bExecute:=bExecuteWriteNC AND bExecute,
	Axis:=Axis,
	bReset:=bReset,	
);

bBusy:=fbHomeReadSoftLimEnable.bBusy OR fbHomeDisableSoftLimEnable.bBusy OR fbHomeReadNCVelocities.bBusy OR fbHomeResetCalibrationFlag.Busy;
bDone:=fbHomeReadSoftLimEnable.bDone AND fbHomeDisableSoftLimEnable.bDone AND fbHomeReadNCVelocities.bDone AND fbHomeResetCalibrationFlag.Done AND bExecute;

bError:=fbHomeReadSoftLimEnable.bError OR fbHomeDisableSoftLimEnable.bError OR fbHomeReadNCVelocities.bError OR fbHomeResetCalibrationFlag.Error;
IF fbHomeReadSoftLimEnable.bError THEN
  nErrorId:=fbHomeReadSoftLimEnable.nErrorId;
ELSIF fbHomeDisableSoftLimEnable.bError THEN
  nErrorId:=fbHomeDisableSoftLimEnable.nErrorId;
ELSIF fbHomeResetCalibrationFlag.Error THEN
  nErrorId:=fbHomeResetCalibrationFlag.ErrorId;
END_IF
```


tc_mca_std_lib/POUs/Motion/Homing/FB_HomeReadNcVelocities.TcPOU (TcPlcObject)
-----------------------------------------------------------------------------

### FB_HomeReadNcVelocities: Declaration

```vhdl
FUNCTION_BLOCK FB_HomeReadNcVelocities
VAR_INPUT
	En: BOOL;
	bReset: BOOL;
    bExecute: BOOL;			
END_VAR
VAR_IN_OUT
	Axis: AXIS_REF;
END_VAR
VAR_OUTPUT
	EnO: BOOL;	
	bBusy: BOOL;
	bDone: BOOL;
	bError: BOOL;
	nErrorId: UDINT;	
	fVelocityToCam: LREAL;
	fVelocityFromCam: LREAL;
END_VAR
VAR
	fbReadVelocityToCam:FB_ReadFloatParameter;
	fbReadVelocityFromCam:FB_ReadFloatParameter;
END_VAR
```

### FB_HomeReadNcVelocities: ST

```vhdl
En:=EnO;
IF bReset THEN
	bError:=FALSE;
	nErrorId:=0;
END_IF 
	
fbReadVelocityToCam(
	bExecute:=bExecute,
	nDeviceGroup:= 16#4000,
	nIndexOffset:= 16#6,
	Axis:= Axis);
	
fbReadVelocityFromCam(
	bExecute:=bExecute,
	nDeviceGroup:= 16#4000,
	nIndexOffset:= 16#7,
	Axis:= Axis);
	
fVelocityToCam:=fbReadVelocityToCam.nData;
fVelocityFromCam:=fbReadVelocityFromCam.nData;	

bBusy:=fbReadVelocityFromCam.bBusy OR fbReadVelocityToCam.bBusy;
bDone:=fbReadVelocityFromCam.bDone AND fbReadVelocityToCam.bDone AND bExecute;

bError:=fbReadVelocityToCam.bError OR fbReadVelocityFromCam.bError;
IF fbReadVelocityToCam.bError THEN
  nErrorId:=fbReadVelocityToCam.nErrorId;
ELSIF fbReadVelocityFromCam.bError THEN
  nErrorId:=fbReadVelocityFromCam.nErrorId;
END_IF
```


tc_mca_std_lib/POUs/Motion/Homing/FB_HomeReadSoftLimEnable.TcPOU (TcPlcObject)
------------------------------------------------------------------------------

### FB_HomeReadSoftLimEnable: Declaration

```vhdl
FUNCTION_BLOCK FB_HomeReadSoftLimEnable
VAR_INPUT
	En: BOOL;
	bReset: BOOL;
    bExecute: BOOL;			
END_VAR
VAR_IN_OUT
	Axis: AXIS_REF;
END_VAR
VAR_OUTPUT
	EnO: BOOL;	
	bBusy: BOOL;
	bDone: BOOL;
	bError: BOOL;
	nErrorId: UDINT;	
	bSofLimEnableLow: BOOL:=TRUE;
	bSofLimEnableHigh: BOOL:=TRUE;
END_VAR
VAR
	fbReadSoftLimEnableLow:FB_ReadParameterInNc_v1_00;
	fbReadSoftLimEnableHigh:FB_ReadParameterInNc_v1_00;
END_VAR
```

### FB_HomeReadSoftLimEnable: ST

```vhdl
En:=EnO;
IF bReset THEN
	bError:=FALSE;
	nErrorId:=0;
END_IF 
	
fbReadSoftLimEnableLow(
	bExecute:=bExecute,
	nDeviceGroup:= 16#5000,
	nIndexOffset:= 16#B,
	Axis:= Axis);

fbReadSoftLimEnableHigh(
	bExecute:=bExecute,
	nDeviceGroup:= 16#5000,
	nIndexOffset:= 16#C,
	Axis:= Axis);
	
bSofLimEnableLow:=DWORD_TO_BOOL(fbReadSoftLimEnableLow.nData);
bSofLimEnableHigh:=DWORD_TO_BOOL(fbReadSoftLimEnableHigh.nData);	

bBusy:=fbReadSoftLimEnableLow.bBusy OR fbReadSoftLimEnableHigh.bBusy;
bDone:=fbReadSoftLimEnableLow.bDone AND fbReadSoftLimEnableHigh.bDone AND bExecute;

bError:=fbReadSoftLimEnableLow.bError OR fbReadSoftLimEnableHigh.bError;
IF fbReadSoftLimEnableLow.bError THEN
  nErrorId:=fbReadSoftLimEnableLow.nErrorId;
ELSIF fbReadSoftLimEnableHigh.bError THEN
  nErrorId:=fbReadSoftLimEnableHigh.nErrorId;
END_IF
```


tc_mca_std_lib/POUs/Motion/Homing/FB_HomeToSwitch.TcPOU (TcPlcObject)
---------------------------------------------------------------------

### FB_HomeToSwitch: Declaration

```vhdl
FUNCTION_BLOCK FB_HomeToSwitch
VAR_INPUT
	En: BOOL;
	bReset: BOOL;
    bExecute: BOOL;	
    bCamSensor:BOOL;	
	nSearchDirTwoardsCam: MC_Direction;
	nSearchDirOffCam: MC_Direction;
	fHomePosition:LREAL;	
	fVelocityToCamNC: LREAL; //Velcoity when searching for cam
	fVelocityFromCamNC: LREAL; // Velocity after found cam (searching for next signal transition)
END_VAR
VAR_IN_OUT
	Axis: AXIS_REF;
END_VAR
VAR_OUTPUT
	EnO: BOOL;	
	bBusy: BOOL;
	bDone: BOOL;
	bHomed:BOOL;
	bError: BOOL;
	nErrorId: UDINT;
END_VAR
VAR
	fbHome: MC_Home;	
	fbWriteHomeDirCamToNC:FB_WriteParameterInNc_v1_00;
	fbWriteHomeDirSyncToNC:FB_WriteParameterInNc_v1_00;
	fbWriteHomeModeToNC:FB_WriteParameterInNc_v1_00;
	fbWriteHomeVelocitiesToNC: FB_HomeWriteNcVelocities;
	bConfigNCDone:BOOL:=FALSE;
	fbRTrigg: R_TRIG;
END_VAR
```

### FB_HomeToSwitch: ST

```vhdl
En:=EnO;
IF bReset THEN
	bConfigNCDone:=FALSE;
	bError:=FALSE;
	nErrorId:=0;
END_IF 
	
//Start preparation of NC if rising edge on bExecute
fbRTrigg(CLK:=bExecute);
IF fbRTrigg.Q THEN
	bConfigNCDone:=FALSE;
END_IF

 
fbWriteHomeDirCamToNC(
	bExecute:=bExecute AND NOT bConfigNCDone,
	nDeviceGroup:=16#5000,
	nIndexOffset:=16#101,	//Direction for Calibration Cam Search	
	nData:=BOOL_TO_DWORD(nSearchDirTwoardsCam=MC_Negative_Direction),//BOOL_TO_DWORD(NOT bSearchDirTwoardsCam),
	Axis:=Axis
);

fbWriteHomeDirSyncToNC(
	bExecute:= bExecute AND NOT bConfigNCDone,
	nDeviceGroup:=16#5000 ,
	nIndexOffset:=16#102 , //Direction for Sync Impuls Search
	nData:=BOOL_TO_DWORD(nSearchDirOffCam=MC_Negative_Direction),//BOOL_TO_DWORD(NOT bSearchDirOffCam),
	Axis:= Axis 
);

fbWriteHomeModeToNC(
	bExecute:=bExecute AND NOT bConfigNCDone,
	nDeviceGroup:=16#5000,
	nIndexOffset:=16#107,  //Reference Mode
	nData:=1,
	Axis:=axis);
	
fbWriteHomeVelocitiesToNC(
  En:=En,
  bExecute:=bExecute AND NOT bConfigNCDone,
  bReset:=bReset,
  fVelocityFromCam:=fVelocityFromCamNC,
  fVelocityToCam:=fVelocityToCamNC,
  Axis:=Axis);

fbHome.bCalibrationCam:=bCamSensor;

fbHome(
	Execute:=bExecute AND bConfigNCDone(* AND NOT bError*),
	Position:=fHomePosition,
	HomingMode:=0,
	Axis:=Axis
	);
bBusy:=(fbHome.Busy OR (NOT bConfigNCDone AND bExecute));
bDone:=fbHome.Done AND bConfigNCDone;
bHomed:=Axis.Status.Homed;

IF (NOT bConfigNCDone) AND fbWriteHomeDirCamToNC.bDone AND fbWriteHomeDirSyncToNC.bDone AND fbWriteHomeModeToNC.bDone AND fbWriteHomeVelocitiesToNC.bDone THEN
  bConfigNCDone:=TRUE;
END_IF

//For some reason MC_HOME gives an Error for one cycle of NC-Task 1 SVB (10ms default..) so filter with bExecute
bError:=(fbHome.Error AND bExecute) OR fbWriteHomeDirCamToNC.bError OR fbWriteHomeDirSyncToNC.bError OR fbWriteHomeModeToNC.bError OR fbWriteHomeVelocitiesToNC.bError;

IF (fbHome.Error AND bExecute) THEN
  nErrorId:=fbHome.ErrorID;
ELSIF fbWriteHomeDirCamToNC.bError THEN
  nErrorId:=fbWriteHomeDirCamToNC.nErrorId;
ELSIF fbWriteHomeDirSyncToNC.bError THEN
  nErrorId:=fbWriteHomeDirSyncToNC.nErrorId;
ELSIF fbWriteHomeModeToNC.bError THEN
  nErrorId:=fbWriteHomeModeToNC.nErrorId;
ELSIF fbWriteHomeVelocitiesToNC.bError THEN
  nErrorId:=fbWriteHomeVelocitiesToNC.nErrorId;  
END_IF
```


tc_mca_std_lib/POUs/Motion/Homing/FB_HomeVirtual.TcPOU (TcPlcObject)
--------------------------------------------------------------------

### FB_HomeVirtual: Declaration

```vhdl
FUNCTION_BLOCK FB_HomeVirtual
VAR_INPUT
	En: BOOL;
	bReset: BOOL;
	bExecute: BOOL;
	nCmdData: UINT;
	bLimitFwd: BOOL;
	bLimitBwd: BOOL;	
	bHomeSensor: BOOL;	
	fHomePosition:LREAL;
	nHomeRevOffset: UINT;
END_VAR
VAR_IN_OUT
	Axis: AXIS_REF;
END_VAR
VAR_OUTPUT
	EnO: BOOL;	
	bBusy: BOOL;
	bDone: BOOL;
	bHomed:BOOL;
	bError: BOOL;
	nErrorId: UDINT;
END_VAR
VAR
	fbHomeToSwitch: FB_HomeToSwitch;
    fbHomeDirect: FB_HomeDirect; //Only used for direct homing (set of position)
    fbMoveVelocity:MC_MoveVelocity;
    fbHomePrepare:FB_HomePrepare;
	fbHomeFinish:FB_HomeFinish;    	    		
	fbExecuteRiseEdge: R_TRIG;
    nHomingState:INT:=0;
	bExecuteHomeToSwitch:BOOL:=FALSE;
	bExecuteMoveVelocity:BOOL:=FALSE;
	bExecutePrepare: BOOL:=FALSE;
	bExecuteFinish: BOOL:=FALSE;
	bExecuteHomeDirect: BOOL;
	nCmdDataLocal: UINT;  //Ensure that nCmdData is not changed during sequence
	bSequenceReady:BOOL:=TRUE;
	bRestoreNCDataNeeded: BOOL:=FALSE;
END_VAR
```

### FB_HomeVirtual: ST

```vhdl
EnO:=En;

IF bReset THEN	
	bError:=FALSE;
	nErrorId:=0;
END_IF

// Reset when bExecute is low
IF NOT bExecute THEN
  nHomingState:=0;
  bSequenceReady:=TRUE;
  bExecuteHomeToSwitch:=FALSE;
  bExecuteHomeDirect:=FALSE;
  bExecuteMoveVelocity:=FALSE;
  bExecutePrepare:=FALSE;
  bExecuteFinish:=FALSE;
END_IF

//Reset at rinsing edge of bExecute
fbExecuteRiseEdge(CLK:=bExecute);
IF fbExecuteRiseEdge.Q THEN
  nCmdDataLocal:=nCmdData; //Ensure that nCmdData is not changed during sequence (nCmdData will only be read at a rising edge of bExecute)
  bSequenceReady:=FALSE;
  bExecutePrepare:=TRUE;  
  bRestoreNCDataNeeded:=FALSE;
  //Check if valid nCmdDataLocal
  CASE nCmdDataLocal OF  	
    1:
    2:
    3:
    4:
    15:
    ELSE //nCmdData not valid	
      bError:=TRUE;
      nErrorId:=16#4FFF;   
  END_CASE
END_IF

//############# Prepare for homing (Read from NC and reset homed flag)
fbHomePrepare(
  En:=En,
  bExecute:=bExecutePrepare AND NOT bError, // Not needed for sequence 15 (set position only, no movement))
  bReset:=bReset,
  Axis:=Axis,
);

//############# Homing Sequences:
CASE nCmdDataLocal OF  
	
   1: // Home to low limit switch
	   CASE nHomingState OF
		  0:
		    bHomed:=Axis.Status.Homed;
            // Wait for read of velocities from NC and reset of calibration flag
	        IF fbHomePrepare.bDone AND bExecute AND NOT bSequenceReady THEN
			  bRestoreNCDataNeeded:=TRUE;
			  IF bLimitBwd THEN
                nHomingState:=1;
              ELSE
				nHomingState:=2;  //Standing on limit switch go direct to state 2 
              END_IF                                          		  
	        END_IF
		  1: // wait for reach low limit then trigger fbHomeToSwitch
		    bHomed:=FALSE;
			bSequenceReady:=FALSE;
			fbMoveVelocity.Velocity:=ABS(fbHomePrepare.fVelocityToCam);
            fbMoveVelocity.Direction:=MC_Negative_Direction;
	        bExecuteMoveVelocity:=bExecute;  // Execute MC_MoveVelocity
		    IF NOT bLimitBwd AND NOT fbMoveVelocity.Busy AND Axis.Status.NotMoving THEN //MC_MoveVelocity.Busy goes down when ramp down initiates (not ends).
			  nHomingState:=2;
		    END_IF
		  2: // Wait for fbHomeToSwitch
		    bHomed:=FALSE;
		    bSequenceReady:=FALSE;
            bExecuteMoveVelocity:=FALSE;			
            bExecuteHomeToSwitch:=TRUE;	
            fbHomeToSwitch.nSearchDirTwoardsCam:=MC_Positive_Direction;
            fbHomeToSwitch.nSearchDirOffCam:=MC_Positive_Direction;	             
	        fbHomeToSwitch.fVelocityToCamNC:=fbHomePrepare.fVelocityToCam; // High speed
  	        fbHomeToSwitch.fVelocityFromCamNC:=fbHomePrepare.fVelocityFromCam;  // Low speed              		
		    fbHomeToSwitch.bCamSensor:=NOT bLimitBwd;            	 		    
	        IF fbHomeToSwitch.bDone THEN	          
			  nHomingState:=3;
			  bExecuteFinish:=TRUE;
			  fbHomeFinish.bSofLimEnableHigh:=fbHomePrepare.bSofLimEnableHighOriginal;
			  fbHomeFinish.bSofLimEnableLow:=fbHomePrepare.bSofLimEnableLowOriginal;
	        END_IF;	
          3: // restore softlimit enable
            bHomed:=FALSE;
		    bSequenceReady:=FALSE;            		            	
	        IF fbHomeFinish.bDone THEN
			  bRestoreNCDataNeeded:=FALSE;
	          bSequenceReady:=TRUE;
			  nHomingState:=0;
			  bHomed:=Axis.Status.Homed;
	        END_IF;	 
	   END_CASE;
	   
   2: // Home to high limit switch
	   CASE nHomingState OF
		  0:
		    bHomed:=Axis.Status.Homed;
            // Wait for read of velocities from NC and reset of calibration flag
	        IF fbHomePrepare.bDone AND bExecute AND NOT bSequenceReady THEN
			  bRestoreNCDataNeeded:=TRUE;
			  IF bLimitFwd THEN
                nHomingState:=1;
              ELSE
				nHomingState:=2;  //Standing on limit switch go direct to state 2 
              END_IF                                          		  
	        END_IF
		  1: // wait for reach low limit then trigger fbHomeToSwitch
		    bHomed:=FALSE;
			bSequenceReady:=FALSE;
			fbMoveVelocity.Velocity:=ABS(fbHomePrepare.fVelocityToCam);
            fbMoveVelocity.Direction:=MC_Positive_Direction;
	        bExecuteMoveVelocity:=bExecute;  // Execute MC_MoveVelocity
		    IF NOT bLimitFwd AND NOT fbMoveVelocity.Busy AND Axis.Status.NotMoving THEN //MC_MoveVelocity.Busy goes down when ramp down initiates (not ends).
			  nHomingState:=2;
		    END_IF
		  2: // Wait for fbHomeToSwitch
		    bHomed:=FALSE;
		    bSequenceReady:=FALSE;
            bExecuteMoveVelocity:=FALSE;			
            bExecuteHomeToSwitch:=TRUE;	
            fbHomeToSwitch.nSearchDirTwoardsCam:=MC_Negative_Direction;
            fbHomeToSwitch.nSearchDirOffCam:=MC_Negative_Direction;	             
	        fbHomeToSwitch.fVelocityToCamNC:=fbHomePrepare.fVelocityToCam; // High speed
  	        fbHomeToSwitch.fVelocityFromCamNC:=fbHomePrepare.fVelocityFromCam;  // Low speed              		
		    fbHomeToSwitch.bCamSensor:=NOT bLimitFwd;            	 		    
	        IF fbHomeToSwitch.bDone THEN	          
			  nHomingState:=3;
			  bExecuteFinish:=TRUE;
			  fbHomeFinish.bSofLimEnableHigh:=fbHomePrepare.bSofLimEnableHighOriginal;
			  fbHomeFinish.bSofLimEnableLow:=fbHomePrepare.bSofLimEnableLowOriginal;
	        END_IF;	
          3: // restore softlimit enable
            bHomed:=FALSE;
		    bSequenceReady:=FALSE;            		            	
	        IF fbHomeFinish.bDone THEN
			  bRestoreNCDataNeeded:=FALSE;
	          bSequenceReady:=TRUE;
			  nHomingState:=0;
			  bHomed:=Axis.Status.Homed;
	        END_IF;	 
	   END_CASE;
	   
   3: // Home on bHomeSensor via bLimitBwd
   	   CASE nHomingState OF
		  0:
		    bHomed:=Axis.Status.Homed;
            // Wait for read of velocities from NC and reset of calibration flag
	        IF fbHomePrepare.bDone AND bExecute AND NOT bSequenceReady THEN
			  bRestoreNCDataNeeded:=TRUE;
			  IF bLimitBwd THEN
                nHomingState:=1;
              ELSE
				nHomingState:=2;  //Standing on limit switch go direct to state 2 
              END_IF                                          		  
	        END_IF
		  1: // wait for reach low limit then trigger fbHomeToSwitch
		    bHomed:=FALSE;
			bSequenceReady:=FALSE;
			fbMoveVelocity.Velocity:=ABS(fbHomePrepare.fVelocityToCam);
            fbMoveVelocity.Direction:=MC_Negative_Direction;
	        bExecuteMoveVelocity:=bExecute;  // Execute MC_MoveVelocity
		    IF NOT bLimitBwd AND NOT fbMoveVelocity.Busy AND Axis.Status.NotMoving THEN //MC_MoveVelocity.Busy goes down when ramp down initiates (not ends).
			  nHomingState:=2;
		    END_IF
		  2: // Wait for fbHomeToSwitch
		    bHomed:=FALSE;
		    bSequenceReady:=FALSE;
            bExecuteMoveVelocity:=FALSE;			
            bExecuteHomeToSwitch:=TRUE;	
            fbHomeToSwitch.nSearchDirTwoardsCam:=MC_Positive_Direction;
            fbHomeToSwitch.nSearchDirOffCam:=MC_Positive_Direction;	             
	        fbHomeToSwitch.fVelocityToCamNC:=fbHomePrepare.fVelocityToCam; // High speed
  	        fbHomeToSwitch.fVelocityFromCamNC:=fbHomePrepare.fVelocityFromCam;  // Low speed              		
		    fbHomeToSwitch.bCamSensor:=bHomeSensor;            	 		    
	        IF fbHomeToSwitch.bDone THEN	          
			  nHomingState:=3;
			  bExecuteFinish:=TRUE;
			  fbHomeFinish.bSofLimEnableHigh:=fbHomePrepare.bSofLimEnableHighOriginal;
			  fbHomeFinish.bSofLimEnableLow:=fbHomePrepare.bSofLimEnableLowOriginal;
	        END_IF;	
          3: // restore softlimit enable
            bHomed:=FALSE;
		    bSequenceReady:=FALSE;            		            	
	        IF fbHomeFinish.bDone THEN
		      bRestoreNCDataNeeded:=FALSE;
	          bSequenceReady:=TRUE;
			  nHomingState:=0;
			  bHomed:=Axis.Status.Homed;
	        END_IF;	 
	   END_CASE;
	4:  // Home on bHomeSensor via bLimitFwd	   
	   CASE nHomingState OF
		  0:
		    bHomed:=Axis.Status.Homed;
            // Wait for read of velocities from NC and reset of calibration flag
	        IF fbHomePrepare.bDone AND bExecute AND NOT bSequenceReady THEN
			  bRestoreNCDataNeeded:=TRUE;
			  IF bLimitFwd THEN
                nHomingState:=1;
              ELSE
				nHomingState:=2;  //Standing on limit switch go direct to state 2 
              END_IF                                          		  
	        END_IF
		  1: // wait for reach low limit then trigger fbHomeToSwitch
		    bHomed:=FALSE;
			bSequenceReady:=FALSE;
			fbMoveVelocity.Velocity:=ABS(fbHomePrepare.fVelocityToCam);
            fbMoveVelocity.Direction:=MC_Positive_Direction;
	        bExecuteMoveVelocity:=bExecute;  // Execute MC_MoveVelocity
		    IF NOT bLimitFwd AND NOT fbMoveVelocity.Busy AND Axis.Status.NotMoving THEN //MC_MoveVelocity.Busy goes down when ramp down initiates (not ends).
			  nHomingState:=2;
		    END_IF
		  2: // Wait for fbHomeToSwitch
		    bHomed:=FALSE;
		    bSequenceReady:=FALSE;
            bExecuteMoveVelocity:=FALSE;			
            bExecuteHomeToSwitch:=TRUE;	
            fbHomeToSwitch.nSearchDirTwoardsCam:=MC_Negative_Direction;
            fbHomeToSwitch.nSearchDirOffCam:=MC_Negative_Direction;	             
	        fbHomeToSwitch.fVelocityToCamNC:=fbHomePrepare.fVelocityToCam; // High speed
  	        fbHomeToSwitch.fVelocityFromCamNC:=fbHomePrepare.fVelocityFromCam;  // Low speed              		
		    fbHomeToSwitch.bCamSensor:=bHomeSensor;            	 		    
	        IF fbHomeToSwitch.bDone THEN	          
			  nHomingState:=3;
			  bExecuteFinish:=TRUE;
			  fbHomeFinish.bSofLimEnableHigh:=fbHomePrepare.bSofLimEnableHighOriginal;
			  fbHomeFinish.bSofLimEnableLow:=fbHomePrepare.bSofLimEnableLowOriginal;
	        END_IF;	
          3: // Restore softlimit enable
            bHomed:=FALSE;
		    bSequenceReady:=FALSE;            		            	
	        IF fbHomeFinish.bDone THEN
			  bRestoreNCDataNeeded:=FALSE;
	          bSequenceReady:=TRUE;
			  nHomingState:=0;
			  bHomed:=Axis.Status.Homed;
	        END_IF;	 
	   END_CASE;
		  	    
   15: //Set current position (simplest homing sequence)
     bExecuteHomeDirect:=bExecute;
	 bHomed:=Axis.Status.Homed;
     IF fbHomeDirect.bDone THEN  //Homing ready				
	   bExecuteHomeDirect:=FALSE;				
       bSequenceReady:=TRUE;	
     END_IF	 
	 
ELSE
  fbHomeToSwitch.bCamSensor:=FALSE;
  bHomed:=Axis.Status.Homed;
END_CASE;

// Main homing block
fbHomeToSwitch(
	bExecute:=bExecuteHomeToSwitch AND bExecute AND NOT bError AND NOT bExecuteHomeDirect AND NOT bExecuteMoveVelocity,
 	bReset:=bReset,
	fHomePosition:=fHomePosition,
	Axis:=Axis
);

// Approach limit switch (error if MC_Home is used)
fbMoveVelocity(
    Execute:= bExecuteMoveVelocity AND bExecute AND NOT bError AND NOT bExecuteHomeToSwitch AND NOT bExecuteHomeDirect,
    Axis:=Axis
);

// No sequence, just set position value (nCmdDataLocal=15). Can not run if fbHomeToSwitch is executed
fbHomeDirect(
	bExecute:=bExecuteHomeDirect AND bExecute AND NOT bError  AND NOT bExecuteHomeToSwitch AND NOT bExecuteMoveVelocity,
 	bReset:=bReset,
	fHomePosition:=fHomePosition,
	Axis:=Axis
);

 
//############# Finish homing

IF NOT bexecute AND bRestoreNCDataNeeded THEN  //If homing is aborted restore is needed
	bExecuteFinish:=TRUE;
	IF fbHomeFinish.bDone THEN
	  bExecuteFinish:=FALSE;
      bRestoreNCDataNeeded:=FALSE;	
	END_IF
END_IF

fbHomeFinish(
  En:=En,
  bExecute:=bExecuteFinish,
  bReset:=bReset,
  Axis:=Axis,
);

// Error handling
IF NOT bError THEN
  IF fbHomeToSwitch.bError THEN 
	bError:=fbHomeToSwitch.bError;
	nErrorId:=fbHomeToSwitch.nErrorId;
  ELSIF fbHomeDirect.bError THEN
	bError:=fbHomeDirect.bError;
	nErrorId:=fbHomeDirect.nErrorId;
  ELSIF fbMoveVelocity.Error THEN
	bError:=fbMoveVelocity.Error;
	nErrorId:=fbMoveVelocity.ErrorId;    		    		
  END_IF;	
END_IF

// Done and busy bit
bDone:=bSequenceReady AND bExecute;
bBusy:=NOT bSequenceReady;	 

RETURN;
```


tc_mca_std_lib/POUs/Motion/Homing/FB_HomeWriteNcVelocities.TcPOU (TcPlcObject)
------------------------------------------------------------------------------

### FB_HomeWriteNcVelocities: Declaration

```vhdl
FUNCTION_BLOCK FB_HomeWriteNcVelocities
VAR_INPUT
	En: BOOL;
	bReset: BOOL;
    bExecute: BOOL;		
	fVelocityToCam: LREAL;
	fVelocityFromCam: LREAL;	
END_VAR
VAR_IN_OUT
	Axis: AXIS_REF;
END_VAR
VAR_OUTPUT
	EnO: BOOL;	
	bBusy: BOOL;
	bDone: BOOL;
	bError: BOOL;
	nErrorId: UDINT;	
END_VAR
VAR
	fbExecuteRiseEdge: R_TRIG;
	fbWriteVelocityToCam:FB_WriteFloatParameter;
	fbWriteVelocityFromCam:FB_WriteFloatParameter;
END_VAR
```

### FB_HomeWriteNcVelocities: ST

```vhdl
En:=EnO;
IF bReset THEN
	bError:=FALSE;
	nErrorId:=0;
END_IF 

fbExecuteRiseEdge(CLK:=bExecute);

fbWriteVelocityToCam(
	bExecute:=bExecute,
	nDeviceGroup:= 16#4000,
	nIndexOffset:= 16#6,
	nData:=fVelocityToCam,
	Axis:= Axis);
	
fbWriteVelocityFromCam(
	bExecute:=bExecute,
	nDeviceGroup:= 16#4000,
	nIndexOffset:= 16#7,
	nData:=fVelocityFromCam,
	Axis:= Axis);

bBusy:=fbWriteVelocityFromCam.bBusy OR fbWriteVelocityToCam.bBusy;
bDone:=fbWriteVelocityFromCam.bDone AND fbWriteVelocityToCam.bDone AND bExecute;

bError:=fbWriteVelocityToCam.bError OR fbWriteVelocityFromCam.bError;
IF fbWriteVelocityToCam.bError THEN
  nErrorId:=fbWriteVelocityToCam.nErrorId;
ELSIF fbWriteVelocityFromCam.bError THEN
  nErrorId:=fbWriteVelocityFromCam.nErrorId;
END_IF
```


tc_mca_std_lib/POUs/Motion/Homing/FB_HomeWriteSoftLimEnable.TcPOU (TcPlcObject)
-------------------------------------------------------------------------------

### FB_HomeWriteSoftLimEnable: Declaration

```vhdl
FUNCTION_BLOCK FB_HomeWriteSoftLimEnable
VAR_INPUT
	En: BOOL;
	bReset: BOOL;
    bExecute: BOOL;		
	bSofLimEnableLow: BOOL:=TRUE;
	bSofLimEnableHigh: BOOL:=TRUE;
END_VAR
VAR_IN_OUT
	Axis: AXIS_REF;
END_VAR
VAR_OUTPUT
	EnO: BOOL;	
	bBusy: BOOL;
	bDone: BOOL;
	bError: BOOL;
	nErrorId: UDINT;	
END_VAR
VAR
	fbExecuteRiseEdge: R_TRIG;
	fbWriteSoftLimEnableLow:FB_WriteParameterInNc_v1_00;
	fbWriteSoftLimEnableHigh:FB_WriteParameterInNc_v1_00;
END_VAR
```

### FB_HomeWriteSoftLimEnable: ST

```vhdl
En:=EnO;
IF bReset THEN
	bError:=FALSE;
	nErrorId:=0;
END_IF 

fbExecuteRiseEdge(CLK:=bExecute);

fbWriteSoftLimEnableLow(
	bExecute:=bExecute,
	nDeviceGroup:= 16#5000,
	nIndexOffset:= 16#B,
	nData:=BOOL_TO_DWORD(bSofLimEnableLow),
	Axis:= Axis);
	
fbWriteSoftLimEnableHigh(
	bExecute:=bExecute,
	nDeviceGroup:= 16#5000,
	nIndexOffset:= 16#C,
	nData:=BOOL_TO_DWORD(bSofLimEnableHigh),
	Axis:= Axis);

bBusy:=fbWriteSoftLimEnableLow.bBusy OR fbWriteSoftLimEnableHigh.bBusy;
bDone:=fbWriteSoftLimEnableLow.bDone AND fbWriteSoftLimEnableHigh.bDone AND bExecute;

bError:=fbWriteSoftLimEnableHigh.bError OR fbWriteSoftLimEnableLow.bError;
IF fbWriteSoftLimEnableHigh.bError THEN
  nErrorId:=fbWriteSoftLimEnableHigh.nErrorId;
ELSIF fbWriteSoftLimEnableLow.bError THEN
  nErrorId:=fbWriteSoftLimEnableLow.nErrorId;
END_IF
```


UnitTests/Interactive.TcPOU (TcPlcObject)
-----------------------------------------

### Interactive: Declaration

```vhdl
PROGRAM Interactive
VAR
	M1: DUT_MotionStage;
	fbMotionStage: FB_MotionStage;
	nCounter: UINT;
	
	stOut: DUT_PositionState;
	fbGoOut: FB_StatePTPMove;
	bOut: BOOL;
	bGoOut: BOOL;
	stIn: DUT_PositionState;
	fbGoIn: FB_StatePTPMove;
	bIn: BOOL;
	bGoIn: BOOL;
	stUnsafe: DUT_PositionState;
	fbGoBad: FB_StatePTPMove;
	bHCF: BOOL;
	bGoHCF: BOOL;
END_VAR
```

### Interactive: ST

```vhdl
M1.bPowerSelf := TRUE;
M1.bLimitBackwardEnable := TRUE;
M1.bLimitForwardEnable := TRUE;
fbMotionStage(stMotionStage:=M1);
nCounter := nCounter + 1;

stOut.sName := 'Out';
stOut.fPosition := 100;
stOut.fDelta := 20;
stOut.fVelocity := 10;

stIn.sName := 'In';
stIn.fPosition := 0;
stIn.fDelta := 0.1;
stIn.fVelocity := 5;

stUnsafe.sName := 'HCF';
stUnsafe.fPosition := -999;
stUnsafe.fDelta := 6;
stUnsafe.fVelocity := 42;

fbGoOut(
	bExecute:=bGoOut,
	stMotionStage:=M1,
	stPositionState:=stOut,
	bMoveOk:=TRUE,
	bAtState=>bOut);
fbGoIn(
	bExecute:=bGoIn,
	stMotionStage:=M1,
	stPositionState:=stIn,
	bMoveOk:=TRUE,
	bAtState=>bIn);
fbGoBad(
	bExecute:=bGoHCF,
	stMotionStage:=M1,
	stPositionState:=stUnsafe,
	bAtState=>bHCF);
```


Version/Global_Version.TcGVL (TcPlcObject)
------------------------------------------

### Global_Version: Declaration

```vhdl
{attribute 'TcGenerated'}
// This function has been automatically generated from the project information.
VAR_GLOBAL CONSTANT
	{attribute 'const_non_replaced'}
	{attribute 'linkalways'}
	stLibVersion_lcls_twincat_motion : ST_LibVersion := (iMajor := 0, iMinor := 0, iBuild := 0, iRevision := 0, sVersion := '0.0.0');
END_VAR
```


Symbols
-------

    Constants.CompilerVersion : VERSION (4529696 64)
    Constants.CompilerVersionNumeric : DWORD (4529856 32)
    Constants.RuntimeVersion : VERSION (4529632 64)
    Constants.RuntimeVersionNumeric : DWORD (4529824 32)
    Constants.bFPUSupport : BOOL (4529792 8)
    Constants.bLittleEndian : BOOL (4529616 8)
    Constants.bSimulationMode : BOOL (4529624 8)
    Constants.nPackMode : UINT (4529776 16)
    Constants.nRegisterSize : WORD (4529760 16)
    GVL.nHomingError : UDINT (4529568 32)
    GVL_ErrorSystem.cSizeOfErrorData : UINT (4529600 16)
    Global_Variables.ADSIGRP_DEVICE_DATA : UDINT (4097664 32)
    Global_Variables.ADSIGRP_IOIMAGE_CLEARI : UDINT (4097568 32)
    Global_Variables.ADSIGRP_IOIMAGE_CLEARO : UDINT (4097600 32)
    Global_Variables.ADSIGRP_IOIMAGE_RISIZE : UDINT (4097440 32)
    Global_Variables.ADSIGRP_IOIMAGE_ROSIZE : UDINT (4097536 32)
    Global_Variables.ADSIGRP_IOIMAGE_RWIB : UDINT (4097376 32)
    Global_Variables.ADSIGRP_IOIMAGE_RWIOB : UDINT (4097632 32)
    Global_Variables.ADSIGRP_IOIMAGE_RWIX : UDINT (4097408 32)
    Global_Variables.ADSIGRP_IOIMAGE_RWOB : UDINT (4097472 32)
    Global_Variables.ADSIGRP_IOIMAGE_RWOX : UDINT (4097504 32)
    Global_Variables.ADSIGRP_SYMNAME : UDINT (4096960 32)
    Global_Variables.ADSIGRP_SYMNOTE : UDINT (4097344 32)
    Global_Variables.ADSIGRP_SYMTAB : UDINT (4096928 32)
    Global_Variables.ADSIGRP_SYMVAL : UDINT (4096992 32)
    Global_Variables.ADSIGRP_SYM_DOWNLOAD : UDINT (4097248 32)
    Global_Variables.ADSIGRP_SYM_HNDBYNAME : UDINT (4097024 32)
    Global_Variables.ADSIGRP_SYM_INFOBYNAME : UDINT (4097152 32)
    Global_Variables.ADSIGRP_SYM_INFOBYNAMEEX : UDINT (4097216 32)
    Global_Variables.ADSIGRP_SYM_RELEASEHND : UDINT (4097120 32)
    Global_Variables.ADSIGRP_SYM_UPLOAD : UDINT (4097280 32)
    Global_Variables.ADSIGRP_SYM_UPLOADINFO : UDINT (4097312 32)
    Global_Variables.ADSIGRP_SYM_VALBYHND : UDINT (4097088 32)
    Global_Variables.ADSIGRP_SYM_VALBYNAME : UDINT (4097056 32)
    Global_Variables.ADSIGRP_SYM_VERSION : UDINT (4097184 32)
    Global_Variables.ADSIOFFS_DEVDATA_ADSSTATE : UDINT (4097696 32)
    Global_Variables.ADSIOFFS_DEVDATA_DEVSTATE : UDINT (4097728 32)
    Global_Variables.ADSLOG_MSGTYPE_ERROR : DWORD (4098784 32)
    Global_Variables.ADSLOG_MSGTYPE_HINT : DWORD (4098720 32)
    Global_Variables.ADSLOG_MSGTYPE_LOG : DWORD (4098816 32)
    Global_Variables.ADSLOG_MSGTYPE_MSGBOX : DWORD (4098848 32)
    Global_Variables.ADSLOG_MSGTYPE_RESOURCE : DWORD (4098880 32)
    Global_Variables.ADSLOG_MSGTYPE_STRING : DWORD (4098912 32)
    Global_Variables.ADSLOG_MSGTYPE_WARN : DWORD (4098752 32)
    Global_Variables.ADSSTATE_CONFIG : UINT (4096832 16)
    Global_Variables.ADSSTATE_ERROR : UINT (4096768 16)
    Global_Variables.ADSSTATE_EXCEPTION : UINT (4096896 16)
    Global_Variables.ADSSTATE_IDLE : UINT (4096608 16)
    Global_Variables.ADSSTATE_INCOMPATIBLE : UINT (4096880 16)
    Global_Variables.ADSSTATE_INIT : UINT (4096640 16)
    Global_Variables.ADSSTATE_INVALID : UINT (4096592 16)
    Global_Variables.ADSSTATE_LOADCFG : UINT (4096720 16)
    Global_Variables.ADSSTATE_MAXSTATES : UINT (4096912 16)
    Global_Variables.ADSSTATE_POWERFAILURE : UINT (4096736 16)
    Global_Variables.ADSSTATE_POWERGOOD : UINT (4096752 16)
    Global_Variables.ADSSTATE_RECONFIG : UINT (4096848 16)
    Global_Variables.ADSSTATE_RESET : UINT (4096624 16)
    Global_Variables.ADSSTATE_RESUME : UINT (4096816 16)
    Global_Variables.ADSSTATE_RUN : UINT (4096672 16)
    Global_Variables.ADSSTATE_SAVECFG : UINT (4096704 16)
    Global_Variables.ADSSTATE_SHUTDOWN : UINT (4096784 16)
    Global_Variables.ADSSTATE_START : UINT (4096656 16)
    Global_Variables.ADSSTATE_STOP : UINT (4096688 16)
    Global_Variables.ADSSTATE_STOPPING : UINT (4096864 16)
    Global_Variables.ADSSTATE_SUSPEND : UINT (4096800 16)
    Global_Variables.AMSLOGGER_IGR_GENERAL : UDINT (4164544 32)
    Global_Variables.AMSLOGGER_IOF_MODE : UDINT (4164576 32)
    Global_Variables.AMSPORT_AMSLOGGER : UINT (4163280 16)
    Global_Variables.AMSPORT_EVENTLOG : UINT (4096304 16)
    Global_Variables.AMSPORT_LOGGER : UINT (4096288 16)
    Global_Variables.AMSPORT_R0_CAM : UINT (4096528 16)
    Global_Variables.AMSPORT_R0_CAMTOOL : UINT (4096544 16)
    Global_Variables.AMSPORT_R0_CNC : UINT (4096416 16)
    Global_Variables.AMSPORT_R0_IO : UINT (4096336 16)
    Global_Variables.AMSPORT_R0_ISG : UINT (4096400 16)
    Global_Variables.AMSPORT_R0_LINE : UINT (4096432 16)
    Global_Variables.AMSPORT_R0_NC : UINT (4096352 16)
    Global_Variables.AMSPORT_R0_NCSAF : UINT (4096368 16)
    Global_Variables.AMSPORT_R0_NCSVB : UINT (4096384 16)
    Global_Variables.AMSPORT_R0_PLC : UINT (4096448 16)
    Global_Variables.AMSPORT_R0_PLC_RTS1 : UINT (4096464 16)
    Global_Variables.AMSPORT_R0_PLC_RTS2 : UINT (4096480 16)
    Global_Variables.AMSPORT_R0_PLC_RTS3 : UINT (4096496 16)
    Global_Variables.AMSPORT_R0_PLC_RTS4 : UINT (4096512 16)
    Global_Variables.AMSPORT_R0_RTIME : UINT (4096320 16)
    Global_Variables.AMSPORT_R3_SCOPESERVER : UINT (4096576 16)
    Global_Variables.AMSPORT_R3_SYSSERV : UINT (4096560 16)
    Global_Variables.BOOTDATAFLAGS_PERSISTENT_INVALID : BYTE (4098976 8)
    Global_Variables.BOOTDATAFLAGS_PERSISTENT_LOADED : BYTE (4098968 8)
    Global_Variables.BOOTDATAFLAGS_RETAIN_INVALID : BYTE (4098952 8)
    Global_Variables.BOOTDATAFLAGS_RETAIN_LOADED : BYTE (4098944 8)
    Global_Variables.BOOTDATAFLAGS_RETAIN_REQUESTED : BYTE (4098960 8)
    Global_Variables.DATE_AND_TIME_SECPERDAY : DWORD (4177536 32)
    Global_Variables.DATE_AND_TIME_SECPERWEEK : DWORD (4177568 32)
    Global_Variables.DBG_OUTPUT_FILE : DWORD (4183840 32)
    Global_Variables.DBG_OUTPUT_LOG : DWORD (4183808 32)
    Global_Variables.DBG_OUTPUT_NONE : DWORD (4183776 32)
    Global_Variables.DBG_OUTPUT_VISU : DWORD (4183872 32)
    Global_Variables.DEFAULT_ADS_TIMEOUT : TIME (4099712 32)
    Global_Variables.DEFAULT_BACKLASHVALUE : LREAL (4313088 64)
    Global_Variables.DEFAULT_CSV_FIELD_DOUBLE_QUOTE : BYTE (4303568 8)
    Global_Variables.DEFAULT_CSV_FIELD_SEP : BYTE (4101272 8)
    Global_Variables.DEFAULT_CSV_RECORD_SEP_CR : BYTE (4303576 8)
    Global_Variables.DEFAULT_CSV_RECORD_SEP_LF : BYTE (4303584 8)
    Global_Variables.DEFAULT_HOME_POSITION : LREAL (4313024 64)
    Global_Variables.EMPTY_ARG_VALUE : Tc2_Utilities.T_Arg (4165184 128)
    Global_Variables.EMPTY_GUID_REGSTRING : STRING(38) (4305736 312)
    Global_Variables.EMPTY_GUID_STRING : STRING(36) (4305440 296)
    Global_Variables.EMPTY_GUID_STRUCT : GUID (4305312 128)
    Global_Variables.EMPTY_ROUTE_ENTRY : Tc2_Utilities.ST_AmsRouteEntry (4163296 1184)
    Global_Variables.FLOATREC_EXP_IS_INF : INT (4164640 16)
    Global_Variables.FLOATREC_EXP_IS_NAN : INT (4164624 16)
    Global_Variables.FLOATREC_MAX_DIGITS : INT (4164656 16)
    Global_Variables.FLOATREC_MAX_PRECISION : INT (4164672 16)
    Global_Variables.FLOATREC_MIN_PRECISION : INT (4164688 16)
    Global_Variables.FMTERR_ARGTYPEINVALID : DWORD (4164992 32)
    Global_Variables.FMTERR_ASTERISKPOSITION : DWORD (4164768 32)
    Global_Variables.FMTERR_DESTBUFFOVERFLOW : DWORD (4165088 32)
    Global_Variables.FMTERR_FLAGPOSITION : DWORD (4164864 32)
    Global_Variables.FMTERR_INSUFFICIENTARGS : DWORD (4165056 32)
    Global_Variables.FMTERR_INVALIDPOINTERINPUT : DWORD (4165120 32)
    Global_Variables.FMTERR_NOERROR : DWORD (4164704 32)
    Global_Variables.FMTERR_PERCENTSIGNPOSITION : DWORD (4164736 32)
    Global_Variables.FMTERR_PRECISIONDOTPOSITION : DWORD (4164928 32)
    Global_Variables.FMTERR_PRECISIONVALUE : DWORD (4164832 32)
    Global_Variables.FMTERR_TYPEFIELDVALUE : DWORD (4164960 32)
    Global_Variables.FMTERR_UNACCEPTEDPARAMETER : DWORD (4165024 32)
    Global_Variables.FMTERR_WIDTHPRECISIONVALPOS : DWORD (4164896 32)
    Global_Variables.FMTERR_WIDTHVALUE : DWORD (4164800 32)
    Global_Variables.FOPEN_MODEAPPEND : DWORD (4099072 32)
    Global_Variables.FOPEN_MODEBINARY : DWORD (4099136 32)
    Global_Variables.FOPEN_MODEPLUS : DWORD (4099104 32)
    Global_Variables.FOPEN_MODEREAD : DWORD (4099008 32)
    Global_Variables.FOPEN_MODETEXT : DWORD (4099168 32)
    Global_Variables.FOPEN_MODEWRITE : DWORD (4099040 32)
    Global_Variables.FORMAT_DECASC_CODES : BYTE (4165568 80)
    Global_Variables.FORMAT_HEXASC_CODES : BYTE (4165312 256)
    Global_Variables.FORMAT_MAX_ARGS : INT (4164608 16)
    Global_Variables.GLOBAL_DCF77_PULSE_SPLIT : TIME (4101280 32)
    Global_Variables.GLOBAL_DCF77_SEQUENCE_CHECK : BOOL (4101264 8)
    Global_Variables.GLOBAL_FORMAT_HASH_PREFIX_TYPE : Tc2_Utilities.E_HashPrefixTypes (4101232 16)
    Global_Variables.GLOBAL_SBCS_TABLE : Tc2_Utilities.E_SBCSType (4101248 16)
    Global_Variables.HKEY_MAX_BINARY_DATA_SIZE : UDINT (4164512 32)
    Global_Variables.IPHELPERAPI_ADAPTERSINFO : UDINT (4162944 32)
    Global_Variables.IPHELPERAPI_IPADDRBYHOSTNAME : UDINT (4162976 32)
    Global_Variables.MAX_ADAPTER_ADDRESS_LENGTH : UDINT (4162848 32)
    Global_Variables.MAX_ADAPTER_DESCRIPTION_LENGTH : UDINT (4162816 32)
    Global_Variables.MAX_ADAPTER_NAME_LENGTH : UDINT (4162784 32)
    Global_Variables.MAX_AVERAGE_MEASURES : INT (4101216 16)
    Global_Variables.MAX_LOCAL_ADAPTERS : UDINT (4163008 32)
    Global_Variables.MAX_REMOTE_PCS : INT (4163136 16)
    Global_Variables.MAX_ROUTE_ADDR_LEN : BYTE (4163160 8)
    Global_Variables.MAX_ROUTE_NAME_LEN : BYTE (4163152 8)
    Global_Variables.MAX_ROUTE_TRANSPORT : BYTE (4163272 8)
    Global_Variables.MAX_STRING_LENGTH : UDINT (4099744 32)
    Global_Variables.MIN_ROUTE_TRANSPORT : BYTE (4163264 8)
    Global_Variables.PI : LREAL (4099648 64)
    Global_Variables.ROUTE_FLAG_DYNAMIC : DWORD (4163200 32)
    Global_Variables.ROUTE_FLAG_NOOVERRIDE : DWORD (4163232 32)
    Global_Variables.ROUTE_FLAG_TEMPORARY : DWORD (4163168 32)
    Global_Variables.SYSTEMSERVICE_ADDREMOTE : UDINT (4163040 32)
    Global_Variables.SYSTEMSERVICE_CHANGENETID : UDINT (4098528 32)
    Global_Variables.SYSTEMSERVICE_CLOSEHANDLE : UDINT (4097888 32)
    Global_Variables.SYSTEMSERVICE_CREATEFILE : UDINT (4097856 32)
    Global_Variables.SYSTEMSERVICE_DELREMOTE : UDINT (4163072 32)
    Global_Variables.SYSTEMSERVICE_ENUMREMOTE : UDINT (4163104 32)
    Global_Variables.SYSTEMSERVICE_FCLOSE : UDINT (4097952 32)
    Global_Variables.SYSTEMSERVICE_FDELETE : UDINT (4098272 32)
    Global_Variables.SYSTEMSERVICE_FEOF : UDINT (4098240 32)
    Global_Variables.SYSTEMSERVICE_FFILEFIND : UDINT (4164480 32)
    Global_Variables.SYSTEMSERVICE_FGETS : UDINT (4098112 32)
    Global_Variables.SYSTEMSERVICE_FOPEN : UDINT (4097920 32)
    Global_Variables.SYSTEMSERVICE_FPRINTF : UDINT (4098208 32)
    Global_Variables.SYSTEMSERVICE_FPUTS : UDINT (4098144 32)
    Global_Variables.SYSTEMSERVICE_FREAD : UDINT (4097984 32)
    Global_Variables.SYSTEMSERVICE_FRENAME : UDINT (4098304 32)
    Global_Variables.SYSTEMSERVICE_FSCANF : UDINT (4098176 32)
    Global_Variables.SYSTEMSERVICE_FSEEK : UDINT (4098048 32)
    Global_Variables.SYSTEMSERVICE_FTELL : UDINT (4098080 32)
    Global_Variables.SYSTEMSERVICE_FWRITE : UDINT (4098016 32)
    Global_Variables.SYSTEMSERVICE_IPHELPERAPI : UDINT (4162880 32)
    Global_Variables.SYSTEMSERVICE_IPHOSTNAME : UDINT (4162912 32)
    Global_Variables.SYSTEMSERVICE_MKDIR : UDINT (4098336 32)
    Global_Variables.SYSTEMSERVICE_OPENCREATE : UDINT (4097760 32)
    Global_Variables.SYSTEMSERVICE_OPENREAD : UDINT (4097792 32)
    Global_Variables.SYSTEMSERVICE_OPENWRITE : UDINT (4097824 32)
    Global_Variables.SYSTEMSERVICE_REG_HKEYLOCALMACHINE : UDINT (4098400 32)
    Global_Variables.SYSTEMSERVICE_RMDIR : UDINT (4098368 32)
    Global_Variables.SYSTEMSERVICE_SENDEMAIL : UDINT (4098432 32)
    Global_Variables.SYSTEMSERVICE_STARTPROCESS : UDINT (4098496 32)
    Global_Variables.SYSTEMSERVICE_TIMESERVICES : UDINT (4098464 32)
    Global_Variables.SYSTEMSTATEFLAGS_BSOD : BYTE (4098984 8)
    Global_Variables.SYSTEMSTATEFLAGS_RTVIOLATION : BYTE (4098992 8)
    Global_Variables.SYSTEMTIME_DATEDELTA_OFFSET : DWORD (4165152 32)
    Global_Variables.SYSTEMTIME_DATE_AND_TIME_MAX : Tc2_Utilities.T_ULARGE_INTEGER (4172160 64)
    Global_Variables.SYSTEMTIME_DATE_AND_TIME_MAX64 : ULINT (4172480 64)
    Global_Variables.SYSTEMTIME_DATE_AND_TIME_MIN : Tc2_Utilities.T_ULARGE_INTEGER (4172096 64)
    Global_Variables.SYSTEMTIME_DATE_AND_TIME_MIN64 : ULINT (4172416 64)
    Global_Variables.SYSTEMTIME_MAX_MONTHDAYS : WORD (4171056 384)
    Global_Variables.SYSTEMTIME_MAX_YEARSDAY : WORD (4171440 448)
    Global_Variables.SYSTEMTIME_TICKSPERDAY : Tc2_Utilities.T_ULARGE_INTEGER (4172032 64)
    Global_Variables.SYSTEMTIME_TICKSPERDAY64 : ULINT (4172352 64)
    Global_Variables.SYSTEMTIME_TICKSPERMSEC : Tc2_Utilities.T_ULARGE_INTEGER (4171904 64)
    Global_Variables.SYSTEMTIME_TICKSPERMSEC64 : ULINT (4172224 64)
    Global_Variables.SYSTEMTIME_TICKSPERSEC : Tc2_Utilities.T_ULARGE_INTEGER (4171968 64)
    Global_Variables.SYSTEMTIME_TICKSPERSEC64 : ULINT (4172288 64)
    Global_Variables.TCEVENTFLAG_AUTOFMTALL : WORD (4099504 16)
    Global_Variables.TCEVENTFLAG_FMTSELF : WORD (4099440 16)
    Global_Variables.TCEVENTFLAG_LOG : WORD (4099456 16)
    Global_Variables.TCEVENTFLAG_MSGBOX : WORD (4099472 16)
    Global_Variables.TCEVENTFLAG_PRIOCLASS : WORD (4099424 16)
    Global_Variables.TCEVENTFLAG_SRCID : WORD (4099488 16)
    Global_Variables.TCEVENTSTATE_CONFIRMED : WORD (4099568 16)
    Global_Variables.TCEVENTSTATE_INVALID : WORD (4099520 16)
    Global_Variables.TCEVENTSTATE_RESET : WORD (4099552 16)
    Global_Variables.TCEVENTSTATE_RESETCON : WORD (4099584 16)
    Global_Variables.TCEVENTSTATE_SIGNALED : WORD (4099536 16)
    Global_Variables.TCEVENT_FMTPRGSIZE : INT (4099616 16)
    Global_Variables.TCEVENT_SRCNAMESIZE : INT (4099600 16)
    Global_Variables.TIMESERVICE_ADJUSTTIMETORTC : UDINT (4098656 32)
    Global_Variables.TIMESERVICE_DATEANDTIME : UDINT (4098560 32)
    Global_Variables.TIMESERVICE_RTCTIMEDIFF : UDINT (4098624 32)
    Global_Variables.TIMESERVICE_SYSTEMTIMES : UDINT (4098592 32)
    Global_Variables.TIMESERVICE_TIMEZONINFORMATION : UDINT (4098688 32)
    Global_Variables.TcMcGlobal : Tc2_MC2._TCMCGLOBAL (4306048 6976)
    Global_Variables.WEST_EUROPE_TZI : Tc2_Utilities.ST_TimeZoneInformation (4172544 864)
    Global_Variables.eWatchdogConfig : Tc2_System.E_WATCHDOG_TIME_CONFIG (4099632 16)
    Global_Variables.nWatchdogTime : BYTE (4099000 8)
    Global_Version.stLibVersion_Tc2_System : ST_LibVersion (4096000 288)
    Global_Version.stLibVersion_Tc2_Utilities : ST_LibVersion (4100928 288)
    Global_Version.stLibVersion_Tc3_Module : ST_LibVersion (4100288 288)
    Global_Version.stLibVersion_lcls_twincat_motion : ST_LibVersion (4529280 288)
    Interactive.M1 : DUT_MotionStage (4334912 11264)
    Interactive.M1.Axis.NcToPlc : NCTOPLC_AXIS_REF (4336000 2048)
    Interactive.M1.Axis.PlcToNc : PLCTONC_AXIS_REF (4334976 1024)
    Interactive.M1.bBrakeRelease : BOOL (4343960 8)
    Interactive.M1.bHardwareEnable : BOOL (4343968 8)
    Interactive.M1.bHome : BOOL (4343952 8)
    Interactive.M1.bLimitBackwardEnable : BOOL (4343944 8)
    Interactive.M1.bLimitForwardEnable : BOOL (4343936 8)
    Interactive.bGoHCF : BOOL (4514160 8)
    Interactive.bGoIn : BOOL (4514144 8)
    Interactive.bGoOut : BOOL (4514128 8)
    Interactive.bHCF : BOOL (4514152 8)
    Interactive.bIn : BOOL (4514136 8)
    Interactive.bOut : BOOL (4305304 8)
    Interactive.fbGoBad : FB_StatePTPMove (4521984 2368)
    Interactive.fbGoIn : FB_StatePTPMove (4518592 2368)
    Interactive.fbGoOut : FB_StatePTPMove (4515200 2368)
    Interactive.fbMotionStage : FB_MotionStage (4346176 167936)
    Interactive.fbMotionStage.fbDriveVirtual.MasterAxis.NcToPlc : NCTOPLC_AXIS_REF (4348800 2048)
    Interactive.fbMotionStage.fbDriveVirtual.MasterAxis.PlcToNc : PLCTONC_AXIS_REF (4347776 1024)
    Interactive.nCounter : UINT (4514112 16)
    Interactive.stIn : DUT_PositionState (4517568 1024)
    Interactive.stOut : DUT_PositionState (4514176 1024)
    Interactive.stUnsafe : DUT_PositionState (4520960 1024)
    TwinCAT_SystemInfoVarList._AppInfo : PlcAppSystemInfo (4529920 2048)
    TwinCAT_SystemInfoVarList._TaskInfo : PlcTaskSystemInfo (4531968 1024)
    TwinCAT_SystemInfoVarList._TaskOid_PlcTask : OTCID (4532992 32)
    TwinCAT_SystemInfoVarList._TaskPouOid_PlcTask : OTCID (4529888 32)
    TwinCAT_SystemInfoVarList.__PlcTask : _Implicit_Task_Info (4533056 896)

PLC Project (2): Example
========================

    Project path: /home/travis/build/pcdshub/lcls-twincat-motion/lcls-twincat-motion/Example/Example.plcproj
    TMC path:     /home/travis/build/pcdshub/lcls-twincat-motion/lcls-twincat-motion/Example/Example.tmc
    AMS ID:       
    IP Address:    (* based on AMS ID)
    Port:         852

    Source files:
        1.) /home/travis/build/pcdshub/lcls-twincat-motion/lcls-twincat-motion/Example/PlcTask.TcTTO
        2.) /home/travis/build/pcdshub/lcls-twincat-motion/lcls-twincat-motion/Example/POUs/Main.TcPOU

    POUs:
        1.) Main

PlcTask.TcTTO (TcPlcObject)
---------------------------


POUs/Main.TcPOU (TcPlcObject)
-----------------------------

### Main: Declaration

```vhdl
PROGRAM Main
VAR
	// Simulated motor that is always allowed to move
	{attribute 'pytmc' := 'pv: TST:SIM:MOT:01'}
	M1: DUT_MotionStage;
	
	// Simulated motor that is never allowed to move
	{attribute 'pytmc' := 'pv: TST:SIM:MOT:01'}
	M2: DUT_MotionStage;
	
	fbMotion1: FB_MotionStage;
	fbMotion2: FB_MotionStage;
END_VAR
```

### Main: ST

```vhdl
M1.bLimitForwardEnable := TRUE;
M1.bLimitBackwardEnable := TRUE;
M1.bHardwareEnable := TRUE;
M1.bPowerSelf := TRUE;
M1.nEnableMode := ENUM_StageEnableMode.STAGE_ENABLE_ALWAYS;
fbMotion1(stMotionStage := M1);
fbMotion2(stMotionStage := M2);
```


Symbols
-------

    Constants.CompilerVersion : VERSION (4698000 64)
    Constants.CompilerVersionNumeric : DWORD (4698144 32)
    Constants.RuntimeVersion : VERSION (4697936 64)
    Constants.RuntimeVersionNumeric : DWORD (4698112 32)
    Constants.bFPUSupport : BOOL (4698096 8)
    Constants.bLittleEndian : BOOL (4697920 8)
    Constants.bSimulationMode : BOOL (4697928 8)
    Constants.nPackMode : UINT (4698080 16)
    Constants.nRegisterSize : WORD (4698064 16)
    Global_Variables.ADSIGRP_DEVICE_DATA : UDINT (4097664 32)
    Global_Variables.ADSIGRP_IOIMAGE_CLEARI : UDINT (4097568 32)
    Global_Variables.ADSIGRP_IOIMAGE_CLEARO : UDINT (4097600 32)
    Global_Variables.ADSIGRP_IOIMAGE_RISIZE : UDINT (4097440 32)
    Global_Variables.ADSIGRP_IOIMAGE_ROSIZE : UDINT (4097536 32)
    Global_Variables.ADSIGRP_IOIMAGE_RWIB : UDINT (4097376 32)
    Global_Variables.ADSIGRP_IOIMAGE_RWIOB : UDINT (4097632 32)
    Global_Variables.ADSIGRP_IOIMAGE_RWIX : UDINT (4097408 32)
    Global_Variables.ADSIGRP_IOIMAGE_RWOB : UDINT (4097472 32)
    Global_Variables.ADSIGRP_IOIMAGE_RWOX : UDINT (4097504 32)
    Global_Variables.ADSIGRP_SYMNAME : UDINT (4096960 32)
    Global_Variables.ADSIGRP_SYMNOTE : UDINT (4097344 32)
    Global_Variables.ADSIGRP_SYMTAB : UDINT (4096928 32)
    Global_Variables.ADSIGRP_SYMVAL : UDINT (4096992 32)
    Global_Variables.ADSIGRP_SYM_DOWNLOAD : UDINT (4097248 32)
    Global_Variables.ADSIGRP_SYM_HNDBYNAME : UDINT (4097024 32)
    Global_Variables.ADSIGRP_SYM_INFOBYNAME : UDINT (4097152 32)
    Global_Variables.ADSIGRP_SYM_INFOBYNAMEEX : UDINT (4097216 32)
    Global_Variables.ADSIGRP_SYM_RELEASEHND : UDINT (4097120 32)
    Global_Variables.ADSIGRP_SYM_UPLOAD : UDINT (4097280 32)
    Global_Variables.ADSIGRP_SYM_UPLOADINFO : UDINT (4097312 32)
    Global_Variables.ADSIGRP_SYM_VALBYHND : UDINT (4097088 32)
    Global_Variables.ADSIGRP_SYM_VALBYNAME : UDINT (4097056 32)
    Global_Variables.ADSIGRP_SYM_VERSION : UDINT (4097184 32)
    Global_Variables.ADSIOFFS_DEVDATA_ADSSTATE : UDINT (4097696 32)
    Global_Variables.ADSIOFFS_DEVDATA_DEVSTATE : UDINT (4097728 32)
    Global_Variables.ADSLOG_MSGTYPE_ERROR : DWORD (4098784 32)
    Global_Variables.ADSLOG_MSGTYPE_HINT : DWORD (4098720 32)
    Global_Variables.ADSLOG_MSGTYPE_LOG : DWORD (4098816 32)
    Global_Variables.ADSLOG_MSGTYPE_MSGBOX : DWORD (4098848 32)
    Global_Variables.ADSLOG_MSGTYPE_RESOURCE : DWORD (4098880 32)
    Global_Variables.ADSLOG_MSGTYPE_STRING : DWORD (4098912 32)
    Global_Variables.ADSLOG_MSGTYPE_WARN : DWORD (4098752 32)
    Global_Variables.ADSSTATE_CONFIG : UINT (4096832 16)
    Global_Variables.ADSSTATE_ERROR : UINT (4096768 16)
    Global_Variables.ADSSTATE_EXCEPTION : UINT (4096896 16)
    Global_Variables.ADSSTATE_IDLE : UINT (4096608 16)
    Global_Variables.ADSSTATE_INCOMPATIBLE : UINT (4096880 16)
    Global_Variables.ADSSTATE_INIT : UINT (4096640 16)
    Global_Variables.ADSSTATE_INVALID : UINT (4096592 16)
    Global_Variables.ADSSTATE_LOADCFG : UINT (4096720 16)
    Global_Variables.ADSSTATE_MAXSTATES : UINT (4096912 16)
    Global_Variables.ADSSTATE_POWERFAILURE : UINT (4096736 16)
    Global_Variables.ADSSTATE_POWERGOOD : UINT (4096752 16)
    Global_Variables.ADSSTATE_RECONFIG : UINT (4096848 16)
    Global_Variables.ADSSTATE_RESET : UINT (4096624 16)
    Global_Variables.ADSSTATE_RESUME : UINT (4096816 16)
    Global_Variables.ADSSTATE_RUN : UINT (4096672 16)
    Global_Variables.ADSSTATE_SAVECFG : UINT (4096704 16)
    Global_Variables.ADSSTATE_SHUTDOWN : UINT (4096784 16)
    Global_Variables.ADSSTATE_START : UINT (4096656 16)
    Global_Variables.ADSSTATE_STOP : UINT (4096688 16)
    Global_Variables.ADSSTATE_STOPPING : UINT (4096864 16)
    Global_Variables.ADSSTATE_SUSPEND : UINT (4096800 16)
    Global_Variables.AMSLOGGER_IGR_GENERAL : UDINT (4164544 32)
    Global_Variables.AMSLOGGER_IOF_MODE : UDINT (4164576 32)
    Global_Variables.AMSPORT_AMSLOGGER : UINT (4163280 16)
    Global_Variables.AMSPORT_EVENTLOG : UINT (4096304 16)
    Global_Variables.AMSPORT_LOGGER : UINT (4096288 16)
    Global_Variables.AMSPORT_R0_CAM : UINT (4096528 16)
    Global_Variables.AMSPORT_R0_CAMTOOL : UINT (4096544 16)
    Global_Variables.AMSPORT_R0_CNC : UINT (4096416 16)
    Global_Variables.AMSPORT_R0_IO : UINT (4096336 16)
    Global_Variables.AMSPORT_R0_ISG : UINT (4096400 16)
    Global_Variables.AMSPORT_R0_LINE : UINT (4096432 16)
    Global_Variables.AMSPORT_R0_NC : UINT (4096352 16)
    Global_Variables.AMSPORT_R0_NCSAF : UINT (4096368 16)
    Global_Variables.AMSPORT_R0_NCSVB : UINT (4096384 16)
    Global_Variables.AMSPORT_R0_PLC : UINT (4096448 16)
    Global_Variables.AMSPORT_R0_PLC_RTS1 : UINT (4096464 16)
    Global_Variables.AMSPORT_R0_PLC_RTS2 : UINT (4096480 16)
    Global_Variables.AMSPORT_R0_PLC_RTS3 : UINT (4096496 16)
    Global_Variables.AMSPORT_R0_PLC_RTS4 : UINT (4096512 16)
    Global_Variables.AMSPORT_R0_RTIME : UINT (4096320 16)
    Global_Variables.AMSPORT_R3_SCOPESERVER : UINT (4096576 16)
    Global_Variables.AMSPORT_R3_SYSSERV : UINT (4096560 16)
    Global_Variables.BOOTDATAFLAGS_PERSISTENT_INVALID : BYTE (4098976 8)
    Global_Variables.BOOTDATAFLAGS_PERSISTENT_LOADED : BYTE (4098968 8)
    Global_Variables.BOOTDATAFLAGS_RETAIN_INVALID : BYTE (4098952 8)
    Global_Variables.BOOTDATAFLAGS_RETAIN_LOADED : BYTE (4098944 8)
    Global_Variables.BOOTDATAFLAGS_RETAIN_REQUESTED : BYTE (4098960 8)
    Global_Variables.DATE_AND_TIME_SECPERDAY : DWORD (4177536 32)
    Global_Variables.DATE_AND_TIME_SECPERWEEK : DWORD (4177568 32)
    Global_Variables.DBG_OUTPUT_FILE : DWORD (4183840 32)
    Global_Variables.DBG_OUTPUT_LOG : DWORD (4183808 32)
    Global_Variables.DBG_OUTPUT_NONE : DWORD (4183776 32)
    Global_Variables.DBG_OUTPUT_VISU : DWORD (4183872 32)
    Global_Variables.DEFAULT_ADS_TIMEOUT : TIME (4099712 32)
    Global_Variables.DEFAULT_BACKLASHVALUE : LREAL (4313088 64)
    Global_Variables.DEFAULT_CSV_FIELD_DOUBLE_QUOTE : BYTE (4303568 8)
    Global_Variables.DEFAULT_CSV_FIELD_SEP : BYTE (4101272 8)
    Global_Variables.DEFAULT_CSV_RECORD_SEP_CR : BYTE (4303576 8)
    Global_Variables.DEFAULT_CSV_RECORD_SEP_LF : BYTE (4303584 8)
    Global_Variables.DEFAULT_HOME_POSITION : LREAL (4313024 64)
    Global_Variables.EMPTY_ARG_VALUE : lcls_twincat_motion.Tc2_Utilities.T_Arg (4165184 128)
    Global_Variables.EMPTY_GUID_REGSTRING : STRING(38) (4305736 312)
    Global_Variables.EMPTY_GUID_STRING : STRING(36) (4305440 296)
    Global_Variables.EMPTY_GUID_STRUCT : GUID (4305312 128)
    Global_Variables.EMPTY_ROUTE_ENTRY : lcls_twincat_motion.Tc2_Utilities.ST_AmsRouteEntry (4163296 1184)
    Global_Variables.FLOATREC_EXP_IS_INF : INT (4164640 16)
    Global_Variables.FLOATREC_EXP_IS_NAN : INT (4164624 16)
    Global_Variables.FLOATREC_MAX_DIGITS : INT (4164656 16)
    Global_Variables.FLOATREC_MAX_PRECISION : INT (4164672 16)
    Global_Variables.FLOATREC_MIN_PRECISION : INT (4164688 16)
    Global_Variables.FMTERR_ARGTYPEINVALID : DWORD (4164992 32)
    Global_Variables.FMTERR_ASTERISKPOSITION : DWORD (4164768 32)
    Global_Variables.FMTERR_DESTBUFFOVERFLOW : DWORD (4165088 32)
    Global_Variables.FMTERR_FLAGPOSITION : DWORD (4164864 32)
    Global_Variables.FMTERR_INSUFFICIENTARGS : DWORD (4165056 32)
    Global_Variables.FMTERR_INVALIDPOINTERINPUT : DWORD (4165120 32)
    Global_Variables.FMTERR_NOERROR : DWORD (4164704 32)
    Global_Variables.FMTERR_PERCENTSIGNPOSITION : DWORD (4164736 32)
    Global_Variables.FMTERR_PRECISIONDOTPOSITION : DWORD (4164928 32)
    Global_Variables.FMTERR_PRECISIONVALUE : DWORD (4164832 32)
    Global_Variables.FMTERR_TYPEFIELDVALUE : DWORD (4164960 32)
    Global_Variables.FMTERR_UNACCEPTEDPARAMETER : DWORD (4165024 32)
    Global_Variables.FMTERR_WIDTHPRECISIONVALPOS : DWORD (4164896 32)
    Global_Variables.FMTERR_WIDTHVALUE : DWORD (4164800 32)
    Global_Variables.FOPEN_MODEAPPEND : DWORD (4099072 32)
    Global_Variables.FOPEN_MODEBINARY : DWORD (4099136 32)
    Global_Variables.FOPEN_MODEPLUS : DWORD (4099104 32)
    Global_Variables.FOPEN_MODEREAD : DWORD (4099008 32)
    Global_Variables.FOPEN_MODETEXT : DWORD (4099168 32)
    Global_Variables.FOPEN_MODEWRITE : DWORD (4099040 32)
    Global_Variables.FORMAT_DECASC_CODES : BYTE (4165568 80)
    Global_Variables.FORMAT_HEXASC_CODES : BYTE (4165312 256)
    Global_Variables.FORMAT_MAX_ARGS : INT (4164608 16)
    Global_Variables.GLOBAL_DCF77_PULSE_SPLIT : TIME (4101280 32)
    Global_Variables.GLOBAL_DCF77_SEQUENCE_CHECK : BOOL (4101264 8)
    Global_Variables.GLOBAL_FORMAT_HASH_PREFIX_TYPE : lcls_twincat_motion.Tc2_Utilities.E_HashPrefixTypes (4101232 16)
    Global_Variables.GLOBAL_SBCS_TABLE : lcls_twincat_motion.Tc2_Utilities.E_SBCSType (4101248 16)
    Global_Variables.HKEY_MAX_BINARY_DATA_SIZE : UDINT (4164512 32)
    Global_Variables.IPHELPERAPI_ADAPTERSINFO : UDINT (4162944 32)
    Global_Variables.IPHELPERAPI_IPADDRBYHOSTNAME : UDINT (4162976 32)
    Global_Variables.MAX_ADAPTER_ADDRESS_LENGTH : UDINT (4162848 32)
    Global_Variables.MAX_ADAPTER_DESCRIPTION_LENGTH : UDINT (4162816 32)
    Global_Variables.MAX_ADAPTER_NAME_LENGTH : UDINT (4162784 32)
    Global_Variables.MAX_AVERAGE_MEASURES : INT (4101216 16)
    Global_Variables.MAX_LOCAL_ADAPTERS : UDINT (4163008 32)
    Global_Variables.MAX_REMOTE_PCS : INT (4163136 16)
    Global_Variables.MAX_ROUTE_ADDR_LEN : BYTE (4163160 8)
    Global_Variables.MAX_ROUTE_NAME_LEN : BYTE (4163152 8)
    Global_Variables.MAX_ROUTE_TRANSPORT : BYTE (4163272 8)
    Global_Variables.MAX_STRING_LENGTH : UDINT (4099744 32)
    Global_Variables.MIN_ROUTE_TRANSPORT : BYTE (4163264 8)
    Global_Variables.PI : LREAL (4099648 64)
    Global_Variables.ROUTE_FLAG_DYNAMIC : DWORD (4163200 32)
    Global_Variables.ROUTE_FLAG_NOOVERRIDE : DWORD (4163232 32)
    Global_Variables.ROUTE_FLAG_TEMPORARY : DWORD (4163168 32)
    Global_Variables.SYSTEMSERVICE_ADDREMOTE : UDINT (4163040 32)
    Global_Variables.SYSTEMSERVICE_CHANGENETID : UDINT (4098528 32)
    Global_Variables.SYSTEMSERVICE_CLOSEHANDLE : UDINT (4097888 32)
    Global_Variables.SYSTEMSERVICE_CREATEFILE : UDINT (4097856 32)
    Global_Variables.SYSTEMSERVICE_DELREMOTE : UDINT (4163072 32)
    Global_Variables.SYSTEMSERVICE_ENUMREMOTE : UDINT (4163104 32)
    Global_Variables.SYSTEMSERVICE_FCLOSE : UDINT (4097952 32)
    Global_Variables.SYSTEMSERVICE_FDELETE : UDINT (4098272 32)
    Global_Variables.SYSTEMSERVICE_FEOF : UDINT (4098240 32)
    Global_Variables.SYSTEMSERVICE_FFILEFIND : UDINT (4164480 32)
    Global_Variables.SYSTEMSERVICE_FGETS : UDINT (4098112 32)
    Global_Variables.SYSTEMSERVICE_FOPEN : UDINT (4097920 32)
    Global_Variables.SYSTEMSERVICE_FPRINTF : UDINT (4098208 32)
    Global_Variables.SYSTEMSERVICE_FPUTS : UDINT (4098144 32)
    Global_Variables.SYSTEMSERVICE_FREAD : UDINT (4097984 32)
    Global_Variables.SYSTEMSERVICE_FRENAME : UDINT (4098304 32)
    Global_Variables.SYSTEMSERVICE_FSCANF : UDINT (4098176 32)
    Global_Variables.SYSTEMSERVICE_FSEEK : UDINT (4098048 32)
    Global_Variables.SYSTEMSERVICE_FTELL : UDINT (4098080 32)
    Global_Variables.SYSTEMSERVICE_FWRITE : UDINT (4098016 32)
    Global_Variables.SYSTEMSERVICE_IPHELPERAPI : UDINT (4162880 32)
    Global_Variables.SYSTEMSERVICE_IPHOSTNAME : UDINT (4162912 32)
    Global_Variables.SYSTEMSERVICE_MKDIR : UDINT (4098336 32)
    Global_Variables.SYSTEMSERVICE_OPENCREATE : UDINT (4097760 32)
    Global_Variables.SYSTEMSERVICE_OPENREAD : UDINT (4097792 32)
    Global_Variables.SYSTEMSERVICE_OPENWRITE : UDINT (4097824 32)
    Global_Variables.SYSTEMSERVICE_REG_HKEYLOCALMACHINE : UDINT (4098400 32)
    Global_Variables.SYSTEMSERVICE_RMDIR : UDINT (4098368 32)
    Global_Variables.SYSTEMSERVICE_SENDEMAIL : UDINT (4098432 32)
    Global_Variables.SYSTEMSERVICE_STARTPROCESS : UDINT (4098496 32)
    Global_Variables.SYSTEMSERVICE_TIMESERVICES : UDINT (4098464 32)
    Global_Variables.SYSTEMSTATEFLAGS_BSOD : BYTE (4098984 8)
    Global_Variables.SYSTEMSTATEFLAGS_RTVIOLATION : BYTE (4098992 8)
    Global_Variables.SYSTEMTIME_DATEDELTA_OFFSET : DWORD (4165152 32)
    Global_Variables.SYSTEMTIME_DATE_AND_TIME_MAX : lcls_twincat_motion.Tc2_Utilities.T_ULARGE_INTEGER (4172160 64)
    Global_Variables.SYSTEMTIME_DATE_AND_TIME_MAX64 : ULINT (4172480 64)
    Global_Variables.SYSTEMTIME_DATE_AND_TIME_MIN : lcls_twincat_motion.Tc2_Utilities.T_ULARGE_INTEGER (4172096 64)
    Global_Variables.SYSTEMTIME_DATE_AND_TIME_MIN64 : ULINT (4172416 64)
    Global_Variables.SYSTEMTIME_MAX_MONTHDAYS : WORD (4171056 384)
    Global_Variables.SYSTEMTIME_MAX_YEARSDAY : WORD (4171440 448)
    Global_Variables.SYSTEMTIME_TICKSPERDAY : lcls_twincat_motion.Tc2_Utilities.T_ULARGE_INTEGER (4172032 64)
    Global_Variables.SYSTEMTIME_TICKSPERDAY64 : ULINT (4172352 64)
    Global_Variables.SYSTEMTIME_TICKSPERMSEC : lcls_twincat_motion.Tc2_Utilities.T_ULARGE_INTEGER (4171904 64)
    Global_Variables.SYSTEMTIME_TICKSPERMSEC64 : ULINT (4172224 64)
    Global_Variables.SYSTEMTIME_TICKSPERSEC : lcls_twincat_motion.Tc2_Utilities.T_ULARGE_INTEGER (4171968 64)
    Global_Variables.SYSTEMTIME_TICKSPERSEC64 : ULINT (4172288 64)
    Global_Variables.TCEVENTFLAG_AUTOFMTALL : WORD (4099504 16)
    Global_Variables.TCEVENTFLAG_FMTSELF : WORD (4099440 16)
    Global_Variables.TCEVENTFLAG_LOG : WORD (4099456 16)
    Global_Variables.TCEVENTFLAG_MSGBOX : WORD (4099472 16)
    Global_Variables.TCEVENTFLAG_PRIOCLASS : WORD (4099424 16)
    Global_Variables.TCEVENTFLAG_SRCID : WORD (4099488 16)
    Global_Variables.TCEVENTSTATE_CONFIRMED : WORD (4099568 16)
    Global_Variables.TCEVENTSTATE_INVALID : WORD (4099520 16)
    Global_Variables.TCEVENTSTATE_RESET : WORD (4099552 16)
    Global_Variables.TCEVENTSTATE_RESETCON : WORD (4099584 16)
    Global_Variables.TCEVENTSTATE_SIGNALED : WORD (4099536 16)
    Global_Variables.TCEVENT_FMTPRGSIZE : INT (4099616 16)
    Global_Variables.TCEVENT_SRCNAMESIZE : INT (4099600 16)
    Global_Variables.TIMESERVICE_ADJUSTTIMETORTC : UDINT (4098656 32)
    Global_Variables.TIMESERVICE_DATEANDTIME : UDINT (4098560 32)
    Global_Variables.TIMESERVICE_RTCTIMEDIFF : UDINT (4098624 32)
    Global_Variables.TIMESERVICE_SYSTEMTIMES : UDINT (4098592 32)
    Global_Variables.TIMESERVICE_TIMEZONINFORMATION : UDINT (4098688 32)
    Global_Variables.TcMcGlobal : lcls_twincat_motion.Tc2_MC2._TCMCGLOBAL (4306048 6976)
    Global_Variables.WEST_EUROPE_TZI : lcls_twincat_motion.Tc2_Utilities.ST_TimeZoneInformation (4172544 864)
    Global_Variables.eWatchdogConfig : Tc2_System.E_WATCHDOG_TIME_CONFIG (4099632 16)
    Global_Variables.nWatchdogTime : BYTE (4099000 8)
    Global_Version.stLibVersion_Tc2_System : ST_LibVersion (4096000 288)
    Global_Version.stLibVersion_Tc2_Utilities : ST_LibVersion (4100928 288)
    Global_Version.stLibVersion_Tc3_Module : ST_LibVersion (4100288 288)
    Main.M1 : lcls_twincat_motion.DUT_MotionStage (4334592 11264)
    Main.M1.Axis.NcToPlc : NCTOPLC_AXIS_REF (4335680 2048)
    Main.M1.Axis.PlcToNc : PLCTONC_AXIS_REF (4334656 1024)
    Main.M1.bBrakeRelease : BOOL (4343640 8)
    Main.M1.bHardwareEnable : BOOL (4343648 8)
    Main.M1.bHome : BOOL (4343632 8)
    Main.M1.bLimitBackwardEnable : BOOL (4343624 8)
    Main.M1.bLimitForwardEnable : BOOL (4343616 8)
    Main.M2 : lcls_twincat_motion.DUT_MotionStage (4345856 11264)
    Main.M2.Axis.NcToPlc : NCTOPLC_AXIS_REF (4346944 2048)
    Main.M2.Axis.PlcToNc : PLCTONC_AXIS_REF (4345920 1024)
    Main.M2.bBrakeRelease : BOOL (4354904 8)
    Main.M2.bHardwareEnable : BOOL (4354912 8)
    Main.M2.bHome : BOOL (4354896 8)
    Main.M2.bLimitBackwardEnable : BOOL (4354888 8)
    Main.M2.bLimitForwardEnable : BOOL (4354880 8)
    Main.fbMotion1 : lcls_twincat_motion.FB_MotionStage (4357120 167936)
    Main.fbMotion1.fbDriveVirtual.MasterAxis.NcToPlc : NCTOPLC_AXIS_REF (4359744 2048)
    Main.fbMotion1.fbDriveVirtual.MasterAxis.PlcToNc : PLCTONC_AXIS_REF (4358720 1024)
    Main.fbMotion2 : lcls_twincat_motion.FB_MotionStage (4525056 167936)
    Main.fbMotion2.fbDriveVirtual.MasterAxis.NcToPlc : NCTOPLC_AXIS_REF (4527680 2048)
    Main.fbMotion2.fbDriveVirtual.MasterAxis.PlcToNc : PLCTONC_AXIS_REF (4526656 1024)
    TwinCAT_SystemInfoVarList._AppInfo : PlcAppSystemInfo (4698176 2048)
    TwinCAT_SystemInfoVarList._TaskInfo : PlcTaskSystemInfo (4700224 1024)
    TwinCAT_SystemInfoVarList._TaskOid_PlcTask : OTCID (4701280 32)
    TwinCAT_SystemInfoVarList._TaskPouOid_PlcTask : OTCID (4701248 32)
    TwinCAT_SystemInfoVarList.__PlcTask : _Implicit_Task_Info (4701312 896)

Boxes
-----

NC axes
-------

    1.) 'Test 1':
        Id = 1
        CreateSymbols = 'true'
        AxisType = 1
        OtherSettings:AllowMotionCmdToSlave = 'true'
        Enc:EncType = 1

    2.) 'Test 2':
        Id = 2
        CreateSymbols = 'true'
        AxisType = 1
        OtherSettings:AllowMotionCmdToSlave = 'true'
        Enc:EncType = 1

    3.) 'Example 1':
        Id = 3
        CreateSymbols = 'true'
        AxisType = 1
        OtherSettings:AllowMotionCmdToSlave = 'true'
        Enc:EncType = 1

    4.) 'Example 2':
        Id = 4
        CreateSymbols = 'true'
        AxisType = 1
        OtherSettings:AllowMotionCmdToSlave = 'true'
        Enc:EncType = 1

Links
-----

    1.) A ('Library Instance', 'PlcTask Inputs^Interactive.M1.Axis.NcToPlc')
          B ('TINC^NC-Task 1 SAF^Axes^Test 1', 'Outputs^ToPlc')
    2.) A ('Library Instance', 'PlcTask Outputs^Interactive.M1.Axis.PlcToNc')
          B ('TINC^NC-Task 1 SAF^Axes^Test 1', 'Inputs^FromPlc')
    3.) A ('Example Instance', 'PlcTask Inputs^Main.M1.Axis.NcToPlc')
          B ('TINC^NC-Task 1 SAF^Axes^Example 1', 'Outputs^ToPlc')
    4.) A ('Example Instance', 'PlcTask Outputs^Main.M1.Axis.PlcToNc')
          B ('TINC^NC-Task 1 SAF^Axes^Example 1', 'Inputs^FromPlc')
    5.) A ('Example Instance', 'PlcTask Inputs^Main.M2.Axis.NcToPlc')
          B ('TINC^NC-Task 1 SAF^Axes^Example 2', 'Outputs^ToPlc')
    6.) A ('Example Instance', 'PlcTask Outputs^Main.M2.Axis.PlcToNc')
          B ('TINC^NC-Task 1 SAF^Axes^Example 2', 'Inputs^FromPlc')

Pragma lint results
-------------------
```
INFO:pytmc.bin.pragmalint:Total pragmas found: 63 Total linter errors: 0
PLC Project (1): Library
========================


DUTs/DUT_MotionStage.TcDUT (TcPlcObject)
----------------------------------------

    - DUT_MotionStage: Declaration - 33 pragmas


DUTs/DUT_PositionState.TcDUT (TcPlcObject)
------------------------------------------

    - DUT_PositionState: Declaration - 6 pragmas


DUTs/ENUM_EpicsHomeCmd.TcDUT (TcPlcObject)
------------------------------------------

    - ENUM_EpicsHomeCmd: Declaration - 2 pragmas


DUTs/ENUM_EpicsMotorCmd.TcDUT (TcPlcObject)
-------------------------------------------

    - ENUM_EpicsMotorCmd: Declaration - 2 pragmas


DUTs/ENUM_StageBrakeMode.TcDUT (TcPlcObject)
--------------------------------------------

    - ENUM_StageBrakeMode: Declaration - 2 pragmas


DUTs/ENUM_StageEnableMode.TcDUT (TcPlcObject)
---------------------------------------------

    - ENUM_StageEnableMode: Declaration - 2 pragmas


POUs/Motion/FB_StatePTPMove.TcPOU (TcPlcObject)
-----------------------------------------------

    - FB_StatePTPMove: Declaration - 8 pragmas


tc_mca_std_lib/POUs/ErrorHandling/DUT_ErrorState.TcDUT (TcPlcObject)
--------------------------------------------------------------------

    - DUT_ErrorState: Declaration - 2 pragmas


tc_mca_std_lib/POUs/ErrorHandling/GVL_ErrorSystem.TcGVL (TcPlcObject)
---------------------------------------------------------------------

    - GVL_ErrorSystem: Declaration - 1 pragmas


Version/Global_Version.TcGVL (TcPlcObject)
------------------------------------------

    - Global_Version: Declaration - 3 pragmas

PLC Project (2): Example
========================


POUs/Main.TcPOU (TcPlcObject)
-----------------------------

    - Main: Declaration - 2 pragmas

```
