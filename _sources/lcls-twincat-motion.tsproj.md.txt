PLC Project (1): Library
========================

    Project root: /home/travis/build/pcdshub/lcls-twincat-motion/lcls-twincat-motion
    Project path: Library/Library.plcproj
    TMC path:     Library/Library.tmc
    AMS ID:       
    IP Address:    (* based on AMS ID)
    Port:         851

    Source files:
        1.) Library/DUTs/DUT_MotionStage.TcDUT
        2.) Library/DUTs/DUT_PositionState.TcDUT
        3.) Library/DUTs/EL5042_Status.TcDUT
        4.) Library/DUTs/ENUM_EpicsHomeCmd.TcDUT
        5.) Library/DUTs/ENUM_EpicsInOut.TcDUT
        6.) Library/DUTs/ENUM_EpicsMotorCmd.TcDUT
        7.) Library/DUTs/ENUM_MotionRequest.TcDUT
        8.) Library/DUTs/ENUM_StageBrakeMode.TcDUT
        9.) Library/DUTs/ENUM_StageEnableMode.TcDUT
        10.) Library/DUTs/DUT_MotionPneumaticActuator.TcDUT
        11.) Library/DUTs/ENUM_PnuematicActuatorPositionState.TcDUT
        12.) Library/DUTs/ST_RenishawAbsEnc.TcDUT
        13.) Library/PlcTask.TcTTO
        14.) Library/POUs/Deprecated/FB_StatePTPMove.TcPOU
        15.) Library/POUs/ImplicitChecks/CheckBounds.TcPOU
        16.) Library/POUs/ImplicitChecks/CheckDivDInt.TcPOU
        17.) Library/POUs/ImplicitChecks/CheckDivLInt.TcPOU
        18.) Library/POUs/ImplicitChecks/CheckDivLReal.TcPOU
        19.) Library/POUs/ImplicitChecks/CheckDivReal.TcPOU
        20.) Library/POUs/Motion/FB_MotionRequest.TcPOU
        21.) Library/POUs/Motion/FB_MotionStage.TcPOU
        22.) Library/POUs/Motion/FB_MotionStageSim.TcPOU
        23.) Library/POUs/Motion/FB_MotionPneumaticActuator.TcPOU
        24.) Library/POUs/Motion/Gantry/FB_GantryAutoCoupling.TcPOU
        25.) Library/POUs/Motion/Gantry/FB_GantryDiffVirtualLimitSwitch.TcPOU
        26.) Library/POUs/Motion/States/FB_EpicsInOut.TcPOU
        27.) Library/POUs/Motion/States/FB_PositionStateLock.TcPOU
        28.) Library/POUs/Motion/States/FB_PositionStateManager.TcPOU
        29.) Library/POUs/Motion/States/FB_PositionStateMove.TcPOU
        30.) Library/POUs/Motion/States/F_AtPositionState.TcPOU
        31.) Library/POUs/Motion/Utils/FB_SetEnables.TcPOU
        32.) Library/POUs/Motion/Utils/F_MotionErrorCodeLookup.TcPOU
        33.) Library/POUs/MotorTesting/FB_MicroStepCountTest.TcPOU
        34.) Library/tc_mca_std_lib/DUTs/DUT_AxisStatus_v0_01.TcDUT
        35.) Library/tc_mca_std_lib/GVLs/GVL.TcGVL
        36.) Library/tc_mca_std_lib/POUs/ChangeConfig/FB_ReadFloatParameter.TcPOU
        37.) Library/tc_mca_std_lib/POUs/ChangeConfig/FB_ReadParameterInNc_v1_00.TcPOU
        38.) Library/tc_mca_std_lib/POUs/ChangeConfig/FB_WriteFloatParameter.TcPOU
        39.) Library/tc_mca_std_lib/POUs/ChangeConfig/FB_WriteParameterInNc_v1_00.TcPOU
        40.) Library/tc_mca_std_lib/POUs/ErrorHandling/DUT_ErrorState.TcDUT
        41.) Library/tc_mca_std_lib/POUs/ErrorHandling/DUT_TerminalError.TcDUT
        42.) Library/tc_mca_std_lib/POUs/ErrorHandling/FB_ErrorList.TcPOU
        43.) Library/tc_mca_std_lib/POUs/ErrorHandling/FB_TerminalError.TcPOU
        44.) Library/tc_mca_std_lib/POUs/ErrorHandling/GVL_ErrorSystem.TcGVL
        45.) Library/tc_mca_std_lib/POUs/ErrorHandling/ST_ErrorSystem.TcDUT
        46.) Library/tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/Analog_Inputs/EL3174_0002.TcPOU
        47.) Library/tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/Analog_Inputs/EL3214.TcPOU
        48.) Library/tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/Analog_Inputs/EL3255.TcPOU
        49.) Library/tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/Analog_Inputs/FB_CalculateFrequency_3702_v0_01.TcPOU
        50.) Library/tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/Digital_Inputs/EL1008.TcPOU
        51.) Library/tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/Digital_Inputs/EL1018.TcPOU
        52.) Library/tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/Digital_Inputs/EL1808.TcPOU
        53.) Library/tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/Digital_Inputs/EL1809.TcPOU
        54.) Library/tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/Digital_Inputs/EL1819.TcPOU
        55.) Library/tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/Digital_Inputs/FB_EL1252ASM_v1_00.TcPOU
        56.) Library/tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/Digital_Outputs/EL2014.TcPOU
        57.) Library/tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/Digital_Outputs/EL2252.TcPOU
        58.) Library/tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/Digital_Outputs/EL2808.TcPOU
        59.) Library/tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/Digital_Outputs/EL2819.TcPOU
        60.) Library/tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/Digital_Outputs/External_Types/dutEL2521_Ctrl.TcDUT
        61.) Library/tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/Digital_Outputs/External_Types/dutEL2521_Status.TcDUT
        62.) Library/tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/Measuring_Terminals/EL5002.TcPOU
        63.) Library/tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/Measuring_Terminals/EL5021.TcPOU
        64.) Library/tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/Measuring_Terminals/EL5042.TcPOU
        65.) Library/tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/Measuring_Terminals/EL5101.TcPOU
        66.) Library/tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/Motion/EL7211_v1_00.TcPOU
        67.) Library/tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/Motion/EL9576_v1_00.TcPOU
        68.) Library/tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/System/EL9410.TcPOU
        69.) Library/tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/System/EL9505.TcPOU
        70.) Library/tc_mca_std_lib/POUs/Hardware/Other/EK1200.TcPOU
        71.) Library/tc_mca_std_lib/POUs/Motion/FB_DriveVirtual.TcPOU
        72.) Library/tc_mca_std_lib/POUs/Motion/FB_NcAxis.TcPOU
        73.) Library/tc_mca_std_lib/POUs/Motion/Homing/FB_HomeDirect.TcPOU
        74.) Library/tc_mca_std_lib/POUs/Motion/Homing/FB_HomeFinish.TcPOU
        75.) Library/tc_mca_std_lib/POUs/Motion/Homing/FB_HomePrepare.TcPOU
        76.) Library/tc_mca_std_lib/POUs/Motion/Homing/FB_HomeReadNcVelocities.TcPOU
        77.) Library/tc_mca_std_lib/POUs/Motion/Homing/FB_HomeReadSoftLimEnable.TcPOU
        78.) Library/tc_mca_std_lib/POUs/Motion/Homing/FB_HomeToSwitch.TcPOU
        79.) Library/tc_mca_std_lib/POUs/Motion/Homing/FB_HomeVirtual.TcPOU
        80.) Library/tc_mca_std_lib/POUs/Motion/Homing/FB_HomeWriteNcVelocities.TcPOU
        81.) Library/tc_mca_std_lib/POUs/Motion/Homing/FB_HomeWriteSoftLimEnable.TcPOU
        82.) Library/UnitTests/BasicTests.TcPOU
        83.) Library/UnitTests/Interactive.TcPOU
        84.) Library/Version/Global_Version.TcGVL

    POUs:
        1.) BasicTests
        2.) CheckBounds
        3.) CheckDivDInt
        4.) CheckDivLInt
        5.) CheckDivLReal
        6.) CheckDivReal
        7.) EK1200
        8.) EL1008
        9.) EL1018
        10.) EL1808
        11.) EL1809
        12.) EL1819
        13.) EL2014
        14.) EL2252
        15.) EL2808
        16.) EL2819
        17.) EL3174_0002
        18.) EL3214
        19.) EL3255
        20.) EL5002
        21.) EL5021
        22.) EL5042
        23.) EL5101
        24.) EL7211_v1_00
        25.) EL9410
        26.) EL9505
        27.) EL9576_v1_00
        28.) FB_CalculateFrequency_3702_v0_01
        29.) FB_DriveVirtual
        30.) FB_EL1252ASM_v1_00
        31.) FB_EpicsInOut
        32.) FB_ErrorList
        33.) FB_GantryAutoCoupling
        34.) FB_GantryDiffVirtualLimitSwitch
        35.) FB_HomeDirect
        36.) FB_HomeFinish
        37.) FB_HomePrepare
        38.) FB_HomeReadNcVelocities
        39.) FB_HomeReadSoftLimEnable
        40.) FB_HomeToSwitch
        41.) FB_HomeVirtual
        42.) FB_HomeWriteNcVelocities
        43.) FB_HomeWriteSoftLimEnable
        44.) FB_MicroStepCountTest
        45.) FB_MotionPneumaticActuator
        46.) FB_MotionRequest
        47.) FB_MotionStage
        48.) FB_MotionStageSim
        49.) FB_NcAxis
        50.) FB_PositionStateLock
        51.) FB_PositionStateManager
        52.) FB_PositionStateMove
        53.) FB_ReadFloatParameter
        54.) FB_ReadParameterInNc_v1_00
        55.) FB_SetEnables
        56.) FB_StatePTPMove
        57.) FB_TerminalError
        58.) FB_WriteFloatParameter
        59.) FB_WriteParameterInNc_v1_00
        60.) F_AtPositionState
        61.) F_MotionErrorCodeLookup
        62.) Interactive

    GVLs:
        1.) GVL
        2.) GVL_ErrorSystem
        3.) Global_Version

DUT: DUT_AxisStatus_v0_01
-------------------------

File: Library/tc_mca_std_lib/DUTs/DUT_AxisStatus_v0_01.TcDUT

```vhdl
TYPE DUT_AxisStatus_v0_01 :
STRUCT
	bEnable: BOOL;
	bReset: BOOL;
	bExecute: BOOL;
	nCommand: UINT;
	nCmdData: UINT;
	fVelocity: LREAL;
	fPosition: LREAL;
	fAcceleration: LREAL;
	fDeceleration: LREAL;
	bJogFwd: BOOL;
	bJogBwd: BOOL;
	bLimitFwd: BOOL;
	bLimitBwd: BOOL;
	fOverride: LREAL := 100;
	bHomeSensor: BOOL;
	bEnabled: BOOL;
	bError: BOOL;
	nErrorId: UDINT;
	fActVelocity: LREAL;
	fActPosition: LREAL;
	fActDiff: LREAL;
	bHomed:BOOL;
	bBusy:BOOL;
END_STRUCT
END_TYPE
```


DUT: DUT_ErrorState
-------------------

File: Library/tc_mca_std_lib/POUs/ErrorHandling/DUT_ErrorState.TcDUT

```vhdl
{attribute 'qualified_only'}
{attribute 'strict'}
TYPE DUT_ErrorState :
(
	None,
	Active,
	Inactive,
	Acknowledged
);
END_TYPE
```


DUT: DUT_MotionPneumaticActuator
--------------------------------

File: Library/DUTs/DUT_MotionPneumaticActuator.TcDUT

```vhdl
{attribute 'qualified_only'}
{attribute 'strict'}
TYPE DUT_MotionPneumaticActuator :
    // Defines the EPICS interface to actuating a pneumatic stage
STRUCT
     (* Hardware *)
    //Readbacks
    //Limit Switch
    {attribute 'pytmc' := '
     pv: PLC:bInLimitSwitch
     io: i
     field: ZNAM FALSE
     field: ONAM TRUE
     field: DESC TRUE if IN limit is reached
    '}
    i_bInLimitSwitch    :    BOOL;
    {attribute 'pytmc' := '
     pv: PLC:bOutLimitSwitch
     io: i
     field: ZNAM FALSE
     field: ONAM TRUE
     field: DESC TRUE if OUT limit is reached
    '}
    i_bOutLimitSwitch    :    BOOL;
    //Controls
    //Digital outputs
    {attribute 'pytmc' := '
    pv: bRetractDigitalOutput;
    io: i;
    field: ONAM FALSE
    field: ZNAM TRUE
    field: DESC TRUE if Retract digital output is active
    '}
    q_bRetract    :    BOOL;
    {attribute 'pytmc' := '
    pv: bInsetDigitalOutput;
    io: i;
    field: ONAM FALSE
    field: ZNAM TRUE
    field: DESC TRUE if Insert digital output is active
    '}
    q_bInsert    :    BOOL;


    //Logic and supervisory
    {attribute 'pytmc' := '
    pv: bInterlockOK;
    io: i;
    field: ZNAM FALSE
    field: ONAM TRUE
    field: DESC True if the actuator has permission to move in either direction
    '}
    bILK_OK: BOOL;
    {attribute 'pytmc' := '
    pv: bInsertEnable;
    io: i;
    field: ZNAM FALSE
    field: ONAM TRUE
    field: DESC True if the actuator had permission to be retracted
    '}
    bInsertOK    :    BOOL;
    {attribute 'pytmc' := '
    pv: bRetractEnable;
    io: i;
    field: ZNAM FALSE
    field: ONAM TRUE
    field: DESC True if the actuator had permission to be inserted
    '}
    bRetractOK    :    BOOL;

    (* Commands *)
    // Used from Epics to comand the actuator to  move
    {attribute 'pytmc' := '
    pv: CMD:IN;
    io: io;
    field: DESC Used by EPICS and internally to request Insert motion
    '}
    bInsert_SW        :    BOOL;
    {attribute 'pytmc' := '
    pv: CMD:OUT;
    io: io;
    field: DESC Used by EPICS and internally to request retract motion
    '}
    bRetract_SW    :    BOOL;

    (*Returns*)
     // TRUE if in the middle of a command
    {attribute 'pytmc' := '
     pv: bBusy
     io: i
     field: ONAM FALSE
     field: ZNAM TRUE
     field: DESC TRUE if in the middle of a command
    '}
    bBusy: BOOL;
    // TRUE if we've done a command and it has finished
    {attribute 'pytmc' := '
     pv: bDone
     io: i
     field: ONAM FALSE
     field: ZNAM TRUE
      field: DESC TRUE if command finished successfully
    '}
    bDone: BOOL;
     {attribute 'pytmc' := '
        pv: bReset
        io: io
        field: ZNAM FALSE
        field: ONAM TRUE
        field: DESC Used internally to reset errors
    '}
    bReset: BOOL;
    // TRUE if we're in an error state
    {attribute 'pytmc' := '
     pv: PLC:bError
     io: i
     field: ONAM FALSE
     field: ZNAM TRUE
     field: DESC TRUE if we're in an error state
    '}
    bError: BOOL;

     // Error code if nonzero
    {attribute 'pytmc' := '
     pv: PLC:nErrorId
     io: i
     field: DESC Error code if nonzero
    '}
    nErrorId: UDINT;
    // Message to identify the error state
    {attribute 'pytmc' := '
     pv: PLC:sErrorMessage
     io: i
     field: DESC Message to identify the error state
    '}
    sErrorMessage: STRING;
    {attribute 'pytmc' := '
    pv: nPositionState ;
    type: mbbi ;
    field: ZRST RETRACTED ;
    field: ONST INSERTED ;
    field: TWST MOVING ;
    field: THST INVALID ;
    io: i
    field: DESC Pneumatic actuator position
    '}

    eState    :    ENUM_PnuematicActuatorPositionState := ENUM_PnuematicActuatorPositionState.INVALID;

END_STRUCT
END_TYPE
```


DUT: DUT_MotionStage
--------------------

File: Library/DUTs/DUT_MotionStage.TcDUT

```vhdl
TYPE DUT_MotionStage :
    // Defines the EPICS interface to moving a motor in TwinCAT
STRUCT
    (* Hardware *)

    // PLC Axis Reference
    Axis: AXIS_REF;
    // NC Forward Limit Switch: TRUE if ok to move
    {attribute 'pytmc' := '
        pv: PLC:bLimitForwardEnable
        io: i
        field: ZNAM FALSE
        field: ONAM TRUE
        field: DESC FALSE if forward limit hit
    '}
    bLimitForwardEnable AT %I*: BOOL;
    // NC Backward Limit Switch: TRUE if ok to move
    {attribute 'pytmc' := '
        pv: PLC:bLimitBackwardEnable
        io: i
        field: ZNAM FALSE
        field: ONAM TRUE
        field: DESC FALSE if reverse limit hit
    '}
    bLimitBackwardEnable AT %I*: BOOL;
    // NO Home Switch: TRUE if at home
    {attribute 'pytmc' := '
        pv: PLC:bHome
        io: i
        field: ZNAM FALSE
        field: ONAM TRUE
        field: DESC TRUE if at homing switch
    '}
    bHome AT %I*: BOOL;
    // NC Brake Output: TRUE to release brake
    {attribute 'pytmc' := '
        pv: PLC:bBrakeRelease
        io: i
        field: ZNAM FALSE
        field: ONAM TRUE
        field: DESC TRUE if brake released
    '}
    bBrakeRelease AT %Q*: BOOL;
    // NC STO Input: TRUE if ok to move
    {attribute 'pytmc' := '
        pv: PLC:bHardwareEnable
        io: i
        field: ZNAM FALSE
        field: ONAM TRUE
        field: DESC TRUE if STO not hit
    '}
    bHardwareEnable AT %I*: BOOL;

    (* Psuedo-hardware *)

    // Forward enable EPS summary
    {attribute 'pytmc' := '
        pv: PLC:bAllForwardEnable
        io: i
        field: ZNAM FALSE
        field: ONAM TRUE
        field: DESC Summary of axis permission to move forward
    '}
    bAllForwardEnable: BOOL:=FALSE;
    // Backward enable EPS summary
    {attribute 'pytmc' := '
        pv: PLC:bAllBackwardEnable
        io: i
        field: ZNAM FALSE
        field: ONAM TRUE
        field: DESC Summary of axis permission to move backward
    '}
    bAllBackwardEnable: BOOL:=FALSE;
    // Enable EPS summary encapsulating emergency stop button and any additional motion preventive hardware
    {attribute 'pytmc' := '
        pv: PLC:bAllEnable
        io: i
        field: ZNAM FALSE
        field: ONAM TRUE
        field: DESC Summary of axis permission to have power
    '}
    bAllEnable: BOOL:=FALSE;
    // Forward virtual gantry limit switch
    {attribute 'pytmc' := '
        pv: PLC:bGantryForwardEnable
        io: i
        field: ZNAM FALSE
        field: ONAM TRUE
        field: DESC TRUE if gantry ok to move forward
    '}
    bGantryForwardEnable: BOOL:=FALSE;
    // Backward virtual gantry limit switch
    {attribute 'pytmc' := '
        pv: PLC:bGantryBackwardEnable
        io: i
        field: ZNAM FALSE
        field: ONAM TRUE
        field: DESC TRUE if gantry ok to move backward
    '}
    bGantryBackwardEnable: BOOL:=FALSE;

    (* Settings *)
    // If TRUE, we want to enable the motor independently of PMPS or other safety systems.
    {attribute 'pytmc' := '
        pv: PLC:bPowerSelf
        io: i
        field: ZNAM FALSE
        field: ONAM TRUE
        field: DESC FALSE if axis is in PMPS
    '}
    bPowerSelf: BOOL:=FALSE;
    // Determines when we automatically enable the motor
    {attribute 'pytmc' := '
        pv: PLC:nEnableMode
        io: i
        field: DESC Describes when the axis will automatically get power
    '}
    nEnableMode: ENUM_StageEnableMode:=ENUM_StageEnableMode.DURING_MOTION;
    // Determines when we automatically disengage the brake
    {attribute 'pytmc' := '
        pv: PLC:nBrakeMode
        io: i
        field: DESC Describes when the brake will be released
    '}
    nBrakeMode: ENUM_StageBrakeMode:=ENUM_StageBrakeMode.IF_ENABLED;
    // Determines our encoder homing strategy
    {attribute 'pytmc' := '
        pv: PLC:nHomingMode
        io: i
        field: DESC Describes our homing strategy
    '}
    nHomingMode: ENUM_EpicsHomeCmd:=ENUM_EpicsHomeCmd.NONE;
    // Set true to activate gantry EPS
    {attribute 'pytmc' := '
        pv: PLC:bGantryAxis
        io: i
        field: ZNAM FALSE
        field: ONAM TRUE
        field: DESC TRUE if gantry EPS active
    '}
    bGantryAxis: BOOL:=FALSE;

    // Set to gantry difference tolerance
    nGantryTol: LINT:=0;

    // Encoder count at which this axis is aligned with other axis
    nEncRef: ULINT:=0;

    (* Commands *)
    // Used internally to request enables
    {attribute 'pytmc' := '
        pv: PLC:bEnable
        io: io
        field: ZNAM FALSE
        field: ONAM TRUE
        field: DESC Used internally to request enables
    '}
    bEnable: BOOL;
    // Used internally to reset errors and other state
    {attribute 'pytmc' := '
        pv: PLC:bReset
        io: io
        field: ZNAM FALSE
        field: ONAM TRUE
        field: DESC Used internally to reset errors
    '}
    bReset: BOOL;
    // Used internally and by the IOC to start or stop a move
    {attribute 'pytmc' := '
        pv: PLC:bExecute
        io: io
        field: ZNAM FALSE
        field: ONAM TRUE
        field: DESC Used internally and by the IOC to start or stop
    '}
    bExecute: BOOL;

    (* Command Args *)
    // Used internally and by the IOC to pick what kind of move to do
    {attribute 'pytmc' := '
        pv: PLC:nCommand
        io: io
        field: DESC Used internally and by the IOC to pick move type
    '}
    nCommand: INT;
    // Used internally and by the IOC to pass additional data to some commands
    {attribute 'pytmc' := '
        pv: PLC:nCmdData
        io: io
        field: DESC Used internally and by the IOC to pass extra args
    '}
    nCmdData: INT;
    // Used internally and by the IOC to pick a destination for the move
    {attribute 'pytmc' := '
        pv: PLC:fPosition
        io: io
        field: DESC Used internally and by the IOC as the set position
    '}
    fPosition: LREAL;
    // Used internally and by the IOC to pick a move velocity
    {attribute 'pytmc' := '
        pv: PLC:fVelocity
        io: io
        field: DESC Used internally and by the IOC to set velocity
    '}
    fVelocity: LREAL;
    // Used internally and by the IOC to pick a move acceleration
    {attribute 'pytmc' := '
        pv: PLC:fAcceleration
        io: io
        field: DESC Used internally and by the IOC to set acceleration
    '}
    fAcceleration: LREAL;
    // Used internally and by the IOC to pick a move deceleration
    {attribute 'pytmc' := '
        pv: PLC:fDeceleration
        io: io
        field: DESC Used internally and by the IOC to set deceleration
    '}
    fDeceleration: LREAL;
    // Used internally and by the IOC to pick a home position
    {attribute 'pytmc' := '
        pv: PLC:fHomePosition
        io: io
        field: DESC Used internally and by the IOC to pick home position
    '}
    fHomePosition: LREAL;

    (* Info *)
    // Unique ID assigned to each axis in the NC
    {attribute 'pytmc' := '
        pv: PLC:nMotionAxisID
        io: i
        field: DESC Unique ID assigned to each axis in the NC
    '}
    nMotionAxisID: UDINT:=0;

    (* Returns *)
    // TRUE if done enabling
    {attribute 'pytmc' := '
        pv: PLC:bEnableDone
        io: i
        field: ONAM FALSE
        field: ZNAM TRUE
        field: DESC TRUE if done enabling
    '}
    bEnableDone: BOOL;
    // TRUE if in the middle of a command
    {attribute 'pytmc' := '
        pv: PLC:bBusy
        io: i
        field: ONAM FALSE
        field: ZNAM TRUE
        field: DESC TRUE if in the middle of a command
    '}
    bBusy: BOOL;
    // TRUE if we've done a command and it has finished
    {attribute 'pytmc' := '
        pv: PLC:bDone
        io: i
        field: ONAM FALSE
        field: ZNAM TRUE
        field: DESC TRUE if command finished successfully
    '}
    bDone: BOOL;
    // TRUE if we're in an error state
    {attribute 'pytmc' := '
        pv: PLC:bError
        io: i
        field: ONAM FALSE
        field: ZNAM TRUE
        field: DESC TRUE if we're in an error state
    '}
    bError: BOOL;
    // Error code if nonzero
    {attribute 'pytmc' := '
        pv: PLC:nErrorId
        io: i
        field: DESC Error code if nonzero
    '}
    nErrorId: UDINT;
    // Message to identify the error state
    {attribute 'pytmc' := '
        pv: PLC:sErrorMessage
        io: i
        field: DESC Message to identify the error state
    '}
    sErrorMessage: STRING;
    // Misc axis status information for the IOC
    stAxisStatus: DUT_AxisStatus_v0_01;
END_STRUCT
END_TYPE
```


DUT: DUT_PositionState
----------------------

File: Library/DUTs/DUT_PositionState.TcDUT

```vhdl
TYPE DUT_PositionState :
    // Defines settings and current safety status for moves to specific positions for an axis
STRUCT
    // Name as queried via the NAME PV in EPICS
    {attribute 'pytmc' := '
        pv: NAME
        io: input
        field: DESC Name of this position state
    '}
    sName: STRING := 'Invalid';

    // Position associated with this state
    {attribute 'pytmc' := '
        pv: SETPOINT
        io: io
        field: DESC Axis position associated with this state
    '}
    fPosition: LREAL;

    // Maximum allowable deviation from fPosition while at the state
    {attribute 'pytmc' := '
        pv: DELTA
        io: io
        field: DRVL 0.0
        field: DESC Max deviation from position at this state
    '}
    fDelta: LREAL;

    // Speed at which to move to this state
    {attribute 'pytmc' := '
        pv: VELO
        io: io
        field: DESC Speed at which to move to this state
    '}
    fVelocity: LREAL;

    // (optional) Acceleration to use for moves to this state
    {attribute 'pytmc' := '
        pv: ACCL
        io: io
        field: DESC Acceleration to use for moves to this state
    '}
    fAccel: LREAL;

    // (optional) Deceleration to use for moves to this state
    {attribute 'pytmc' := '
        pv: DCCL
        io: io
        field: DESC Deceleration to use for moves to this state
    '}
    fDecel: LREAL;

    // Safety parameter. This must be set to TRUE by the PLC program to allow moves to this state. This is expected to change as conditions change.
    {attribute 'pytmc' := '
        pv: MOVE_OK
        io: i
        field: ZNAM FALSE
        field: ONAM TRUE
        field: DESC TRUE if the move would be safe
    '}
    bMoveOk: BOOL;

    // Signifies to FB_PositionStateLock that this state should be immutable
    {attribute 'pytmc' := '
        pv: LOCKED
        io: i
        field: ZNAM FALSE
        field: ONAM TRUE
        field: DESC TRUE if state is immutable
    '}
    bLocked: BOOL;

    // Set this to TRUE when you make your state. This defaults to FALSE so that uninitialized states can never be moved to
    {attribute 'pytmc' := '
        pv: VALID
        io: i
        field: ZNAM FALSE
        field: ONAM TRUE
        field: DESC TRUE if this is a real state
    '}
    bValid: BOOL;
END_STRUCT
END_TYPE
```


DUT: DUT_TerminalError
----------------------

File: Library/tc_mca_std_lib/POUs/ErrorHandling/DUT_TerminalError.TcDUT

```vhdl
TYPE DUT_TerminalError :
STRUCT
	//Error system related
	iTerminalID : INT;					//ID of the terminal
	Error_ID : ULINT := 0;				//ID for the Error entry
	ErrorState : DUT_ErrorState;		//State of the error
	
	//Error related
	nDateTimeOn : ULINT;				//Date and time when the error occured. Raw data
	sDateTimeOn : STRING(24);			//Date and time when the error occured. Readable format
	nDateTimeOff : ULINT;				//Date and time when the error disapeared. Raw data
	sDateTimeOff : STRING(24);			//Date and time when the error disapeared. Readable format
	bWcState : BOOL;					//WcState variable of the terminal
	uiInfoDataState : UINT;				//InfoData.State variable of the terminal
	sErrorMessage : STRING (128);		//Error message corresponding to WcState and InfoData.State
	ErrorType : INT; 					//Error types (priorities) need to be developed
END_STRUCT
END_TYPE
```


DUT: EL5042_Status
------------------

File: Library/DUTs/EL5042_Status.TcDUT

```vhdl
TYPE EL5042_Status :
STRUCT
END_STRUCT
END_TYPE
```


DUT: ENUM_EpicsHomeCmd
----------------------

File: Library/DUTs/ENUM_EpicsHomeCmd.TcDUT

```vhdl
{attribute 'qualified_only'}
{attribute 'strict'}
TYPE ENUM_EpicsHomeCmd :
    // Defines the valid options for homing in FB_MotionStage
(
    LOW_LIMIT := 1, // Low limit switch
    HIGH_LIMIT := 2, // High limit switch
    HOME_VIA_LOW := 3, // Home switch via low switch
    HOME_VIA_HIGH := 4, // Home switch via high switch
    ABSOLUTE_SET := 15, // Set here to be fHomePosition
    NONE := -1 // Do not home, ever
);
END_TYPE
```


DUT: ENUM_EpicsInOut
--------------------

File: Library/DUTs/ENUM_EpicsInOut.TcDUT

```vhdl
{attribute 'qualified_only'}
// Example EPICS states enum for use in FB_PositionStateManager
// Remove strict attribute for easier handling
TYPE ENUM_EpicsInOut :
(
    UNKNOWN := 0, // UNKNOWN must be in slot 0 or the FB breaks
    OUT := 1, // OUT at slot 1 is a convention
    IN := 2
);
END_TYPE
```


DUT: ENUM_EpicsMotorCmd
-----------------------

File: Library/DUTs/ENUM_EpicsMotorCmd.TcDUT

```vhdl
{attribute 'qualified_only'}
{attribute 'strict'}
TYPE ENUM_EpicsMotorCmd :
    // Defines valid EPICS commands for nCommand
(
    JOG := 0,
    MOVE_VELOCITY := 1,
    MOVE_RELATIVE := 2,
    MOVE_ABSOLUTE := 3,
    MOVE_MODULO := 4,
    HOME := 10,
    GEAR := 30
);
END_TYPE
```


DUT: ENUM_MotionRequest
-----------------------

File: Library/DUTs/ENUM_MotionRequest.TcDUT

```vhdl
{attribute 'qualified_only'}
{attribute 'strict'}
TYPE ENUM_MotionRequest :
    // Defines behavior options for when FB_MotionRequest is run during an active move from another source
(
    WAIT := 0,
    INTERRUPT := 1,
    ABORT := 2
);
END_TYPE
```


DUT: ENUM_PnuematicActuatorPositionState
----------------------------------------

File: Library/DUTs/ENUM_PnuematicActuatorPositionState.TcDUT

```vhdl
{attribute 'qualified_only'}
{attribute 'strict'}
// Defines the positions for a pnuematic actuator
TYPE ENUM_PnuematicActuatorPositionState :
(
   RETRACTED    := 0, // Out limit switch is active
   INSERTED    := 1, // In limit switch is active
   MOVING    := 2, // Neither limit switches is Active
   INVALID :=3 // Invalid state
);
END_TYPE
```


DUT: ENUM_StageBrakeMode
------------------------

File: Library/DUTs/ENUM_StageBrakeMode.TcDUT

```vhdl
{attribute 'qualified_only'}
{attribute 'strict'}
TYPE ENUM_StageBrakeMode :
    // Defines when to send the brake disengage signal in FB_MotionStage
(
    IF_ENABLED, // Disengage brake when the motor is enabled
    IF_MOVING, // Disengage brake when the motor is moving
    NO_BRAKE // Do not change the brake state in FB_MotionStage
);
END_TYPE
```


DUT: ENUM_StageEnableMode
-------------------------

File: Library/DUTs/ENUM_StageEnableMode.TcDUT

```vhdl
{attribute 'qualified_only'}
{attribute 'strict'}
TYPE ENUM_StageEnableMode :
    // Define conditions when FB_MotionStage automatically sets bEnable
(
    ALWAYS, // Always set bEnable to TRUE
    NEVER,  // Only change bEnable on errors
    DURING_MOTION  // Enable before motion, disable after motion
);
END_TYPE
```


DUT: ST_ErrorSystem
-------------------

File: Library/tc_mca_std_lib/POUs/ErrorHandling/ST_ErrorSystem.TcDUT

```vhdl
TYPE ST_ErrorSystem :
STRUCT
	//Array of error data. Size = cSizeOfErrorData in the GVL
	aErrorData : ARRAY [0..GVL_ErrorSystem.cSizeOfErrorData - 1] OF DUT_TerminalError;
	lNextErrorID : ULINT := 1;					//ErrorID for the next error entry
	nNoErrors : UINT;							//Number of errors in the list
	nNoOverflows : INT := 0;					//Number of overflows. How many error entries have been lost
END_STRUCT
END_TYPE
```


DUT: ST_RenishawAbsEnc
----------------------

File: Library/DUTs/ST_RenishawAbsEnc.TcDUT

```vhdl
// Renishaw BiSS-C absolute encoder used with an EL5042
TYPE ST_RenishawAbsEnc :
STRUCT
    Count AT %I*: ULINT; // Connect to encoder "Position" input
    Status: EL5042_Status; // Status struct placeholder
    Ref: ULINT; // Encoder zero position (useful for aligned position with gantries)
END_STRUCT
END_TYPE
```


DUT: dutEL2521_Ctrl
-------------------

File: Library/tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/Digital_Outputs/External_Types/dutEL2521_Ctrl.TcDUT

```vhdl
TYPE dutEL2521_Ctrl :
STRUCT
	///The control word (CW) is located in the output process image, and is transmitted from the controller to the terminal.
	///CW.0 FREQ_SEL 0bin / 1bin  Rapid change of the base frequency (only if the ramp function is inactive):
	///0bin = Base frequency 1 (object 8001:02)
	///1bin = Base frequency 2 (object 8001:03) 
	FREQ_SEL: BOOL;
	///CW.1 RAMP_DIS 1bin Operation of the ramp function is cancelled, in spite of object 8000:06 being active; if travel distance control is active, it is interrupted by this bit 
	RAMP_DIS: BOOL;
	///CW.2 GO_COUNTER 1bin  If travel distance control is active (object 8000:0A), then a pre-set counter value is approached when the bit is set 
	GO_COUNTER: BOOL;
	///CW.5 CNT_CLR 1bin The contents of the counter is cleared or set (object 8000:0B) by this bit. 
	///Any overflow or underflow bits that might be set are also cleared by this bit. 
	///The process can be edge triggered or level triggered (object 8000:05). 
	CNT_CLR: BOOL;
END_STRUCT
END_TYPE
```


DUT: dutEL2521_Status
---------------------

File: Library/tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/Digital_Outputs/External_Types/dutEL2521_Status.TcDUT

```vhdl
TYPE dutEL2521_Status :
STRUCT
	///The status word (SW) is located in the input process image, and is transmitted from the terminal to the controller.
	///SW.0 SEL_ACK/END_COUNTER 1bin  Confirms the change of base frequency. At activated travel distance control: target counter value reached 
	SEL_ACK: BOOL;
	///SW.1 RAMP_ACTIVE 1bin Ramp is currently being followed 
	RAMP_ACTIVE: BOOL;
	///SW.2 UNDERFLOW 1bin This bit is set if the 16-bit counter underflows (0 -> 65535). It is reset when the counter drops below two thirds of its measuring range (43690 -> 43689) or immediately an overflow occurs. 
	UNDERFLOW: BOOL;
	///SW.3 OVERFLOW 1bin This bit is set if the 16-bit counter overflows (65535 -> 0). It is reset when the counter exceeds one third of its measuring range (21845 -> 21846) or immediately an underflow occurs 
	OVERFLOW: BOOL;
	///SW.4 INPUT_T 1bin Status of INPUT_T 
	INPUT_T: BOOL;
	///SW.5 INPUT_Z 1bin Status of INPUT_Z 
	INPUT_Z: BOOL;
	///SW.6 ERROR 1bin General error bit, included with overflow/underflow 
	ERROR: BOOL;
END_STRUCT
END_TYPE
```


GVL: GVL
--------

File: Library/tc_mca_std_lib/GVLs/GVL.TcGVL

```vhdl
VAR_GLOBAL
	nHomingError:UDINT:=16#14D00;
END_VAR
```


GVL: GVL_ErrorSystem
--------------------

File: Library/tc_mca_std_lib/POUs/ErrorHandling/GVL_ErrorSystem.TcGVL

```vhdl
{attribute 'qualified_only'}
VAR_GLOBAL CONSTANT
	cSizeOfErrorData : UINT := 128;
	
END_VAR
```


GVL: Global_Version
-------------------

File: Library/Version/Global_Version.TcGVL

```vhdl
{attribute 'TcGenerated'}
// This function has been automatically generated from the project information.
VAR_GLOBAL CONSTANT
    {attribute 'const_non_replaced'}
    {attribute 'linkalways'}
    stLibVersion_lcls_twincat_motion : ST_LibVersion := (iMajor := 0, iMinor := 0, iBuild := 0, iRevision := 0, sVersion := '0.0.0');
END_VAR
```


POU: BasicTests
---------------

File: Library/UnitTests/BasicTests.TcPOU

```vhdl
PROGRAM BasicTests
VAR
    Motor: DUT_MotionStage;
    fbMotion: FB_MotionStageSim;
    fbRequest: FB_MotionRequest;

    bError: BOOL;
    errState: MC_AxisStates;
END_VAR
fbRequest(stMotionStage := Motor);
fbMotion(stMotionStage := Motor);

CASE Motor.Axis.Status.MotionState OF
   MC_AXISSTATE_ERRORSTOP,
   MC_AXISSTATE_STOPPING,
   MC_AXISSTATE_HOMING,
   MC_AXISSTATE_DISCRETEMOTION,
   MC_AXISSTATE_CONTINOUSMOTION,
   MC_AXISSTATE_SYNCHRONIZEDMOTION:
        IF NOT Motor.bBrakeRelease THEN
            bError := TRUE;
            errState := Motor.Axis.Status.MotionState;
        END_IF
END_CASE

END_PROGRAM
```


POU: CheckBounds
----------------

File: Library/POUs/ImplicitChecks/CheckBounds.TcPOU

```vhdl
// Implicitly generated code : DO NOT EDIT
FUNCTION CheckBounds : DINT
VAR_INPUT
    index, lower, upper: DINT;
END_VAR
// Implicitly generated code : Only an Implementation suggestion
{noflow}
IF  index < lower THEN
    CheckBounds := lower;
ELSIF  index > upper THEN
    CheckBounds := upper;
ELSE
    CheckBounds := index;
END_IF
{flow}

END_FUNCTION
```


POU: CheckDivDInt
-----------------

File: Library/POUs/ImplicitChecks/CheckDivDInt.TcPOU

```vhdl
// Implicitly generated code : DO NOT EDIT
FUNCTION CheckDivDInt : DINT
VAR_INPUT
    divisor:DINT;
END_VAR
// Implicitly generated code : Only an Implementation suggestion
{noflow}
IF divisor = 0 THEN
    CheckDivDInt:=1;
ELSE
    CheckDivDInt:=divisor;
END_IF;
{flow}

END_FUNCTION
```


POU: CheckDivLInt
-----------------

File: Library/POUs/ImplicitChecks/CheckDivLInt.TcPOU

```vhdl
// Implicitly generated code : DO NOT EDIT
FUNCTION CheckDivLInt : LINT
VAR_INPUT
    divisor:LINT;
END_VAR
// Implicitly generated code : Only an Implementation suggestion
{noflow}
IF divisor = 0 THEN
    CheckDivLInt:=1;
ELSE
    CheckDivLInt:=divisor;
END_IF;
{flow}

END_FUNCTION
```


POU: CheckDivLReal
------------------

File: Library/POUs/ImplicitChecks/CheckDivLReal.TcPOU

```vhdl
// Implicitly generated code : DO NOT EDIT
FUNCTION CheckDivLReal : LREAL
VAR_INPUT
    divisor:LREAL;
END_VAR
// Implicitly generated code : Only an Implementation suggestion
{noflow}
IF divisor = 0 THEN
    CheckDivLReal:=1;
ELSE
    CheckDivLReal:=divisor;
END_IF;
{flow}

END_FUNCTION
```


POU: CheckDivReal
-----------------

File: Library/POUs/ImplicitChecks/CheckDivReal.TcPOU

```vhdl
// Implicitly generated code : DO NOT EDIT
FUNCTION CheckDivReal : REAL
VAR_INPUT
    divisor:REAL;
END_VAR
// Implicitly generated code : Only an Implementation suggestion
{noflow}
IF divisor = 0 THEN
    CheckDivReal:=1;
ELSE
    CheckDivReal:=divisor;
END_IF;
{flow}

END_FUNCTION
```


POU: EK1200
-----------

File: Library/tc_mca_std_lib/POUs/Hardware/Other/EK1200.TcPOU

```vhdl
FUNCTION_BLOCK EK1200
VAR_INPUT
	En: BOOL;
END_VAR
VAR_OUTPUT
	EnO: BOOL;
END_VAR
EnO:=En;

END_FUNCTION_BLOCK
```


POU: EL1008
-----------

File: Library/tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/Digital_Inputs/EL1008.TcPOU

```vhdl
///EL1008 | 8-channel digital input terminal 24 V DC, 3 ms
FUNCTION_BLOCK EL1008

VAR_INPUT
	En: BOOL;
	iTerminal_ID : INT;
	ErrorSystem : POINTER TO ST_ErrorSystem;
END_VAR

VAR_OUTPUT
	EnO: BOOL;
	bDi_1: BOOL;
	bDi_2: BOOL;
	bDi_3: BOOL;
	bDi_4: BOOL;
	bDi_5: BOOL;
	bDi_6: BOOL;
	bDi_7: BOOL;
	bDi_8: BOOL;
	bError: BOOL;
END_VAR

VAR
	Channel_1_Input AT %I*: BOOL;
	Channel_2_Input AT %I*: BOOL;
	Channel_3_Input AT %I*: BOOL;
	Channel_4_Input AT %I*: BOOL;
	Channel_5_Input AT %I*: BOOL;
	Channel_6_Input AT %I*: BOOL;
	Channel_7_Input AT %I*: BOOL;
	Channel_8_Input AT %I*: BOOL;
	WcState_WcState AT %I*: BOOL;
	InfoData_State AT %I*: UINT;
	
	//FB-s
	EL1008_Error : FB_TerminalError;
END_VAR
EnO:=En;

//Error FB instance
EL1008_Error(
	En := TRUE,
	iTerminal_ID := iTerminal_ID,
	bWcState := WcState_WcState,
	uiInfoData_State := InfoData_State,
	pErrorSystem := ErrorSystem,
	bError => bError,
);

IF En THEN
	IF bError=FALSE THEN
		bDi_1:=Channel_1_Input;
		bDi_2:=Channel_2_Input;
		bDi_3:=Channel_3_Input;
		bDi_4:=Channel_4_Input;
		bDi_5:=Channel_5_Input;
		bDi_6:=Channel_6_Input;
		bDi_7:=Channel_7_Input;
		bDi_8:=Channel_8_Input;
	ELSE
		bDi_1:=FALSE;
		bDi_2:=FALSE;
		bDi_3:=FALSE;
		bDi_4:=FALSE;
		bDi_5:=FALSE;
		bDi_6:=FALSE;
		bDi_7:=FALSE;
		bDi_8:=FALSE;
	END_IF
END_IF

END_FUNCTION_BLOCK
```


POU: EL1018
-----------

File: Library/tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/Digital_Inputs/EL1018.TcPOU

```vhdl
///EL1018 | 8-channel digital input terminal 24 V DC, 10 µs
FUNCTION_BLOCK EL1018

VAR_INPUT
	En: BOOL;
	iTerminal_ID : INT;
	ErrorSystem : POINTER TO ST_ErrorSystem;
END_VAR

VAR_OUTPUT
	EnO: BOOL;
	bDi_1: BOOL;
	bDi_2: BOOL;
	bDi_3: BOOL;
	bDi_4: BOOL;
	bDi_5: BOOL;
	bDi_6: BOOL;
	bDi_7: BOOL;
	bDi_8: BOOL;
	bError : BOOL;
END_VAR

VAR
	Channel_1_Input AT %I*: BOOL;
	Channel_2_Input AT %I*: BOOL;
	Channel_3_Input AT %I*: BOOL;
	Channel_4_Input AT %I*: BOOL;
	Channel_5_Input AT %I*: BOOL;
	Channel_6_Input AT %I*: BOOL;
	Channel_7_Input AT %I*: BOOL;
	Channel_8_Input AT %I*: BOOL;
	WcState_WcState AT %I*: BOOL;
	InfoData_State  AT %I*: UINT;
	
	//FB-s
	EL1018_Error : FB_TerminalError;
END_VAR
EnO:=En;

//Error FB instance
EL1018_Error(
	En := TRUE,
	iTerminal_ID := iTerminal_ID,
	bWcState := WcState_WcState,
	uiInfoData_State := InfoData_State,
	pErrorSystem := ErrorSystem,
	bError => bError,
);

IF En THEN
	IF bError=FALSE THEN
		bDi_1:=Channel_1_Input;
		bDi_2:=Channel_2_Input;
		bDi_3:=Channel_3_Input;
		bDi_4:=Channel_4_Input;
		bDi_5:=Channel_5_Input;
		bDi_6:=Channel_6_Input;
		bDi_7:=Channel_7_Input;
		bDi_8:=Channel_8_Input;
	ELSE
		bDi_1:=FALSE;
		bDi_2:=FALSE;
		bDi_3:=FALSE;
		bDi_4:=FALSE;
		bDi_5:=FALSE;
		bDi_6:=FALSE;
		bDi_7:=FALSE;
		bDi_8:=FALSE;
	END_IF
END_IF

END_FUNCTION_BLOCK
```


POU: EL1808
-----------

File: Library/tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/Digital_Inputs/EL1808.TcPOU

```vhdl
///EL1808 | HD EtherCAT Terminals, 8-channel digital input 24 V DC, 3 ms, 2-wire connection
FUNCTION_BLOCK EL1808

VAR_INPUT
	En: BOOL;
	iTerminal_ID : INT;
	ErrorSystem : POINTER TO ST_ErrorSystem;
END_VAR

VAR_OUTPUT
	EnO: BOOL;
	bDi_1: BOOL;
	bDi_2: BOOL;
	bDi_3: BOOL;
	bDi_4: BOOL;
	bDi_5: BOOL;
	bDi_6: BOOL;
	bDi_7: BOOL;
	bDi_8: BOOL;
	bError: BOOL;
END_VAR

VAR
	Channel_1_Input AT %I*: BOOL;
	Channel_2_Input AT %I*: BOOL;
	Channel_3_Input AT %I*: BOOL;
	Channel_4_Input AT %I*: BOOL;
	Channel_5_Input AT %I*: BOOL;
	Channel_6_Input AT %I*: BOOL;
	Channel_7_Input AT %I*: BOOL;
	Channel_8_Input AT %I*: BOOL;
	WcState_WcState AT %I*: BOOL;
	InfoData_State AT %I*: UINT;
	
	//FB-s
	EL1808_Error : FB_TerminalError;
END_VAR
EnO:=En;

//Error FB instance
EL1808_Error(
	En := TRUE,
	iTerminal_ID := iTerminal_ID,
	bWcState := WcState_WcState,
	uiInfoData_State := InfoData_State,
	pErrorSystem := ErrorSystem,
	bError => bError,
);

IF En THEN
	IF bError=FALSE THEN
		bDi_1:=Channel_1_Input;
		bDi_2:=Channel_2_Input;
		bDi_3:=Channel_3_Input;
		bDi_4:=Channel_4_Input;
		bDi_5:=Channel_5_Input;
		bDi_6:=Channel_6_Input;
		bDi_7:=Channel_7_Input;
		bDi_8:=Channel_8_Input;
	ELSE
		bDi_1:=FALSE;
		bDi_2:=FALSE;
		bDi_3:=FALSE;
		bDi_4:=FALSE;
		bDi_5:=FALSE;
		bDi_6:=FALSE;
		bDi_7:=FALSE;
		bDi_8:=FALSE;
	END_IF
END_IF

END_FUNCTION_BLOCK
```


POU: EL1809
-----------

File: Library/tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/Digital_Inputs/EL1809.TcPOU

```vhdl
///EL1809 | HD EtherCAT Terminals, 16-channel digital input 24 V DC, 3 ms
FUNCTION_BLOCK EL1809

VAR_INPUT
	En: BOOL;
	iTerminal_ID : INT;
	ErrorSystem : POINTER TO ST_ErrorSystem;
END_VAR

VAR_OUTPUT
	EnO: BOOL;
	bDi_1: BOOL;
	bDi_2: BOOL;
	bDi_3: BOOL;
	bDi_4: BOOL;
	bDi_5: BOOL;
	bDi_6: BOOL;
	bDi_7: BOOL;
	bDi_8: BOOL;
	bDi_9: BOOL;
	bDi_10: BOOL;
	bDi_11: BOOL;
	bDi_12: BOOL;
	bDi_13: BOOL;
	bDi_14: BOOL;
	bDi_15: BOOL;
	bDi_16: BOOL;
	bError: BOOL;
END_VAR

VAR
	Channel_1_Input AT %I*: BOOL;
	Channel_2_Input AT %I*: BOOL;
	Channel_3_Input AT %I*: BOOL;
	Channel_4_Input AT %I*: BOOL;
	Channel_5_Input AT %I*: BOOL;
	Channel_6_Input AT %I*: BOOL;
	Channel_7_Input AT %I*: BOOL;
	Channel_8_Input AT %I*: BOOL;
	Channel_9_Input AT %I*: BOOL;
	Channel_10_Input AT %I*: BOOL;
	Channel_11_Input AT %I*: BOOL;
	Channel_12_Input AT %I*: BOOL;
	Channel_13_Input AT %I*: BOOL;
	Channel_14_Input AT %I*: BOOL;
	Channel_15_Input AT %I*: BOOL;
	Channel_16_Input AT %I*: BOOL;
	WcState_WcState AT %I*: BOOL;
	InfoData_State AT %I*: UINT;
	
	//FB-s
	EL1809_Error : FB_TerminalError;
END_VAR
EnO:=En;

//Error FB instance
EL1809_Error(
	En := TRUE,
	iTerminal_ID := iTerminal_ID,
	bWcState := WcState_WcState,
	uiInfoData_State := InfoData_State,
	pErrorSystem := ErrorSystem,
	bError => bError,
);

IF En THEN
	IF bError=FALSE THEN
		bDi_1:=Channel_1_Input;
		bDi_2:=Channel_2_Input;
		bDi_3:=Channel_3_Input;
		bDi_4:=Channel_4_Input;
		bDi_5:=Channel_5_Input;
		bDi_6:=Channel_6_Input;
		bDi_7:=Channel_7_Input;
		bDi_8:=Channel_8_Input;
		bDi_9:=Channel_9_Input;
		bDi_10:=Channel_10_Input;
		bDi_11:=Channel_11_Input;
		bDi_12:=Channel_12_Input;
		bDi_13:=Channel_13_Input;
		bDi_14:=Channel_14_Input;
		bDi_15:=Channel_15_Input;
		bDi_16:=Channel_16_Input;
	ELSE
		bDi_1:=FALSE;
		bDi_2:=FALSE;
		bDi_3:=FALSE;
		bDi_4:=FALSE;
		bDi_5:=FALSE;
		bDi_6:=FALSE;
		bDi_7:=FALSE;
		bDi_8:=FALSE;
		bDi_9:=FALSE;
		bDi_10:=FALSE;
		bDi_11:=FALSE;
		bDi_12:=FALSE;
		bDi_13:=FALSE;
		bDi_14:=FALSE;
		bDi_15:=FALSE;
		bDi_16:=FALSE;
	END_IF
END_IF

END_FUNCTION_BLOCK
```


POU: EL1819
-----------

File: Library/tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/Digital_Inputs/EL1819.TcPOU

```vhdl
///EL1819 | HD EtherCAT Terminals, 16-channel digital input 24 V DC, 10 µs
FUNCTION_BLOCK EL1819

VAR_INPUT
	En: BOOL;
	iTerminal_ID : INT;
	ErrorSystem : POINTER TO ST_ErrorSystem;
END_VAR

VAR_OUTPUT
	EnO: BOOL;
	bDi_1: BOOL;
	bDi_2: BOOL;
	bDi_3: BOOL;
	bDi_4: BOOL;
	bDi_5: BOOL;
	bDi_6: BOOL;
	bDi_7: BOOL;
	bDi_8: BOOL;
	bDi_9: BOOL;
	bDi_10: BOOL;
	bDi_11: BOOL;
	bDi_12: BOOL;
	bDi_13: BOOL;
	bDi_14: BOOL;
	bDi_15: BOOL;
	bDi_16: BOOL;
	bError: BOOL;
END_VAR

VAR
	Channel_1_Input AT %I*: BOOL;
	Channel_2_Input AT %I*: BOOL;
	Channel_3_Input AT %I*: BOOL;
	Channel_4_Input AT %I*: BOOL;
	Channel_5_Input AT %I*: BOOL;
	Channel_6_Input AT %I*: BOOL;
	Channel_7_Input AT %I*: BOOL;
	Channel_8_Input AT %I*: BOOL;
	Channel_9_Input AT %I*: BOOL;
	Channel_10_Input AT %I*: BOOL;
	Channel_11_Input AT %I*: BOOL;
	Channel_12_Input AT %I*: BOOL;
	Channel_13_Input AT %I*: BOOL;
	Channel_14_Input AT %I*: BOOL;
	Channel_15_Input AT %I*: BOOL;
	Channel_16_Input AT %I*: BOOL;
	WcState_WcState AT %I*: BOOL;
	InfoData_State AT %I*: UINT;
	
	//FB-s
	EL1819_Error : FB_TerminalError;
END_VAR
EnO:=En;

//Error FB instance
EL1819_Error(
	En := TRUE,
	iTerminal_ID := iTerminal_ID,
	bWcState := WcState_WcState,
	uiInfoData_State := InfoData_State,
	pErrorSystem := ErrorSystem,
	bError => bError,
);

IF En THEN
	IF bError=FALSE THEN
		bDi_1:=Channel_1_Input;
		bDi_2:=Channel_2_Input;
		bDi_3:=Channel_3_Input;
		bDi_4:=Channel_4_Input;
		bDi_5:=Channel_5_Input;
		bDi_6:=Channel_6_Input;
		bDi_7:=Channel_7_Input;
		bDi_8:=Channel_8_Input;
		bDi_9:=Channel_9_Input;
		bDi_10:=Channel_10_Input;
		bDi_11:=Channel_11_Input;
		bDi_12:=Channel_12_Input;
		bDi_13:=Channel_13_Input;
		bDi_14:=Channel_14_Input;
		bDi_15:=Channel_15_Input;
		bDi_16:=Channel_16_Input;
	ELSE
		bDi_1:=FALSE;
		bDi_2:=FALSE;
		bDi_3:=FALSE;
		bDi_4:=FALSE;
		bDi_5:=FALSE;
		bDi_6:=FALSE;
		bDi_7:=FALSE;
		bDi_8:=FALSE;
		bDi_9:=FALSE;
		bDi_10:=FALSE;
		bDi_11:=FALSE;
		bDi_12:=FALSE;
		bDi_13:=FALSE;
		bDi_14:=FALSE;
		bDi_15:=FALSE;
		bDi_16:=FALSE;
	END_IF
END_IF

END_FUNCTION_BLOCK
```


POU: EL2014
-----------

File: Library/tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/Digital_Outputs/EL2014.TcPOU

```vhdl
FUNCTION_BLOCK EL2014
VAR_INPUT
	En: BOOL;
	iTerminal_ID : INT; 
	bDo_1: BOOL;
	bDo_2: BOOL;
	bDo_3: BOOL;
	bDo_4: BOOL;
	ErrorSystem : POINTER TO ST_ErrorSystem;
END_VAR

VAR_OUTPUT
	EnO : BOOL;
	bError : BOOL;
END_VAR

VAR
	Channel_1_Output AT %Q*: BOOL;
	Channel_2_Output AT %Q*: BOOL;
	Channel_3_Output AT %Q*: BOOL;
	Channel_4_Output AT %Q*: BOOL;
	WcState_WcState AT %I*: BOOL;
	InfoData_State AT %I*: UINT;
	
	//FB-s
	EL2014_Error : FB_TerminalError;
END_VAR
(*
* TODO:
* Channel diagnostic variables and device diag variables
*)

EnO:=En;

EL2014_Error(
	En := TRUE,
	iTerminal_ID := iTerminal_ID,
	bWcState := WcState_WcState,
	uiInfoData_State := InfoData_State,
	pErrorSystem := ErrorSystem,
	bError => bError,
);

IF En THEN
	IF bError=FALSE THEN
		Channel_1_Output:=bDo_1;
		Channel_2_Output:=bDo_2;
		Channel_3_Output:=bDo_3;
		Channel_4_Output:=bDo_4;
	ELSE
		Channel_1_Output:=FALSE;
		Channel_2_Output:=FALSE;
		Channel_3_Output:=FALSE;
		Channel_4_Output:=FALSE;
	END_IF
END_IF

END_FUNCTION_BLOCK
```


POU: EL2252
-----------

File: Library/tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/Digital_Outputs/EL2252.TcPOU

```vhdl
///EL2252 | XFC, 2-channel digital output terminal with time stamp, tri-state
FUNCTION_BLOCK EL2252
VAR_INPUT
	En: BOOL;
	iTerminal_ID : INT; 
	bDo_1: BOOL;
	bDo_2: BOOL;
ErrorSystem : POINTER TO ST_ErrorSystem;
END_VAR

VAR_OUTPUT
	EnO : BOOL;
	bError : BOOL;
END_VAR

VAR
	Channel_1_Output AT %Q*: BOOL;
	Channel_2_Output AT %Q*: BOOL;
	WcState_WcState AT %I*: BOOL;
	InfoData_State AT %I*: UINT;
	
	//FB-s
	EL2252_Error : FB_TerminalError;
END_VAR
(*
* TODO:
* Add the DC sync variables
*)

EL2252_Error(
	En := TRUE,
	iTerminal_ID := iTerminal_ID,
	bWcState := WcState_WcState,
	uiInfoData_State := InfoData_State,
	pErrorSystem := ErrorSystem,
	bError => bError,
);

IF En THEN
	IF bError=FALSE THEN
		Channel_1_Output:=bDo_1;
		Channel_2_Output:=bDo_2;
	ELSE
		Channel_1_Output:=FALSE;
		Channel_2_Output:=FALSE;
	END_IF
END_IF

END_FUNCTION_BLOCK
```


POU: EL2808
-----------

File: Library/tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/Digital_Outputs/EL2808.TcPOU

```vhdl
FUNCTION_BLOCK EL2808

VAR_INPUT
	En: BOOL;
	iTerminal_ID : INT; 
	bDo_1: BOOL;
	bDo_2: BOOL;
	bDo_3: BOOL;
	bDo_4: BOOL;
	bDo_5: BOOL;
	bDo_6: BOOL;
	bDo_7: BOOL;
	bDo_8: BOOL;
	ErrorSystem : POINTER TO ST_ErrorSystem;
END_VAR

VAR_OUTPUT
	EnO : BOOL;
	bError : BOOL;
END_VAR

VAR
	Channel_1_Output AT %Q*: BOOL;
	Channel_2_Output AT %Q*: BOOL;
	Channel_3_Output AT %Q*: BOOL;
	Channel_4_Output AT %Q*: BOOL;
	Channel_5_Output AT %Q*: BOOL;
	Channel_6_Output AT %Q*: BOOL;
	Channel_7_Output AT %Q*: BOOL;
	Channel_8_Output AT %Q*: BOOL;
	WcState_WcState AT %I*: BOOL;
	InfoData_State AT %I*: UINT;
	
	//FB-s
	EL2808_Error : FB_TerminalError;
END_VAR
EnO:=En;

EL2808_Error(
	En := TRUE,
	iTerminal_ID := iTerminal_ID,
	bWcState := WcState_WcState,
	uiInfoData_State := InfoData_State,
	pErrorSystem := ErrorSystem,
	bError => bError,
);

IF En THEN
	IF bError=FALSE THEN
		Channel_1_Output:=bDo_1;
		Channel_2_Output:=bDo_2;
		Channel_3_Output:=bDo_3;
		Channel_4_Output:=bDo_4;
		Channel_5_Output:=bDo_5;
		Channel_6_Output:=bDo_6;
		Channel_7_Output:=bDo_7;
		Channel_8_Output:=bDo_8;
	ELSE
		Channel_1_Output:=FALSE;
		Channel_2_Output:=FALSE;
		Channel_3_Output:=FALSE;
		Channel_4_Output:=FALSE;
		Channel_5_Output:=FALSE;
		Channel_6_Output:=FALSE;
		Channel_7_Output:=FALSE;
		Channel_8_Output:=FALSE;
	END_IF
END_IF

END_FUNCTION_BLOCK
```


POU: EL2819
-----------

File: Library/tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/Digital_Outputs/EL2819.TcPOU

```vhdl
FUNCTION_BLOCK EL2819
VAR_INPUT
	En: BOOL;
	iTerminal_ID : INT; 
	bDo_1: BOOL;
	bDo_2: BOOL;
	bDo_3: BOOL;
	bDo_4: BOOL;
	bDo_5: BOOL;
	bDo_6: BOOL;
	bDo_7: BOOL;
	bDo_8: BOOL;
	bDo_9: BOOL;
	bDo_10: BOOL;
	bDo_11: BOOL;
	bDo_12: BOOL;
	bDo_13: BOOL;
	bDo_14: BOOL;
	bDo_15: BOOL;
	bDo_16: BOOL;
	ErrorSystem : POINTER TO ST_ErrorSystem;
END_VAR

VAR_OUTPUT
	EnO : BOOL;
	bError : BOOL;
END_VAR

VAR
	Channel_1_Output AT %Q*: BOOL;
	Channel_2_Output AT %Q*: BOOL;
	Channel_3_Output AT %Q*: BOOL;
	Channel_4_Output AT %Q*: BOOL;
	Channel_5_Output AT %Q*: BOOL;
	Channel_6_Output AT %Q*: BOOL;
	Channel_7_Output AT %Q*: BOOL;
	Channel_8_Output AT %Q*: BOOL;
	Channel_9_Output AT %Q*: BOOL;
	Channel_10_Output AT %Q*: BOOL;
	Channel_11_Output AT %Q*: BOOL;
	Channel_12_Output AT %Q*: BOOL;
	Channel_13_Output AT %Q*: BOOL;
	Channel_14_Output AT %Q*: BOOL;
	Channel_15_Output AT %Q*: BOOL;
	Channel_16_Output AT %Q*: BOOL;
	
	WcState_WcState AT %I*: BOOL;
	InfoData_State AT %I*: UINT;
	
	//FB-s
	EL2819_Error : FB_TerminalError;
END_VAR
(*
* TODO:
* Channel diagnostic variables and device diag variables
*)

EnO:=En;

EL2819_Error(
	En := TRUE,
	iTerminal_ID := iTerminal_ID,
	bWcState := WcState_WcState,
	uiInfoData_State := InfoData_State,
	pErrorSystem := ErrorSystem,
	bError => bError,
);

IF En THEN
	IF bError=FALSE THEN
		Channel_1_Output:=bDo_1;
		Channel_2_Output:=bDo_2;
		Channel_3_Output:=bDo_3;
		Channel_4_Output:=bDo_4;
		Channel_5_Output:=bDo_5;
		Channel_6_Output:=bDo_6;
		Channel_7_Output:=bDo_7;
		Channel_8_Output:=bDo_8;
		Channel_9_Output:=bDo_9;
		Channel_10_Output:=bDo_10;
		Channel_11_Output:=bDo_11;
		Channel_12_Output:=bDo_12;
		Channel_13_Output:=bDo_13;
		Channel_14_Output:=bDo_14;
		Channel_15_Output:=bDo_15;
		Channel_16_Output:=bDo_16;
	ELSE
		Channel_1_Output:=FALSE;
		Channel_2_Output:=FALSE;
		Channel_3_Output:=FALSE;
		Channel_4_Output:=FALSE;
		Channel_5_Output:=FALSE;
		Channel_6_Output:=FALSE;
		Channel_7_Output:=FALSE;
		Channel_8_Output:=FALSE;
		Channel_9_Output:=FALSE;
		Channel_10_Output:=FALSE;
		Channel_11_Output:=FALSE;
		Channel_12_Output:=FALSE;
		Channel_13_Output:=FALSE;
		Channel_14_Output:=FALSE;
		Channel_15_Output:=FALSE;
		Channel_16_Output:=FALSE;
	END_IF
END_IF

END_FUNCTION_BLOCK
```


POU: EL3174_0002
----------------

File: Library/tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/Analog_Inputs/EL3174_0002.TcPOU

```vhdl
//EL3174-0002 | 4-channel analog input, -10/0...+10V, -20/0/+4...20mA, 16 bit, differential
FUNCTION_BLOCK EL3174_0002

VAR_INPUT
	En: BOOL;
	iTerminal_ID : INT;
	ErrorSystem : POINTER TO ST_ErrorSystem;
END_VAR
	
VAR_OUTPUT
	EnO: BOOL;
	iAi_Ch1_Value : INT;
	iAi_Ch2_Value : INT;
	iAi_Ch3_Value : INT;
	iAi_Ch4_Value : INT;
	bError: BOOL;
END_VAR

VAR
	//Channels
	AI_Std_Ch_1_Status	AT %I* : WORD;
	AI_Std_Ch_1_Value 	AT %I* : INT;
	AI_Std_Ch_2_Status 	AT %I* : WORD;
	AI_Std_Ch_2_Value 	AT %I* : INT;
	AI_Std_Ch_3_Status 	AT %I* : WORD;
	AI_Std_Ch_3_Value 	AT %I* : INT;
	AI_Std_Ch_4_Status 	AT %I* : WORD;
	AI_Std_Ch_4_Value 	AT %I* : INT;
	
	//Terminal status
	WcState_WcState AT %I*: BOOL;
	InfoData_State AT %I*: UINT;
	
	//FB-s
	EL3174_0002_Error : FB_TerminalError;
END_VAR
(*
* TODO:
* Status words of the channels
*)

EnO := En;

//Error FB instance
EL3174_0002_Error(
	En := TRUE,
	iTerminal_ID := iTerminal_ID,
	bWcState := WcState_WcState,
	uiInfoData_State := InfoData_State,
	pErrorSystem := ErrorSystem,
	bError => bError,
);

IF En THEN
	IF bError = FALSE THEN
		iAi_Ch1_Value := AI_Std_Ch_1_Value;
		iAi_Ch2_Value := AI_Std_Ch_2_Value;
		iAi_Ch3_Value := AI_Std_Ch_3_Value;
		iAi_Ch4_Value := AI_Std_Ch_4_Value;
	ELSE
		iAi_Ch1_Value := 0;
		iAi_Ch2_Value := 0;
		iAi_Ch3_Value := 0;
		iAi_Ch4_Value := 0;
	END_IF
END_IF

END_FUNCTION_BLOCK
```


POU: EL3214
-----------

File: Library/tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/Analog_Inputs/EL3214.TcPOU

```vhdl
//EL3214 | 4-channel analog input terminal, PT100 (RTD)
FUNCTION_BLOCK EL3214

VAR_INPUT
	En: BOOL;
	iTerminal_ID : INT;
	ErrorSystem : POINTER TO ST_ErrorSystem;
END_VAR

VAR_OUTPUT
	EnO: BOOL;
	iAi_Ch1_Value : INT;
	iAi_Ch2_Value : INT;
	iAi_Ch3_Value : INT;
	iAi_Ch4_Value : INT;
	bError: BOOL;
END_VAR

VAR
	//Channels
	AI_RTD_Ch_1_Status	AT %I* : WORD;
	AI_RTD_Ch_1_Value 	AT %I* : INT;
	AI_RTD_Ch_2_Status 	AT %I* : WORD;
	AI_RTD_Ch_2_Value 	AT %I* : INT;
	AI_RTD_Ch_3_Status 	AT %I* : WORD;
	AI_RTD_Ch_3_Value 	AT %I* : INT;
	AI_RTD_Ch_4_Status 	AT %I* : WORD;
	AI_RTD_Ch_4_Value 	AT %I* : INT;
	
	//Terminal status
	WcState_WcState AT %I*: BOOL;
	InfoData_State AT %I*: UINT;
	
	//FB-s
	EL3214_Error : FB_TerminalError;
END_VAR
(*
* TODO:
* Status words of the channels
*)

EnO := En;

//Error FB instance
EL3214_Error(
	En := TRUE,
	iTerminal_ID := iTerminal_ID,
	bWcState := WcState_WcState,
	uiInfoData_State := InfoData_State,
	pErrorSystem := ErrorSystem,
	bError => bError,
);

IF En THEN
	IF bError = FALSE THEN
		iAi_Ch1_Value := AI_RTD_Ch_1_Value;
		iAi_Ch2_Value := AI_RTD_Ch_2_Value;
		iAi_Ch3_Value := AI_RTD_Ch_3_Value;
		iAi_Ch4_Value := AI_RTD_Ch_4_Value;
	ELSE
		iAi_Ch1_Value := 0;
		iAi_Ch2_Value := 0;
		iAi_Ch3_Value := 0;
		iAi_Ch4_Value := 0;
	END_IF
END_IF

END_FUNCTION_BLOCK
```


POU: EL3255
-----------

File: Library/tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/Analog_Inputs/EL3255.TcPOU

```vhdl
//EL3255 | 5-channel potentiometer measurement with sensor supply
FUNCTION_BLOCK EL3255

VAR_INPUT
	En: BOOL;
	iTerminal_ID : INT;
	ErrorSystem : POINTER TO ST_ErrorSystem;
END_VAR

VAR_OUTPUT
	EnO : BOOL;	
	Ch1_Value : INT;
	Ch2_Value : INT;
	Ch3_Value : INT;
	Ch4_Value : INT;
	Ch5_Value : INT;
	bError : BOOL;
END_VAR

VAR
	AI_Std_Ch1_Value AT %I* : INT;
	AI_Std_Ch2_Value AT %I* : INT;
	AI_Std_Ch3_Value AT %I* : INT;
	AI_Std_Ch4_Value AT %I* : INT;
	AI_Std_Ch5_Value AT %I* : INT;
	WcState_WcState AT %I*: BOOL;
	InfoData_State AT %I*: UINT;
	
	//FB-s
	EL3255_Error : FB_TerminalError;
END_VAR
(*
* TODO:
* Channel Status words
*)

EnO:=En;

//Error FB instance
EL3255_Error(
	En := TRUE,
	iTerminal_ID := iTerminal_ID,
	bWcState := WcState_WcState,
	uiInfoData_State := InfoData_State,
	pErrorSystem := ErrorSystem,
	bError => bError,
);

IF EN THEN
	IF NOT bError THEN
		Ch1_Value := AI_Std_Ch1_Value;
		Ch2_Value := AI_Std_Ch2_Value;
		Ch3_Value := AI_Std_Ch3_Value;
		Ch4_Value := AI_Std_Ch4_Value;
		Ch5_Value := AI_Std_Ch5_Value;
	ELSE
		Ch1_Value := 0;
		Ch2_Value := 0;
		Ch3_Value := 0;
		Ch4_Value := 0;
		Ch5_Value := 0;
	END_IF
END_IF

END_FUNCTION_BLOCK
```


POU: EL5002
-----------

File: Library/tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/Measuring_Terminals/EL5002.TcPOU

```vhdl
//EL5002 | 2-chennel SSI absolute encoder terminal
FUNCTION_BLOCK EL5002

VAR_INPUT
	En: BOOL;
	iTerminal_ID : INT;
	ErrorSystem : POINTER TO ST_ErrorSystem;
END_VAR

VAR_OUTPUT
	EnO: BOOL;
	Ch1_Counter_Value : UDINT;
	Ch2_Counter_Value : UDINT;
	bError: BOOL;
END_VAR

VAR
	udi_Ch1_Cnt_Value AT %I* : UDINT;
	udi_Ch2_Cnt_Value AT %I* : UDINT;
	WcState_WcState AT %I*: BOOL;
	InfoData_State AT %I*: UINT;
	
	//FB-s
	EL5002_Error : FB_TerminalError;
END_VAR
(*
* TODO:
* Channel Status words
*)

EnO:=En;

//Error FB instance
EL5002_Error(
	En := TRUE,
	iTerminal_ID := iTerminal_ID,
	bWcState := WcState_WcState,
	uiInfoData_State := InfoData_State,
	pErrorSystem := ErrorSystem,
	bError => bError,
);

IF EN THEN
	IF NOT bError THEN
		Ch1_Counter_Value := udi_Ch1_Cnt_Value;
		Ch2_Counter_Value := udi_Ch2_Cnt_Value;
	ELSE
		Ch1_Counter_Value := 0;
		Ch2_Counter_Value := 0;
	END_IF
END_IF

END_FUNCTION_BLOCK
```


POU: EL5021
-----------

File: Library/tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/Measuring_Terminals/EL5021.TcPOU

```vhdl
//EL5021 | 1-channel Sin/Cos encoder
FUNCTION_BLOCK EL5021

VAR_INPUT
	En: BOOL;
	iTerminal_ID : INT;
	ErrorSystem : POINTER TO ST_ErrorSystem;
END_VAR

VAR_OUTPUT
	EnO: BOOL;
	Counter_Value : UDINT;
	Latch_Value : UDINT;
	bError: BOOL;
END_VAR

VAR
	udiCounter_Value AT %I* : UDINT;
	udiLatch_Value AT %I* : UDINT;
	WcState_WcState AT %I*: BOOL;
	InfoData_State AT %I*: UINT;
	
	//FB-s
	EL5021_Error : FB_TerminalError;
END_VAR
(*
* TODO:
* Channel Status words, control words
*)

EnO:=En;

//Error FB instance
EL5021_Error(
	En := TRUE,
	iTerminal_ID := iTerminal_ID,
	bWcState := WcState_WcState,
	uiInfoData_State := InfoData_State,
	pErrorSystem := ErrorSystem,
	bError => bError,
);

IF EN THEN
	IF NOT bError THEN
		Counter_Value := udiCounter_Value;
		Latch_Value := udiLatch_Value;
	ELSE
		Counter_Value := 0;
		Latch_Value := 0;
	END_IF
END_IF

END_FUNCTION_BLOCK
```


POU: EL5042
-----------

File: Library/tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/Measuring_Terminals/EL5042.TcPOU

```vhdl
//EL5042 | 2-channel BiSS-C absolute encoder terminal
FUNCTION_BLOCK EL5042

VAR_INPUT
	En: BOOL;
	iTerminal_ID : INT;
	ErrorSystem : POINTER TO ST_ErrorSystem;
END_VAR

VAR_OUTPUT
	EnO: BOOL;
	Ch1_Position : ULINT;
	Ch2_Position : ULINT;
	bError: BOOL;
END_VAR

VAR
	FB_Inputs_ch1_Position AT %I* : ULINT;
	FB_Inputs_ch2_Position AT %I* : ULINT;
	WcState_WcState AT %I*: BOOL;
	InfoData_State AT %I*: UINT;
	
	//FB-s
	EL5042_Error : FB_TerminalError;
END_VAR
(*
* TODO:
* Channel Status words
*)

EnO:=En;

//Error FB instance
EL5042_Error(
	En := TRUE,
	iTerminal_ID := iTerminal_ID,
	bWcState := WcState_WcState,
	uiInfoData_State := InfoData_State,
	pErrorSystem := ErrorSystem,
	bError => bError,
);

IF EN THEN
	IF NOT bError THEN
		Ch1_Position := FB_Inputs_ch1_Position;
		Ch2_Position := FB_Inputs_ch2_Position;
	ELSE
		Ch1_Position := 0;
		Ch2_Position := 0;
	END_IF
END_IF

END_FUNCTION_BLOCK
```


POU: EL5101
-----------

File: Library/tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/Measuring_Terminals/EL5101.TcPOU

```vhdl
// EL5101 | 1-channel incremental encoder terminal, 5V, RS422
FUNCTION_BLOCK EL5101

VAR_INPUT
	En: BOOL;
	iTerminal_ID : INT;
	ErrorSystem : POINTER TO ST_ErrorSystem;
END_VAR

VAR_OUTPUT
	EnO: BOOL;
	Counter_Value : UINT;
	Latch_Value : UINT;
	bError: BOOL;
END_VAR

VAR
	uiCounter_Value AT %I* : UINT;
	uiLatch_Value AT %I* : UINT;
	WcState_WcState AT %I*: BOOL;
	InfoData_State AT %I*: UINT;
	
	//FB-s
	EL5101_Error : FB_TerminalError;
END_VAR
(*
* TODO:
* Channel Status word, control words
*)

EnO:=En;

//Error FB instance
EL5101_Error(
	En := TRUE,
	iTerminal_ID := iTerminal_ID,
	bWcState := WcState_WcState,
	uiInfoData_State := InfoData_State,
	pErrorSystem := ErrorSystem,
	bError => bError,
);

IF EN THEN
	IF NOT bError THEN
		Counter_Value := uiCounter_Value;
		Latch_Value := uiLatch_Value;
	ELSE
		Counter_Value := 0;
		Latch_Value := 0;
	END_IF
END_IF

END_FUNCTION_BLOCK
```


POU: EL7211_v1_00
-----------------

File: Library/tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/Motion/EL7211_v1_00.TcPOU

```vhdl
///EL7211 | Servo motor termional 5 A
FUNCTION_BLOCK EL7211_v1_00
VAR_INPUT
	En: BOOL;
END_VAR
VAR_OUTPUT
	EnO: BOOL;

	bError: BOOL;
END_VAR
VAR
	WcState_WcState AT %I*: BOOL;
	InfoData_State AT %I*: UINT;
END_VAR
EnO:=En;

IF En AND (WcState_WcState OR InfoData_State<>16#8) THEN
	bError:=TRUE;
ELSE
	bError:=FALSE;
END_IF

END_FUNCTION_BLOCK
```


POU: EL9410
-----------

File: Library/tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/System/EL9410.TcPOU

```vhdl
//EL9410 | E-Bus power supplier and refresher, diagnostics
FUNCTION_BLOCK EL9410

VAR_INPUT
	En: BOOL;
	iTerminal_ID : INT;
	ErrorSystem : POINTER TO ST_ErrorSystem;
END_VAR

VAR_OUTPUT
	EnO: BOOL;
	bError: BOOL;
END_VAR

VAR
	bStatus_Us_UV AT %I* : BOOL;
	bStatus_Up_UV AT %I* : BOOL;
	WcState_WcState AT %I*: BOOL;
	InfoData_State AT %I*: UINT;
	
	//FB-s
	EL9410_Error : FB_TerminalError;
END_VAR
(*
* TODO:
* Status bits
*)

EnO:=En;

//Error FB instance
EL9410_Error(
	En := TRUE,
	iTerminal_ID := iTerminal_ID,
	bWcState := WcState_WcState,
	uiInfoData_State := InfoData_State,
	pErrorSystem := ErrorSystem,
	bError => bError,
);

END_FUNCTION_BLOCK
```


POU: EL9505
-----------

File: Library/tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/System/EL9505.TcPOU

```vhdl
//EL9505 | Power supply terminal 5V
FUNCTION_BLOCK EL9505

VAR_INPUT
	En: BOOL;
	iTerminal_ID : INT;
	ErrorSystem : POINTER TO ST_ErrorSystem;
END_VAR

VAR_OUTPUT
	EnO: BOOL;
	bError: BOOL;
END_VAR

VAR
	bStatus_Uo_Power_OK AT %I* : BOOL;
	bStatus_Uo_Overload AT %I* : BOOL;
	WcState_WcState AT %I*: BOOL;
	InfoData_State AT %I*: UINT;
	
	//FB-s
	EL9505_Error : FB_TerminalError;
END_VAR
(*
* TODO:
* Status bits
*)
EnO:=En;

//Error FB instance
EL9505_Error(
	En := TRUE,
	iTerminal_ID := iTerminal_ID,
	bWcState := WcState_WcState,
	uiInfoData_State := InfoData_State,
	pErrorSystem := ErrorSystem,
	bError => bError,
);

END_FUNCTION_BLOCK
```


POU: EL9576_v1_00
-----------------

File: Library/tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/Motion/EL9576_v1_00.TcPOU

```vhdl
///EL9576 | Brake terminal (vap and resistor)
FUNCTION_BLOCK EL9576_v1_00
VAR_INPUT
	En: BOOL;
END_VAR
VAR_OUTPUT
	EnO: BOOL;
	bError: BOOL;	
	OverTemperature: BOOL;
	I2TError : BOOL;
	I2TWarning : BOOL;
	OverVoltage  : BOOL;
	UnderVoltage : BOOL;
	ChopperOn : BOOL;
	DCLinkVoltage : LREAL;
	DutyCycle  : LREAL;
	ResistorCurrent : LREAL;
	
END_VAR
VAR
	BCTOverTemperature AT %I*: BOOL;
	BCTI2TError AT %I*: BOOL;
	BCTI2TWarning AT %I*: BOOL;
	BCTOverVoltage  AT %I*: BOOL;
	BCTUnderVoltage  AT %I*: BOOL;
	BCTChopperOn  AT %I*: BOOL;
	BCTDCLinkVoltage AT %I*: UDINT;
	BCTDutyCycle  AT %I*: USINT;
	BCTResistorCurrent AT %I*: UDINT;
	WcState_WcState AT %I*: BOOL;
	InfoData_State AT %I*: UINT;
	
END_VAR
EnO:=En;

IF En AND (WcState_WcState OR InfoData_State<>16#8 OR BCTI2TError OR BCTI2TWarning OR BCTOverTemperature OR BCTOverVoltage OR BCTUnderVoltage) THEN
	bError:=TRUE;
ELSE
	bError:=FALSE;
END_IF

OverTemperature:=BCTOverTemperature;
I2TError:=BCTI2TError;
I2TWarning:=BCTI2TWarning;
OverVoltage:=BCTOverVoltage;
UnderVoltage:=bctUnderVoltage;
ChopperOn:=bctChopperOn;
DCLinkVoltage:=UDINT_TO_LREAL(bctDCLinkVoltage);
DutyCycle:=USINT_TO_LREAL(BCTDutyCycle);
ResistorCurrent:=UDINT_TO_LREAL(BCTResistorCurrent);

END_FUNCTION_BLOCK
```


POU: FB_CalculateFrequency_3702_v0_01
-------------------------------------

File: Library/tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/Analog_Inputs/FB_CalculateFrequency_3702_v0_01.TcPOU

```vhdl
FUNCTION_BLOCK FB_CalculateFrequency_3702_v0_01
VAR CONSTANT
	///200 samples/period
	cBufferSize: INT := 1000;
END_VAR
VAR_INPUT
	En: BOOL;
	bCalculate: BOOL;
	aBufferValue: ARRAY[0..(cBuffersize - 1)] OF INT;
	aBufferDcTime: ARRAY[0..(cBuffersize - 1)] OF UDINT;
	///If curve has a DC offset
	nDCOffset: INT := 0;
END_VAR
VAR_OUTPUT
	EnO: BOOL;
	bError: BOOL;
	fActFrequency: LREAL;
END_VAR
VAR
	nIndex: INT;
	nFirstZeroCrossing: INT;
	nLastZeroCrossing: INT;
	rTimeFirst: REAL := 0;
	rTimeLast: REAL := 0;
	rTimeRes: REAL := 0;
	nCrossings: INT := 0;
END_VAR
VAR_TEMP
	rRange: REAL := 0;
	rTimeSpan: REAL := 0;
END_VAR
EnO:=En;
bError:=FALSE;
nCrossings:=0;
IF En AND bCalculate THEN
	//Serach for crossings of nDCOffset
	FOR nIndex:=1 TO cBuffersize-1 DO
		IF((aBufferValue[nIndex]>nDCOffset AND aBufferValue[nIndex-1]<=nDCOffset) OR (aBufferValue[nIndex]<nDCOffset AND aBufferValue[nIndex-1]>=nDCOffset))	THEN
			IF(nCrossings=0) THEN
				nFirstZeroCrossing:=nIndex;
			END_IF
			nLastZeroCrossing:=nIndex;
			nCrossings:=nCrossings+1;
		END_IF
	END_FOR	
	
	IF nFirstZeroCrossing < nLastZeroCrossing  AND  nCrossings>2 THEN
		//interpolate zero crossings for higher accuracy
		rTimeRes:=UDINT_TO_REAL(aBufferDcTime[1]-aBufferDcTime[0]); //Buffer must contain more than 2 values
		rRange:=INT_TO_REAL(ABS(aBufferValue[nFirstZeroCrossing-1]-aBufferValue[nFirstZeroCrossing]));
		rTimeFirst:=UDINT_TO_REAL( aBufferDcTime[nFirstZeroCrossing-1])+ABS(INT_TO_REAL(aBufferValue[nFirstZeroCrossing-1])/rRange*rTimeRes);
		rRange:=INT_TO_REAL(ABS(aBufferValue[nLastZeroCrossing-1]-aBufferValue[nLastZeroCrossing]));
		rTimeLast:=UDINT_TO_REAL( aBufferDcTime[nLastZeroCrossing-1])+ABS(INT_TO_REAL(aBufferValue[nLastZeroCrossing-1])/rRange*rTimeRes);

		//Time span first to last (considering that max one time counter overflow have occured in the total time range of the time buffer)	
		IF rTimeFirst<rTimeLast THEN		
			rTimeSpan:=rTimeLast-rTimeFirst;
		ELSE //overflow of counter once (only 32bit timestamp =4.29seconds)
			rTimeSpan:=4294967296.0-rTimeFirst+rTimeLast;
		END_IF
		
		fActFrequency:=1000000000.0/rTimeSpan*(nCrossings-1)/2; //two crossings per period => Average frequency over buffer.
	ELSE
		fActFrequency:=0;
	END_IF
END_IF

END_FUNCTION_BLOCK
```


POU: FB_DriveVirtual
--------------------

File: Library/tc_mca_std_lib/POUs/Motion/FB_DriveVirtual.TcPOU

```vhdl
///#########################################################
///Function block to run a virtual drive with Nc
///	Library:		
///	Tc2_MC2.lib
///
///	Global Variables:
///	
///	Data types:
///	
///	External functions:
///
///###########################################################
FUNCTION_BLOCK FB_DriveVirtual
VAR
	sVersion: STRING:='1.0.3';	
END_VAR
VAR_INPUT
	En: BOOL;
	bEnable: BOOL;
	bReset: BOOL;
	bExecute: BOOL;
	/////	nCommandLocal...
	/////	0 = Jog
	/////	1 = MoveVelocity
	/////	2 = MoveRelative
	/////	3 = MoveAbsolut
	/////	4 = MoveModulo
	/////	10 = Homing
	/////	20 = SuperInp >>>ToBe
	/////	30 = Gear
	nCommand: UINT;
	nCmdData: UINT;
	fVelocity: LREAL;
	fPosition: LREAL;
	fAcceleration: LREAL;
	fDeceleration: LREAL;
	bJogFwd: BOOL;
	bJogBwd: BOOL;
	bLimitFwd: BOOL;
	bLimitBwd: BOOL;	
	fOverride: LREAL := 100;
	bHomeSensor: BOOL;
	fHomePosition:LREAL;
	nHomeRevOffset: UINT;
	MasterAxis: AXIS_REF;
	bPowerSelf: BOOL;
END_VAR
VAR_OUTPUT
	EnO: BOOL;
	bEnabled: BOOL;
	bBusy: BOOL;
	bDone: BOOL;
	bError: BOOL;
	bHomed: BOOL;
	nErrorId: UDINT;
	nMotionAxisID:UDINT:=0;  //Axis id in Motion (NC)
	Status: ST_AxisStatus;
	fActVelocity: LREAL;
	fActPosition: LREAL;
	fActDiff: LREAL;
    sErrorMessage:STRING;
END_VAR
VAR_IN_OUT
	Axis: AXIS_REF;
END_VAR
VAR	
	nCommandLocal: UINT;
	nCmdDataLocal: UINT;
	bFirstScan: BOOL := TRUE;
	fbReset: MC_Reset;
	fbPower: MC_Power;
	fbHalt: MC_Halt;
	fbJog: MC_Jog;
	fbMoveVelocity: MC_MoveVelocity;
	fbMoveRelative: MC_MoveRelative;
	fbMoveAbsolute: MC_MoveAbsolute;
	fbMoveModulo: MC_MoveModulo;	
	fbHomeVirtual:FB_HomeVirtual;
	fbGearInDyn: MC_GearInDyn;
	fbGearOut: MC_GearOut;
	fbExecuteRiseEdge: R_TRIG;
	stAxisStatus: DUT_AxisStatus_v0_01;	
END_VAR
EnO:=En;

// Transfer nCommand and nCmdData to local copies at rising edge of bExecute (avoid issues if nCommand or nCmdData are changed during a command) 
fbExecuteRiseEdge(CLK:=bExecute);
IF fbExecuteRiseEdge.Q THEN
  nCmdDataLocal:=nCmdData;
  nCommandLocal:=nCommand;
END_IF

bHomed:=fbHomeVirtual.bHomed; //Add in DUT_AxisStatus later
bDone:=FALSE;

(*Reset*)
fbReset(
	Execute:=bReset AND Axis.Status.Error,
	Axis:=Axis,
	Done=> ,
	Busy=> ,
	Error=> ,
	ErrorID=> );

(*Power*)
IF bPowerSelf THEN
fbPower(
	Axis:=Axis,
	Enable:=bEnable,	
	Enable_Positive:=bEnable AND bLimitFwd,	
	Enable_Negative:=bEnable AND bLimitBwd,	
	Override:=fOverride,
	BufferMode:= ,
	Status=> ,
	Busy=> ,
	Active=> ,
	Error=> ,
	ErrorID=> );
END_IF

(*Halt*)
fbHalt(
	Execute:=NOT bExecute  AND (((fbMoveVelocity.Busy OR fbPower.Busy) AND (nCommandLocal=1)) OR (fbMoveRelative.Busy AND (nCommandLocal=2)) OR (fbMoveAbsolute.Busy AND (nCommandLocal=3)) OR (fbMoveModulo.Busy AND (nCommandLocal=4)) OR (fbHomeVirtual.bBusy AND (nCommandLocal=10))),
	Deceleration:=fDeceleration,
	Jerk:=0,
	BufferMode:= ,
	Options:= ,
	Axis:=Axis ,
	Done=> ,
	Busy=> ,
	Active=> ,
	CommandAborted=> ,
	Error=> ,
	ErrorID=> );

(*Jog (Command = 0)*)
fbJog(
	JogForward:=bJogFwd AND (nCommandLocal=0) ,
	JogBackwards:=bJogBwd AND (nCommandLocal=0) ,
	Mode:=UINT_TO_INT(nCmdDataLocal),
	Position:= ,
	Velocity:=fVelocity,
	Acceleration:=fAcceleration,
	Deceleration:=fDeceleration,
	Jerk:=0,
	Axis:=Axis,
	Done=> ,
	Busy=> ,
	Active=> ,
	CommandAborted=> ,
	Error=> ,
	ErrorID=> );

(*MoveVelocity (Command = 1)*)
fbMoveVelocity(
	Execute:=bExecute AND (nCommandLocal=1),
	Velocity:=ABS(fVelocity),
	Acceleration:=fAcceleration,
	Deceleration:=fDeceleration,
	Jerk:=0,
	Direction:=SEL(fVelocity<0, MC_Positive_Direction, MC_Negative_Direction),
	BufferMode:= ,
	Options:= ,
	Axis:=Axis,
	InVelocity=> ,
	Busy=> ,
	Active=> ,
	CommandAborted=> ,
	Error=> ,
	ErrorID=> );

(*MoveRelative (Command = 2)*)
fbMoveRelative(
	Execute:=bExecute AND (nCommandLocal=2), 
	Distance:=fPosition, 
	Velocity:=ABS(fVelocity), 
	Acceleration:=fAcceleration,
	Deceleration:=fDeceleration,
	Jerk:=0,
	BufferMode:= , 
	Options:= , 
	Axis:=Axis, 
	Done=> , 
	Busy=> , 
	Active=> , 
	CommandAborted=> , 
	Error=> , 
	ErrorID=> );
	
IF nCommandLocal=2 THEN
	bDone:=fbMoveRelative.Done;
END_IF
	
(*MoveAbsolute (Command = 3)*)
fbMoveAbsolute(
	Execute:=bExecute AND (nCommandLocal=3),
	Position:=fPosition,
	Velocity:=ABS(fVelocity),
	Acceleration:=fAcceleration,
	Deceleration:=fDeceleration,
	Jerk:=0,
	BufferMode:= ,
	Options:= ,
	Axis:=Axis,
	Done=> ,
	Busy=> ,
	Active=> ,
	CommandAborted=> ,
	Error=> ,
	ErrorID=> );

IF nCommandLocal=3 THEN
	bDone:=fbMoveAbsolute.Done;
END_IF

(*MoveModulo (Command = 4)*)
fbMoveModulo(
	Execute:=bExecute AND (nCommandLocal=4), 
	Position:=fPosition, 
	Velocity:=ABS(fVelocity), 
	Acceleration:=fAcceleration, 
	Deceleration:=fDeceleration, 
	Jerk:=0, 
	Direction:=UINT_TO_INT(nCmdDataLocal), 
	BufferMode:= , 
	Options:= , 
	Axis:=Axis, 
	Done=> , 
	Busy=> , 
	Active=> , 
	CommandAborted=> , 
	Error=> , 
	ErrorID=> );

IF nCommandLocal=4 THEN
	bDone:=fbMoveModulo.Done;
END_IF
	
(*Home (Command = 10)*)
fbHomeVirtual(	
	bExecute:= nCommandLocal=10 AND bExecute,
	fHomePosition:=fHomePosition,
	bHomeSensor:=bHomeSensor,
	bLimitBwd:=bLimitBwd,
	bLimitFwd:=bLimitFwd,
	nCmdData:=nCmdDataLocal,
	bReset:=bReset,
	nHomeRevOffset:=nHomeRevOffset,
	Axis:=Axis
	);
	
IF nCommandLocal=10 THEN
	bDone:=fbHomeVirtual.bDone;
END_IF
	
(*Gear (Command = 30)*)
fbGearInDyn(
	Enable:=bExecute  AND (nCommandLocal=30),
	GearRatio:=SEL(nCmdDataLocal>0, 1,fVelocity),
	Acceleration:=fAcceleration,
	Deceleration:=fDeceleration,
	Jerk:=0.0,
	BufferMode:= , 
	Options:= , 
	Master:=MasterAxis,
	Slave:=Axis,
	InGear=> , 
	Busy=> , 
	Active=> , 
	CommandAborted=> , 
	Error=> , 
	ErrorID=> );
	
fbGearOut(
	Execute:=NOT bExecute AND Axis.Status.NotMoving AND (nCommandLocal=30),
	Slave:=Axis,
	Error=>,
	Done=>,
	ErrorID=>);


IF nCommandLocal=30 THEN
	bDone:=Axis.Status.Coupled;
END_IF

(*Busy*)
bBusy:=Axis.Status.HasJob OR Axis.Status.HomingBusy OR fbHomeVirtual.bBusy;

(*Enabled*)
bEnabled:=fbPower.Status;

(*Error from functions and Nc*)
IF fbPower.Error AND fbPower.Active THEN
	bError:=fbPower.Enable;
	nErrorId:=fbPower.ErrorID;
ELSIF fbHalt.Error AND fbHalt.Active THEN
	bError:=fbHalt.Execute;
	nErrorId:=fbHalt.ErrorID;
ELSIF fbJog.Error AND nCommandLocal=0 (*fbJog.Active*) THEN
	bError:=fbJog.JogForward OR fbJog.JogBackwards;
	nErrorId:=fbJog.ErrorID;
ELSIF fbMoveVelocity.Error AND nCommandLocal=1(*fbMoveVelocity.Active*) THEN
	bError:=fbMoveVelocity.Execute;
	nErrorId:=fbMoveVelocity.ErrorID;
ELSIF fbMoveRelative.Error AND nCommandLocal=2 (*fbMoveRelative.Active*) THEN
	bError:=fbMoveRelative.Execute;
	nErrorId:=fbMoveRelative.ErrorID;
ELSIF fbMoveAbsolute.Error AND nCommandLocal=3 (*fbMoveAbsolute.Active*) THEN
	bError:=fbMoveAbsolute.Execute;
	nErrorId:=fbMoveAbsolute.ErrorID;
ELSIF fbMoveModulo.Error AND nCommandLocal=4 (*fbMoveModulo.Active*) THEN
	bError:=fbMoveModulo.Execute;
	nErrorId:=fbMoveModulo.ErrorID;
ELSIF fbHomeVirtual.bError AND nCommandLocal=10 (*fbHome.Active*) THEN
	bError:=fbHomeVirtual.bError;
	nErrorId:=fbHomeVirtual.nErrorID;
ELSIF fbGearInDyn.Error AND nCommandLocal=30 (*fbGearInDyn.Active*) THEN
	bError:=fbGearInDyn.Enable;
	nErrorId:=fbGearInDyn.ErrorID;
ELSIF fbGearOut.Error AND nCommandLocal=30 AND Axis.Status.Coupled THEN
	bError:=fbGearOut.Execute;
	nErrorId:=fbGearOut.ErrorID;
ELSIF Axis.Status.Error  THEN
	bError:=TRUE;
	nErrorId:=Axis.Status.ErrorID;
ELSIF fbHomeVirtual.bError THEN
	bError:=TRUE;
	nErrorId:=fbHomeVirtual.nErrorId;
ELSE
	bError:=FALSE;
	nErrorId:=0;
END_IF;

(*Converese nErrorID to string*)
sErrorMessage:=WORD_TO_HEXSTR(in:=TO_WORD(nErrorID) , iPrecision:= 4, bLoCase:=0 );

(*Status from Nc*)
Status:=Axis.Status;

(*Axis id in motion "motor"*)
nMotionAxisID:=axis.NcToPlc.AxisId;

(*Actual Velocity*)
fActVelocity:=Axis.NcToPlc.ActVelo;

(*Actual Position*)
IF Axis.Status.OpMode.Modulo THEN
	fActPosition:=Axis.NcToPlc.ModuloActPos;
ELSE
	fActPosition:=Axis.NcToPlc.ActPos;
END_IF

(*Actual Position*)
fActDiff:=Axis.NcToPlc.PosDiff;


//Status struct for EPICS communication
stAxisStatus.bEnable:=bEnable;
stAxisStatus.bEnabled:=bEnabled;
stAxisStatus.bError:=bError;
stAxisStatus.bExecute:=bExecute;
stAxisStatus.bHomeSensor:=bHomeSensor;
stAxisStatus.bJogBwd:=bJogBwd;
stAxisStatus.bJogFwd:=bJogFwd;
stAxisStatus.bLimitBwd:=bLimitBwd;
stAxisStatus.bLimitFwd:=bLimitFwd;
stAxisStatus.bReset:=bReset;
stAxisStatus.fAcceleration:=fAcceleration;
stAxisStatus.fActDiff:=fActDiff;
stAxisStatus.fActPosition:=fActPosition;
stAxisStatus.fActVelocity:=fActVelocity;
stAxisStatus.fDeceleration:=fDeceleration;
stAxisStatus.fOverride:=fOverride;
stAxisStatus.fPosition:=fPosition;
stAxisStatus.fVelocity:=fVelocity;
stAxisStatus.nCmdData:=nCmdData;  //Or nCmdDataLocal
stAxisStatus.nCommand:=nCommand;  //Or nCommandLocal
stAxisStatus.nErrorId:=nErrorId;
stAxisStatus.bBusy:=bBusy;
stAxisStatus.bHomed:=bHomed;

IF bFirstScan THEN
	bFirstScan:=FALSE;
END_IF

END_FUNCTION_BLOCK
```


POU: FB_EL1252ASM_v1_00
-----------------------

File: Library/tc_mca_std_lib/POUs/Hardware/EtherCAT_Terminals/Digital_Inputs/FB_EL1252ASM_v1_00.TcPOU

```vhdl
FUNCTION_BLOCK FB_EL1252ASM_v1_00
VAR_INPUT
	En: BOOL;
END_VAR
VAR_OUTPUT
	EnO: BOOL;
	Di_1: BOOL;
	Di_2: BOOL;
	Di_1_LatchTimePos: ULINT;
	Di_2_LatchTimePos: ULINT;
	Di_1_LatchTimeNeg: ULINT;
	Di_2_LatchTimeNeg: ULINT;
	///Below bits can be used but then they must be enabled in the COE of the card. Nicklas suggested to not use these (since something wss written that you then only were allowed to read the latch time onece (some kkind of auto reset??))	
	///Di_1_LatchNeg:BOOL;
	///	Di_1_LatchPos:BOOL;
	///	Di_2_LatchNeg:BOOL;
	///	Di_2_LatchPos:BOOL;
	Error: BOOL;
END_VAR
VAR
	Channel_1_Input AT %I*: BOOL;
	Channel_2_Input AT %I*: BOOL;
	///Latch_Status1 AT %I*: USINT;
	///	Latch_Status2 AT %I*: USINT;
	Latch_LatchPos1 AT %I*: ULINT;
	Latch_LatchNeg1 AT %I*: ULINT;
	Latch_LatchPos2 AT %I*: ULINT;
	Latch_LatchNeg2 AT %I*: ULINT;
	WcState_WcState AT %I*: BOOL;
	InfoData_State AT %I*: UINT;
END_VAR
EnO:=En;

IF En AND (WcState_WcState OR InfoData_State<>16#8) THEN //InfoData_State==0 => in OP mode
	Error:=TRUE;
ELSE
	Error:=FALSE;
END_IF

IF En THEN
	IF Error=FALSE THEN
		Di_1:=Channel_1_Input;
		Di_2:=Channel_2_Input;
	(*	Di_1_LatchPos:=Latch_Status1.0;
		Di_1_LatchNeg:=Latch_Status1.1;
		Di_2_LatchPos:=Latch_Status2.0;
		Di_2_LatchNeg:=Latch_Status2.1;*)
		Di_1_LatchTimePos:=Latch_LatchPos1;
		Di_2_LatchTimePos:=Latch_LatchPos2;		
		Di_1_LatchTimeNeg:=Latch_LatchNeg1;		
		Di_2_LatchTimeNeg:=Latch_LatchNeg2;
		
	ELSE
		Di_1:=FALSE;
		Di_2:=FALSE;
	END_IF
END_IF

END_FUNCTION_BLOCK
```


POU: FB_EpicsInOut
------------------

File: Library/POUs/Motion/States/FB_EpicsInOut.TcPOU

```vhdl
FUNCTION_BLOCK FB_EpicsInOut
// Example usage of FB_PositionStateManager for a simple IN/OUT axis. See NOTE: comments.
// Also usable as a drop-in for these cases (no need to roll your own in/out)
VAR_IN_OUT
    // Motor to apply states to
    stMotionStage: DUT_MotionStage;
    // Information about the OUT position
    stOut: DUT_PositionState; // NOTE: Do not pragma these, let it happen in the manager.
    // Information about the IN parameter
    stIn: DUT_PositionState;
END_VAR
VAR_INPUT
    // If TRUE, the motor will be moved when enumSet is changed
    bEnable: BOOL;
    // When changed, sets the destination and starts a move
    {attribute 'pytmc' := '
        pv: SET
        io: io
    '}
    enumSet: ENUM_EpicsInOut; // NOTE: Please copy this pragma exactly on your enumSet
END_VAR
VAR_OUTPUT
    // If TRUE, we are in an error state
    bError: BOOL; // NOTE: do not pragma these, already has pragma in manager
    // Error code
    nErrorId: UDINT;
    // Message associated with bError = TRUE
    sErrorMessage: STRING;
    // If TRUE, we are currently moving between states
    bBusy: BOOL;
    // If TRUE, we asked for a move between states, it completed successfully, and there is no ongoing move
    bDone: BOOL;
    // The current state readback
    {attribute 'pytmc' := '
        pv: GET
        io: i
    '}
    enumGet: ENUM_EpicsInOut; // NOTE: Please copy this pragma exactly on your enumGet
END_VAR
VAR
    bInit: BOOL;
    arrStates: ARRAY[1..15] OF DUT_PositionState;

    {attribute 'pytmc' := '
        pv:
        io: io
    '}
    fbStateManager: FB_PositionStateManager; // NOTE: Please copy this pragma exactly to pick up the standard PVs
    fbLockOut: FB_PositionStateLock;
    fbLockIn: FB_PositionStateLock;
END_VAR
// Fist cycle setup
IF NOT bInit THEN
    stOut.sName := 'OUT';
    stIn.sName := 'IN';
    bInit := TRUE;
END_IF

// If either of these have bLocked = TRUE, do not allow user to change them
fbLockOut(stPositionState:=stOut);
fbLockIn(stPositionState:=stIn);

// Stuff first two values of the 15 element array for the manager
arrStates[1] := stOut;
arrStates[2] := stIn;

// Call the function block every cycle
fbStateManager(
    stMotionStage := stMotionStage,
    arrStates := arrStates,
    setState := enumSet,
    bEnable := bEnable,
    bError => bError,
    nErrorId => nErrorId,
    sErrorMessage => sErrorMessage,
    bBusy => bBusy,
    bDone => bDone,
    getState => enumGet); // Cannot do this assignment if enumGet has attribute strict

END_FUNCTION_BLOCK
```


POU: FB_ErrorList
-----------------

File: Library/tc_mca_std_lib/POUs/ErrorHandling/FB_ErrorList.TcPOU

```vhdl
FUNCTION_BLOCK FB_ErrorList

VAR_INPUT
	En : BOOL;											//Enable input
	bReset : BOOL;										//Delete all Error entry
	lErrorID : ULINT;									//ErrorID to be acknoledged
	bACK : BOOL;										//Acknoledge the given error and delete it from the list
END_VAR
	
VAR_OUTPUT
	EnO : BOOL;											//Enable output
	nNoError: UINT;										//Number of Errors
	nNoOverflow : INT;									//Number of Overflows
	pErrorSystem : POINTER TO ST_ErrorSystem;			//Pointer to ErrorSystem
END_VAR

VAR
	nFreePos : UINT;									//Number of free position in the list
	nListCnt1 : UINT;									//work variable
	ErrorSystem : ST_ErrorSystem;						//Data structure of the Error list
END_VAR
(*
* ================================================================================
*                                   DESCRIPTION
* ================================================================================
* This Function Block implements the core structure of the Error/Warning Handling
* system. It realizes the datastructure containing every Error Entry, collect
* statistics about the usage and manage the Error Entries.
* Note: The system is under development, most of the functionalities are not
* implemented or existing functionalities may change with time.
* ================================================================================
*)
EnO := En;

//Ponter to ErrorSystem
pErrorSystem := ADR(ErrorSystem);

//Number of overflows
nNoOverflow := ErrorSystem.nNoOverflows;

IF bReset THEN
	MEMSET ( ADR(ErrorSystem.aErrorData[0]), 0, GVL_ErrorSystem.cSizeOfErrorData * SIZEOF(DUT_TerminalError));
	ErrorSystem.lNextErrorID := 1;
END_IF

//Number of errors in the system
nNoError := 0;
FOR nListCnt1 := 0 TO GVL_ErrorSystem.cSizeOfErrorData - 1 DO
	IF ErrorSystem.aErrorData[nListCnt1].Error_ID <> 0  THEN
		nNoError := nNoError+1; 
	END_IF
END_FOR
ErrorSystem.nNoErrors := nNoError;

//Number of free position in the list
nFreePos := GVL_ErrorSystem.cSizeOfErrorData - nNoError;

//Acknoledge specified Error entry
IF bACK THEN
	FOR nListCnt1 := 0 TO GVL_ErrorSystem.cSizeOfErrorData - 1 DO
		IF ErrorSystem.aErrorData[nListCnt1].Error_ID = lErrorID THEN
			ErrorSystem.aErrorData[nListCnt1].ErrorState := DUT_ErrorState.Acknowledged;
		END_IF
	END_FOR
END_IF

//Deleting acknoledged errors
FOR nListCnt1 := 0 TO GVL_ErrorSystem.cSizeOfErrorData - 1 DO
	IF ErrorSystem.aErrorData[nListCnt1].ErrorState = DUT_ErrorState.Acknowledged THEN
		MEMMOVE (ADR(ErrorSystem.aErrorData[nListCnt1]), ADR(ErrorSystem.aErrorData[nListCnt1+1]), (GVL_ErrorSystem.cSizeOfErrorData - 1 - nListCnt1) * SIZEOF(DUT_TerminalError));
		MEMSET(ADR(ErrorSystem.aErrorData[GVL_ErrorSystem.cSizeOfErrorData - 1]), 0, SIZEOF(DUT_TerminalError));
	END_IF
END_FOR

END_FUNCTION_BLOCK
```


POU: FB_GantryAutoCoupling
--------------------------

File: Library/POUs/Motion/Gantry/FB_GantryAutoCoupling.TcPOU

```vhdl
FUNCTION_BLOCK FB_GantryAutoCoupling
VAR_INPUT
    nGantryTol : LINT;
END_VAR
VAR_OUTPUT
    bGantryAlreadyCoupled : BOOL;
END_VAR
VAR_IN_OUT
    Master : DUT_MotionStage;
    MasterEnc : ST_RenishawAbsEnc;
    Slave : DUT_MotionStage;
    SlaveEnc : ST_RenishawAbsEnc;
    bExecuteCouple : BOOL;
    bExecuteDecouple : BOOL;
END_VAR
VAR
    gantry_diff_limit : FB_GantryDiffVirtualLimitSwitch;
    couple : MC_GEARIN;
    decouple : MC_GEAROUT;
    bInitComplete : BOOL;
    fbSetEnables : FB_SetEnables;
END_VAR
// Designate Master and SLave Axes
Master.bGantryAxis := TRUE;
Slave.bGantryAxis := TRUE;

Master.nGantryTol := nGantryTol;
Slave.nGantryTol := Master.nGantryTol;

// Activate Gantry Virtual Limit Switch
gantry_diff_limit(Penc:=MasterEnc, SEnc:=SlaveEnc, GantDiffTol:=Master.nGantryTol,
                  PLimFwd=>Master.bGantryForwardEnable, PLimBwd=>Master.bGantryBackwardEnable,
                  SLimFwd=>Slave.bGantryForwardEnable, SLimBwd=>Slave.bGantryBackwardEnable);

// Coupling Status Bit
bGantryAlreadyCoupled := Master.Axis.NcToPlc.CoupleState=1 AND Slave.Axis.NcToPlc.CoupleState=3;

fbSetEnables(stMotionStage:=Master);
fbSetEnables(stMotionStage:=Slave);

IF bGantryAlreadyCoupled THEN
    Master.bGantryForwardEnable := Master.bGantryForwardEnable AND Slave.bAllForwardEnable;
    Slave.bGantryForwardEnable := Master.bAllForwardEnable AND Slave.bGantryForwardEnable;

    Master.bGantryBackwardEnable := Master.bGantryBackwardEnable AND Slave.bAllBackwardEnable;
    Slave.bGantryBackwardEnable := Master.bAllBackwardEnable AND Slave.bGantryBackwardEnable;
END_IF


// Coupling states
// Auto-coupling at init and auto-reset of coupling boolean
bExecuteCouple S= NOT bInitComplete;

bExecuteCouple R= couple.Busy OR bGantryAlreadyCoupled;
couple(Master:=Master.Axis, Slave:=Slave.Axis, Execute:=bExecuteCouple);

bInitComplete S= bGantryAlreadyCoupled;

// Decoupling with auto-reset of coupling boolean
bExecuteDecouple R= decouple.Busy OR NOT bGantryAlreadyCoupled;
decouple(Slave:=Slave.Axis, Execute:=bExecuteDecouple);

END_FUNCTION_BLOCK
```


POU: FB_GantryDiffVirtualLimitSwitch
------------------------------------

File: Library/POUs/Motion/Gantry/FB_GantryDiffVirtualLimitSwitch.TcPOU

```vhdl
FUNCTION_BLOCK FB_GantryDiffVirtualLimitSwitch
VAR_INPUT
    PEnc: ST_RenishawAbsEnc; // Primary axis encoder (usually the upstream one)
    SEnc: ST_RenishawAbsEnc; // Secondary axis encoder (couples to the primary)

    GantDiffTol: LINT;        // Gantry differenace tolerance in encoder counts
END_VAR
VAR_OUTPUT
    PLimFwd: BOOL; // Primary axis forward direction enable
    PLimBwd: BOOL; // Primary axis reverse direction enable
    SLimFwd: BOOL; // Secondary axis forward direction enable
    SLimBwd: BOOL; // Secondary axis reverse direction enable
END_VAR
VAR
    GantryDiff: LINT;
END_VAR
(* Gantry Difference Virtual Limit Switch
A. Wallace 2017-2-15

Determines which direction is disabled due to it increasing the gantry difference.
Refer to the ESD for actual conventions.

A positive gantry error refers to a CCW clocked assembly:
eg. for X
X1 upstream, X2 downstream. Primary axis is always upstream.
Gantry difference > 0 when
X2>X1
Therefore
X2 positive direction disabled
X1 negative direction disabled

Call before FB_MotionStage fb calls for the gantry axes.
*)

GantryDiff := ( ULINT_TO_LINT(PEnc.Count) - ULINT_TO_LINT(PEnc.Ref) ) - ( ULINT_TO_LINT(SEnc.Count) - ULINT_TO_LINT(SEnc.Ref) );

IF ABS(GantryDiff) > GantDiffTol THEN
    IF GantryDiff < 0  THEN
        PLimBwd := FALSE;
        SLimFwd := FALSE;
    ELSE
        PLimBwd := TRUE;
        SLimFwd := TRUE;
    END_IF
    IF GantryDiff > 0 THEN
        PLimFwd := FALSE;
        SLimBwd := FALSE;
    ELSE
        PLimFwd := TRUE;
        SLimBwd := TRUE;
    END_IF
ELSE
    //If there is no fault, all directions are enabled
    PLimFwd := TRUE;
    PLimBwd := TRUE;
    SLimFwd := TRUE;
    SLimBwd := TRUE;
END_IF

END_FUNCTION_BLOCK
```


POU: FB_HomeDirect
------------------

File: Library/tc_mca_std_lib/POUs/Motion/Homing/FB_HomeDirect.TcPOU

```vhdl
FUNCTION_BLOCK FB_HomeDirect
VAR_INPUT
	En: BOOL;
	bReset: BOOL;
    bExecute: BOOL;	
	fHomePosition:LREAL;	
END_VAR
VAR_IN_OUT
	Axis: AXIS_REF;
END_VAR
VAR_OUTPUT
	EnO: BOOL;	
	bBusy: BOOL;
	bDone: BOOL;
	bHomed:BOOL;
	bError: BOOL;
	nErrorId: UDINT;
END_VAR
VAR
	fbHome: MC_Home;	
END_VAR
En:=EnO;
IF bReset THEN
	bError:=FALSE;
	nErrorId:=0;
END_IF 

fbHome(
	Execute:=bExecute,
	Position:=fHomePosition,
	HomingMode:=MC_Direct,
	bCalibrationCam:=FALSE,
	Axis:=Axis
	);
	
bBusy:=fbHome.Busy;
bDone:=fbHome.Done;
bHomed:=Axis.Status.Homed;

bError:=fbHome.Error; 

IF fbHome.Error THEN
  nErrorId:=fbHome.ErrorID;
END_IF

END_FUNCTION_BLOCK
```


POU: FB_HomeFinish
------------------

File: Library/tc_mca_std_lib/POUs/Motion/Homing/FB_HomeFinish.TcPOU

```vhdl
FUNCTION_BLOCK FB_HomeFinish
VAR_INPUT
	En: BOOL;
	bReset: BOOL;
    bExecute: BOOL;	
    nCmdData: UINT;
	bSofLimEnableLow: BOOL:=TRUE;
	bSofLimEnableHigh: BOOL:=TRUE;			
END_VAR
VAR_IN_OUT
	Axis: AXIS_REF;
END_VAR
VAR_OUTPUT
	EnO: BOOL;	
	bBusy: BOOL;
	bDone: BOOL;
	bError: BOOL;
	nErrorId: UDINT;
END_VAR
VAR		
	fbHomewriteSoftLimEnable:FB_HomeWriteSoftLimEnable;	
	fbExecuteRiseEdge: R_TRIG;	
	bExecuteWriteNC:BOOL:=FALSE;
	nState:INT:=0;
END_VAR
En:=EnO;
IF bReset THEN
	bError:=FALSE;
	nErrorId:=0;
END_IF 

IF NOT bExecute THEN
  bExecuteWriteNC:=FALSE;
  fbHomewriteSoftLimEnable.bSofLimEnableLow:=bSofLimEnableLow;
  fbHomewriteSoftLimEnable.bSofLimEnableHigh:=bSofLimEnableHigh;   
  nState:=0;
END_IF

fbExecuteRiseEdge(CLK:=bExecute);
IF fbExecuteRiseEdge.Q THEN
  bExecuteWriteNC:=TRUE;  
  fbHomewriteSoftLimEnable.bSofLimEnableLow:=bSofLimEnableLow;
  fbHomewriteSoftLimEnable.bSofLimEnableHigh:=bSofLimEnableHigh;
END_IF

// Write to NC (disable soft limits)
fbHomewriteSoftLimEnable(
	En:=En,
	bExecute:=bExecuteWriteNC AND bExecute,
	Axis:=Axis,
	bReset:=bReset,	
);

bBusy:=fbHomewriteSoftLimEnable.bBusy;
bDone:=fbHomewriteSoftLimEnable.bDone;

bError:=fbHomewriteSoftLimEnable.bError;
IF fbHomewriteSoftLimEnable.bError THEN
  nErrorId:=fbHomewriteSoftLimEnable.nErrorId;
END_IF

END_FUNCTION_BLOCK
```


POU: FB_HomePrepare
-------------------

File: Library/tc_mca_std_lib/POUs/Motion/Homing/FB_HomePrepare.TcPOU

```vhdl
FUNCTION_BLOCK FB_HomePrepare
VAR_INPUT
	En: BOOL;
	bReset: BOOL;
    bExecute: BOOL;	
    nCmdData: UINT;		
END_VAR
VAR_IN_OUT
	Axis: AXIS_REF;
END_VAR
VAR_OUTPUT
	EnO: BOOL;	
	bBusy: BOOL;
	bDone: BOOL;
	bError: BOOL;
	nErrorId: UDINT;
	bSofLimEnableLowOriginal: BOOL:=TRUE;
	bSofLimEnableHighOriginal: BOOL:=TRUE;	
	fVelocityToCam: LREAL:=0;
	fVelocityFromCam: LREAL:=0;		
END_VAR
VAR
	fbHomeReadSoftLimEnable:FB_HomeReadSoftLimEnable;	
	fbHomeDisableSoftLimEnable:FB_HomeWriteSoftLimEnable;
	fbHomeReadNCVelocities: FB_HomeReadNcVelocities;
	fbHomeResetCalibrationFlag:MC_Home;   //Only used for reset of calibration flag
	fbExecuteRiseEdge: R_TRIG;
	bExecuteReadNC:BOOL:=FALSE;
	bExecuteWriteNC:BOOL:=FALSE;
	nState:INT:=0;
END_VAR
En:=EnO;
IF bReset THEN
	bError:=FALSE;
	nErrorId:=0;
END_IF 

IF NOT bExecute THEN
  bExecuteReadNC:=FALSE;
  bExecuteWriteNC:=FALSE;   
  nState:=0;
END_IF

fbExecuteRiseEdge(CLK:=bExecute);
IF fbExecuteRiseEdge.Q THEN
  bExecuteReadNC:=TRUE;  
END_IF

// Read from NC
fbHomeReadNCVelocities(
  En:=En,
  bExecute:=bExecuteReadNC, // Actualy not needed for sequence 15 (set position only, no movement))
  bReset:=bReset,
  Axis:=Axis,
);

fbHomeReadSoftLimEnable(
	En:=En,
	bExecute:=bExecuteReadNC AND bExecute,
	Axis:=Axis,
	bReset:=bReset,	
);

// Reset calibration flag
fbHomeResetCalibrationFlag(
  Execute:=bExecuteReadNC,
  HomingMode:=MC_ResetCalibration,
  Axis:=Axis
);

bSofLimEnableLowOriginal:=fbHomeReadSoftLimEnable.bSofLimEnableLow;
bSofLimEnableHighOriginal:=fbHomeReadSoftLimEnable.bSofLimEnableHigh;	

fVelocityToCam:=fbHomeReadNCVelocities.fVelocityToCam;
fVelocityFromCam:=fbHomeReadNCVelocities.fVelocityFromCam;

IF bExecuteReadNC AND bExecute AND fbHomeReadSoftLimEnable.bDone THEN
	fbHomeDisableSoftLimEnable.bSofLimEnableHigh:=FALSE;
	fbHomeDisableSoftLimEnable.bSofLimEnableLow:=FALSE;
	bExecuteWriteNC:=TRUE; //Always write (only needed if enabled actually)
END_IF

// Write to NC (disable soft limits)
fbHomeDisableSoftLimEnable(
	En:=En,
	bExecute:=bExecuteWriteNC AND bExecute,
	Axis:=Axis,
	bReset:=bReset,	
);

bBusy:=fbHomeReadSoftLimEnable.bBusy OR fbHomeDisableSoftLimEnable.bBusy OR fbHomeReadNCVelocities.bBusy OR fbHomeResetCalibrationFlag.Busy;
bDone:=fbHomeReadSoftLimEnable.bDone AND fbHomeDisableSoftLimEnable.bDone AND fbHomeReadNCVelocities.bDone AND fbHomeResetCalibrationFlag.Done AND bExecute;

bError:=fbHomeReadSoftLimEnable.bError OR fbHomeDisableSoftLimEnable.bError OR fbHomeReadNCVelocities.bError OR fbHomeResetCalibrationFlag.Error;
IF fbHomeReadSoftLimEnable.bError THEN
  nErrorId:=fbHomeReadSoftLimEnable.nErrorId;
ELSIF fbHomeDisableSoftLimEnable.bError THEN
  nErrorId:=fbHomeDisableSoftLimEnable.nErrorId;
ELSIF fbHomeResetCalibrationFlag.Error THEN
  nErrorId:=fbHomeResetCalibrationFlag.ErrorId;
END_IF

END_FUNCTION_BLOCK
```


POU: FB_HomeReadNcVelocities
----------------------------

File: Library/tc_mca_std_lib/POUs/Motion/Homing/FB_HomeReadNcVelocities.TcPOU

```vhdl
FUNCTION_BLOCK FB_HomeReadNcVelocities
VAR_INPUT
	En: BOOL;
	bReset: BOOL;
    bExecute: BOOL;			
END_VAR
VAR_IN_OUT
	Axis: AXIS_REF;
END_VAR
VAR_OUTPUT
	EnO: BOOL;	
	bBusy: BOOL;
	bDone: BOOL;
	bError: BOOL;
	nErrorId: UDINT;	
	fVelocityToCam: LREAL;
	fVelocityFromCam: LREAL;
END_VAR
VAR
	fbReadVelocityToCam:FB_ReadFloatParameter;
	fbReadVelocityFromCam:FB_ReadFloatParameter;
END_VAR
En:=EnO;
IF bReset THEN
	bError:=FALSE;
	nErrorId:=0;
END_IF 
	
fbReadVelocityToCam(
	bExecute:=bExecute,
	nDeviceGroup:= 16#4000,
	nIndexOffset:= 16#6,
	Axis:= Axis);
	
fbReadVelocityFromCam(
	bExecute:=bExecute,
	nDeviceGroup:= 16#4000,
	nIndexOffset:= 16#7,
	Axis:= Axis);
	
fVelocityToCam:=fbReadVelocityToCam.nData;
fVelocityFromCam:=fbReadVelocityFromCam.nData;	

bBusy:=fbReadVelocityFromCam.bBusy OR fbReadVelocityToCam.bBusy;
bDone:=fbReadVelocityFromCam.bDone AND fbReadVelocityToCam.bDone AND bExecute;

bError:=fbReadVelocityToCam.bError OR fbReadVelocityFromCam.bError;
IF fbReadVelocityToCam.bError THEN
  nErrorId:=fbReadVelocityToCam.nErrorId;
ELSIF fbReadVelocityFromCam.bError THEN
  nErrorId:=fbReadVelocityFromCam.nErrorId;
END_IF

END_FUNCTION_BLOCK
```


POU: FB_HomeReadSoftLimEnable
-----------------------------

File: Library/tc_mca_std_lib/POUs/Motion/Homing/FB_HomeReadSoftLimEnable.TcPOU

```vhdl
FUNCTION_BLOCK FB_HomeReadSoftLimEnable
VAR_INPUT
	En: BOOL;
	bReset: BOOL;
    bExecute: BOOL;			
END_VAR
VAR_IN_OUT
	Axis: AXIS_REF;
END_VAR
VAR_OUTPUT
	EnO: BOOL;	
	bBusy: BOOL;
	bDone: BOOL;
	bError: BOOL;
	nErrorId: UDINT;	
	bSofLimEnableLow: BOOL:=TRUE;
	bSofLimEnableHigh: BOOL:=TRUE;
END_VAR
VAR
	fbReadSoftLimEnableLow:FB_ReadParameterInNc_v1_00;
	fbReadSoftLimEnableHigh:FB_ReadParameterInNc_v1_00;
END_VAR
En:=EnO;
IF bReset THEN
	bError:=FALSE;
	nErrorId:=0;
END_IF 
	
fbReadSoftLimEnableLow(
	bExecute:=bExecute,
	nDeviceGroup:= 16#5000,
	nIndexOffset:= 16#B,
	Axis:= Axis);

fbReadSoftLimEnableHigh(
	bExecute:=bExecute,
	nDeviceGroup:= 16#5000,
	nIndexOffset:= 16#C,
	Axis:= Axis);
	
bSofLimEnableLow:=DWORD_TO_BOOL(fbReadSoftLimEnableLow.nData);
bSofLimEnableHigh:=DWORD_TO_BOOL(fbReadSoftLimEnableHigh.nData);	

bBusy:=fbReadSoftLimEnableLow.bBusy OR fbReadSoftLimEnableHigh.bBusy;
bDone:=fbReadSoftLimEnableLow.bDone AND fbReadSoftLimEnableHigh.bDone AND bExecute;

bError:=fbReadSoftLimEnableLow.bError OR fbReadSoftLimEnableHigh.bError;
IF fbReadSoftLimEnableLow.bError THEN
  nErrorId:=fbReadSoftLimEnableLow.nErrorId;
ELSIF fbReadSoftLimEnableHigh.bError THEN
  nErrorId:=fbReadSoftLimEnableHigh.nErrorId;
END_IF

END_FUNCTION_BLOCK
```


POU: FB_HomeToSwitch
--------------------

File: Library/tc_mca_std_lib/POUs/Motion/Homing/FB_HomeToSwitch.TcPOU

```vhdl
FUNCTION_BLOCK FB_HomeToSwitch
VAR_INPUT
	En: BOOL;
	bReset: BOOL;
    bExecute: BOOL;	
    bCamSensor:BOOL;	
	nSearchDirTwoardsCam: MC_Direction;
	nSearchDirOffCam: MC_Direction;
	fHomePosition:LREAL;	
	fVelocityToCamNC: LREAL; //Velcoity when searching for cam
	fVelocityFromCamNC: LREAL; // Velocity after found cam (searching for next signal transition)
END_VAR
VAR_IN_OUT
	Axis: AXIS_REF;
END_VAR
VAR_OUTPUT
	EnO: BOOL;	
	bBusy: BOOL;
	bDone: BOOL;
	bHomed:BOOL;
	bError: BOOL;
	nErrorId: UDINT;
END_VAR
VAR
	fbHome: MC_Home;	
	fbWriteHomeDirCamToNC:FB_WriteParameterInNc_v1_00;
	fbWriteHomeDirSyncToNC:FB_WriteParameterInNc_v1_00;
	fbWriteHomeModeToNC:FB_WriteParameterInNc_v1_00;
	fbWriteHomeVelocitiesToNC: FB_HomeWriteNcVelocities;
	bConfigNCDone:BOOL:=FALSE;
	fbRTrigg: R_TRIG;
END_VAR
En:=EnO;
IF bReset THEN
	bConfigNCDone:=FALSE;
	bError:=FALSE;
	nErrorId:=0;
END_IF 
	
//Start preparation of NC if rising edge on bExecute
fbRTrigg(CLK:=bExecute);
IF fbRTrigg.Q THEN
	bConfigNCDone:=FALSE;
END_IF

 
fbWriteHomeDirCamToNC(
	bExecute:=bExecute AND NOT bConfigNCDone,
	nDeviceGroup:=16#5000,
	nIndexOffset:=16#101,	//Direction for Calibration Cam Search	
	nData:=BOOL_TO_DWORD(nSearchDirTwoardsCam=MC_Negative_Direction),//BOOL_TO_DWORD(NOT bSearchDirTwoardsCam),
	Axis:=Axis
);

fbWriteHomeDirSyncToNC(
	bExecute:= bExecute AND NOT bConfigNCDone,
	nDeviceGroup:=16#5000 ,
	nIndexOffset:=16#102 , //Direction for Sync Impuls Search
	nData:=BOOL_TO_DWORD(nSearchDirOffCam=MC_Negative_Direction),//BOOL_TO_DWORD(NOT bSearchDirOffCam),
	Axis:= Axis 
);

fbWriteHomeModeToNC(
	bExecute:=bExecute AND NOT bConfigNCDone,
	nDeviceGroup:=16#5000,
	nIndexOffset:=16#107,  //Reference Mode
	nData:=1,
	Axis:=axis);
	
fbWriteHomeVelocitiesToNC(
  En:=En,
  bExecute:=bExecute AND NOT bConfigNCDone,
  bReset:=bReset,
  fVelocityFromCam:=fVelocityFromCamNC,
  fVelocityToCam:=fVelocityToCamNC,
  Axis:=Axis);

fbHome.bCalibrationCam:=bCamSensor;

fbHome(
	Execute:=bExecute AND bConfigNCDone(* AND NOT bError*),
	Position:=fHomePosition,
	HomingMode:=0,
	Axis:=Axis
	);
bBusy:=(fbHome.Busy OR (NOT bConfigNCDone AND bExecute));
bDone:=fbHome.Done AND bConfigNCDone;
bHomed:=Axis.Status.Homed;

IF (NOT bConfigNCDone) AND fbWriteHomeDirCamToNC.bDone AND fbWriteHomeDirSyncToNC.bDone AND fbWriteHomeModeToNC.bDone AND fbWriteHomeVelocitiesToNC.bDone THEN
  bConfigNCDone:=TRUE;
END_IF

//For some reason MC_HOME gives an Error for one cycle of NC-Task 1 SVB (10ms default..) so filter with bExecute
bError:=(fbHome.Error AND bExecute) OR fbWriteHomeDirCamToNC.bError OR fbWriteHomeDirSyncToNC.bError OR fbWriteHomeModeToNC.bError OR fbWriteHomeVelocitiesToNC.bError;

IF (fbHome.Error AND bExecute) THEN
  nErrorId:=fbHome.ErrorID;
ELSIF fbWriteHomeDirCamToNC.bError THEN
  nErrorId:=fbWriteHomeDirCamToNC.nErrorId;
ELSIF fbWriteHomeDirSyncToNC.bError THEN
  nErrorId:=fbWriteHomeDirSyncToNC.nErrorId;
ELSIF fbWriteHomeModeToNC.bError THEN
  nErrorId:=fbWriteHomeModeToNC.nErrorId;
ELSIF fbWriteHomeVelocitiesToNC.bError THEN
  nErrorId:=fbWriteHomeVelocitiesToNC.nErrorId;  
END_IF

END_FUNCTION_BLOCK
```


POU: FB_HomeVirtual
-------------------

File: Library/tc_mca_std_lib/POUs/Motion/Homing/FB_HomeVirtual.TcPOU

```vhdl
FUNCTION_BLOCK FB_HomeVirtual
VAR_INPUT
	En: BOOL;
	bReset: BOOL;
	bExecute: BOOL;
	nCmdData: UINT;
	bLimitFwd: BOOL;
	bLimitBwd: BOOL;	
	bHomeSensor: BOOL;	
	fHomePosition:LREAL;
	nHomeRevOffset: UINT;
END_VAR
VAR_IN_OUT
	Axis: AXIS_REF;
END_VAR
VAR_OUTPUT
	EnO: BOOL;	
	bBusy: BOOL;
	bDone: BOOL;
	bHomed:BOOL;
	bError: BOOL;
	nErrorId: UDINT;
END_VAR
VAR
	fbHomeToSwitch: FB_HomeToSwitch;
    fbHomeDirect: FB_HomeDirect; //Only used for direct homing (set of position)
    fbMoveVelocity:MC_MoveVelocity;
    fbHomePrepare:FB_HomePrepare;
	fbHomeFinish:FB_HomeFinish;    	    		
	fbExecuteRiseEdge: R_TRIG;
    nHomingState:INT:=0;
	bExecuteHomeToSwitch:BOOL:=FALSE;
	bExecuteMoveVelocity:BOOL:=FALSE;
	bExecutePrepare: BOOL:=FALSE;
	bExecuteFinish: BOOL:=FALSE;
	bExecuteHomeDirect: BOOL;
	nCmdDataLocal: UINT;  //Ensure that nCmdData is not changed during sequence
	bSequenceReady:BOOL:=TRUE;
	bRestoreNCDataNeeded: BOOL:=FALSE;
END_VAR
EnO:=En;

IF bReset THEN	
	bError:=FALSE;
	nErrorId:=0;
END_IF

// Reset when bExecute is low
IF NOT bExecute THEN
  nHomingState:=0;
  bSequenceReady:=TRUE;
  bExecuteHomeToSwitch:=FALSE;
  bExecuteHomeDirect:=FALSE;
  bExecuteMoveVelocity:=FALSE;
  bExecutePrepare:=FALSE;
  bExecuteFinish:=FALSE;
END_IF

//Reset at rinsing edge of bExecute
fbExecuteRiseEdge(CLK:=bExecute);
IF fbExecuteRiseEdge.Q THEN
  nCmdDataLocal:=nCmdData; //Ensure that nCmdData is not changed during sequence (nCmdData will only be read at a rising edge of bExecute)
  bSequenceReady:=FALSE;
  bExecutePrepare:=TRUE;  
  bRestoreNCDataNeeded:=FALSE;
  //Check if valid nCmdDataLocal
  CASE nCmdDataLocal OF  	
    1:
    2:
    3:
    4:
    15:
    ELSE //nCmdData not valid	
      bError:=TRUE;
      nErrorId:=16#4FFF;   
  END_CASE
END_IF

//############# Prepare for homing (Read from NC and reset homed flag)
fbHomePrepare(
  En:=En,
  bExecute:=bExecutePrepare AND NOT bError, // Not needed for sequence 15 (set position only, no movement))
  bReset:=bReset,
  Axis:=Axis,
);

//############# Homing Sequences:
CASE nCmdDataLocal OF  
	
   1: // Home to low limit switch
	   CASE nHomingState OF
		  0:
		    bHomed:=Axis.Status.Homed;
            // Wait for read of velocities from NC and reset of calibration flag
	        IF fbHomePrepare.bDone AND bExecute AND NOT bSequenceReady THEN
			  bRestoreNCDataNeeded:=TRUE;
			  IF bLimitBwd THEN
                nHomingState:=1;
              ELSE
				nHomingState:=2;  //Standing on limit switch go direct to state 2 
              END_IF                                          		  
	        END_IF
		  1: // wait for reach low limit then trigger fbHomeToSwitch
		    bHomed:=FALSE;
			bSequenceReady:=FALSE;
			fbMoveVelocity.Velocity:=ABS(fbHomePrepare.fVelocityToCam);
            fbMoveVelocity.Direction:=MC_Negative_Direction;
	        bExecuteMoveVelocity:=bExecute;  // Execute MC_MoveVelocity
		    IF NOT bLimitBwd AND NOT fbMoveVelocity.Busy AND Axis.Status.NotMoving THEN //MC_MoveVelocity.Busy goes down when ramp down initiates (not ends).
			  nHomingState:=2;
		    END_IF
		  2: // Wait for fbHomeToSwitch
		    bHomed:=FALSE;
		    bSequenceReady:=FALSE;
            bExecuteMoveVelocity:=FALSE;			
            bExecuteHomeToSwitch:=TRUE;	
            fbHomeToSwitch.nSearchDirTwoardsCam:=MC_Positive_Direction;
            fbHomeToSwitch.nSearchDirOffCam:=MC_Positive_Direction;	             
	        fbHomeToSwitch.fVelocityToCamNC:=fbHomePrepare.fVelocityToCam; // High speed
  	        fbHomeToSwitch.fVelocityFromCamNC:=fbHomePrepare.fVelocityFromCam;  // Low speed              		
		    fbHomeToSwitch.bCamSensor:=NOT bLimitBwd;            	 		    
	        IF fbHomeToSwitch.bDone THEN	          
			  nHomingState:=3;
			  bExecuteFinish:=TRUE;
			  fbHomeFinish.bSofLimEnableHigh:=fbHomePrepare.bSofLimEnableHighOriginal;
			  fbHomeFinish.bSofLimEnableLow:=fbHomePrepare.bSofLimEnableLowOriginal;
	        END_IF;	
          3: // restore softlimit enable
            bHomed:=FALSE;
		    bSequenceReady:=FALSE;            		            	
	        IF fbHomeFinish.bDone THEN
			  bRestoreNCDataNeeded:=FALSE;
	          bSequenceReady:=TRUE;
			  nHomingState:=0;
			  bHomed:=Axis.Status.Homed;
	        END_IF;	 
	   END_CASE;
	   
   2: // Home to high limit switch
	   CASE nHomingState OF
		  0:
		    bHomed:=Axis.Status.Homed;
            // Wait for read of velocities from NC and reset of calibration flag
	        IF fbHomePrepare.bDone AND bExecute AND NOT bSequenceReady THEN
			  bRestoreNCDataNeeded:=TRUE;
			  IF bLimitFwd THEN
                nHomingState:=1;
              ELSE
				nHomingState:=2;  //Standing on limit switch go direct to state 2 
              END_IF                                          		  
	        END_IF
		  1: // wait for reach low limit then trigger fbHomeToSwitch
		    bHomed:=FALSE;
			bSequenceReady:=FALSE;
			fbMoveVelocity.Velocity:=ABS(fbHomePrepare.fVelocityToCam);
            fbMoveVelocity.Direction:=MC_Positive_Direction;
	        bExecuteMoveVelocity:=bExecute;  // Execute MC_MoveVelocity
		    IF NOT bLimitFwd AND NOT fbMoveVelocity.Busy AND Axis.Status.NotMoving THEN //MC_MoveVelocity.Busy goes down when ramp down initiates (not ends).
			  nHomingState:=2;
		    END_IF
		  2: // Wait for fbHomeToSwitch
		    bHomed:=FALSE;
		    bSequenceReady:=FALSE;
            bExecuteMoveVelocity:=FALSE;			
            bExecuteHomeToSwitch:=TRUE;	
            fbHomeToSwitch.nSearchDirTwoardsCam:=MC_Negative_Direction;
            fbHomeToSwitch.nSearchDirOffCam:=MC_Negative_Direction;	             
	        fbHomeToSwitch.fVelocityToCamNC:=fbHomePrepare.fVelocityToCam; // High speed
  	        fbHomeToSwitch.fVelocityFromCamNC:=fbHomePrepare.fVelocityFromCam;  // Low speed              		
		    fbHomeToSwitch.bCamSensor:=NOT bLimitFwd;            	 		    
	        IF fbHomeToSwitch.bDone THEN	          
			  nHomingState:=3;
			  bExecuteFinish:=TRUE;
			  fbHomeFinish.bSofLimEnableHigh:=fbHomePrepare.bSofLimEnableHighOriginal;
			  fbHomeFinish.bSofLimEnableLow:=fbHomePrepare.bSofLimEnableLowOriginal;
	        END_IF;	
          3: // restore softlimit enable
            bHomed:=FALSE;
		    bSequenceReady:=FALSE;            		            	
	        IF fbHomeFinish.bDone THEN
			  bRestoreNCDataNeeded:=FALSE;
	          bSequenceReady:=TRUE;
			  nHomingState:=0;
			  bHomed:=Axis.Status.Homed;
	        END_IF;	 
	   END_CASE;
	   
   3: // Home on bHomeSensor via bLimitBwd
   	   CASE nHomingState OF
		  0:
		    bHomed:=Axis.Status.Homed;
            // Wait for read of velocities from NC and reset of calibration flag
	        IF fbHomePrepare.bDone AND bExecute AND NOT bSequenceReady THEN
			  bRestoreNCDataNeeded:=TRUE;
			  IF bLimitBwd THEN
                nHomingState:=1;
              ELSE
				nHomingState:=2;  //Standing on limit switch go direct to state 2 
              END_IF                                          		  
	        END_IF
		  1: // wait for reach low limit then trigger fbHomeToSwitch
		    bHomed:=FALSE;
			bSequenceReady:=FALSE;
			fbMoveVelocity.Velocity:=ABS(fbHomePrepare.fVelocityToCam);
            fbMoveVelocity.Direction:=MC_Negative_Direction;
	        bExecuteMoveVelocity:=bExecute;  // Execute MC_MoveVelocity
		    IF NOT bLimitBwd AND NOT fbMoveVelocity.Busy AND Axis.Status.NotMoving THEN //MC_MoveVelocity.Busy goes down when ramp down initiates (not ends).
			  nHomingState:=2;
		    END_IF
		  2: // Wait for fbHomeToSwitch
		    bHomed:=FALSE;
		    bSequenceReady:=FALSE;
            bExecuteMoveVelocity:=FALSE;			
            bExecuteHomeToSwitch:=TRUE;	
            fbHomeToSwitch.nSearchDirTwoardsCam:=MC_Positive_Direction;
            fbHomeToSwitch.nSearchDirOffCam:=MC_Positive_Direction;	             
	        fbHomeToSwitch.fVelocityToCamNC:=fbHomePrepare.fVelocityToCam; // High speed
  	        fbHomeToSwitch.fVelocityFromCamNC:=fbHomePrepare.fVelocityFromCam;  // Low speed              		
		    fbHomeToSwitch.bCamSensor:=bHomeSensor;            	 		    
	        IF fbHomeToSwitch.bDone THEN	          
			  nHomingState:=3;
			  bExecuteFinish:=TRUE;
			  fbHomeFinish.bSofLimEnableHigh:=fbHomePrepare.bSofLimEnableHighOriginal;
			  fbHomeFinish.bSofLimEnableLow:=fbHomePrepare.bSofLimEnableLowOriginal;
	        END_IF;	
          3: // restore softlimit enable
            bHomed:=FALSE;
		    bSequenceReady:=FALSE;            		            	
	        IF fbHomeFinish.bDone THEN
		      bRestoreNCDataNeeded:=FALSE;
	          bSequenceReady:=TRUE;
			  nHomingState:=0;
			  bHomed:=Axis.Status.Homed;
	        END_IF;	 
	   END_CASE;
	4:  // Home on bHomeSensor via bLimitFwd	   
	   CASE nHomingState OF
		  0:
		    bHomed:=Axis.Status.Homed;
            // Wait for read of velocities from NC and reset of calibration flag
	        IF fbHomePrepare.bDone AND bExecute AND NOT bSequenceReady THEN
			  bRestoreNCDataNeeded:=TRUE;
			  IF bLimitFwd THEN
                nHomingState:=1;
              ELSE
				nHomingState:=2;  //Standing on limit switch go direct to state 2 
              END_IF                                          		  
	        END_IF
		  1: // wait for reach low limit then trigger fbHomeToSwitch
		    bHomed:=FALSE;
			bSequenceReady:=FALSE;
			fbMoveVelocity.Velocity:=ABS(fbHomePrepare.fVelocityToCam);
            fbMoveVelocity.Direction:=MC_Positive_Direction;
	        bExecuteMoveVelocity:=bExecute;  // Execute MC_MoveVelocity
		    IF NOT bLimitFwd AND NOT fbMoveVelocity.Busy AND Axis.Status.NotMoving THEN //MC_MoveVelocity.Busy goes down when ramp down initiates (not ends).
			  nHomingState:=2;
		    END_IF
		  2: // Wait for fbHomeToSwitch
		    bHomed:=FALSE;
		    bSequenceReady:=FALSE;
            bExecuteMoveVelocity:=FALSE;			
            bExecuteHomeToSwitch:=TRUE;	
            fbHomeToSwitch.nSearchDirTwoardsCam:=MC_Negative_Direction;
            fbHomeToSwitch.nSearchDirOffCam:=MC_Negative_Direction;	             
	        fbHomeToSwitch.fVelocityToCamNC:=fbHomePrepare.fVelocityToCam; // High speed
  	        fbHomeToSwitch.fVelocityFromCamNC:=fbHomePrepare.fVelocityFromCam;  // Low speed              		
		    fbHomeToSwitch.bCamSensor:=bHomeSensor;            	 		    
	        IF fbHomeToSwitch.bDone THEN	          
			  nHomingState:=3;
			  bExecuteFinish:=TRUE;
			  fbHomeFinish.bSofLimEnableHigh:=fbHomePrepare.bSofLimEnableHighOriginal;
			  fbHomeFinish.bSofLimEnableLow:=fbHomePrepare.bSofLimEnableLowOriginal;
	        END_IF;	
          3: // Restore softlimit enable
            bHomed:=FALSE;
		    bSequenceReady:=FALSE;            		            	
	        IF fbHomeFinish.bDone THEN
			  bRestoreNCDataNeeded:=FALSE;
	          bSequenceReady:=TRUE;
			  nHomingState:=0;
			  bHomed:=Axis.Status.Homed;
	        END_IF;	 
	   END_CASE;
		  	    
   15: //Set current position (simplest homing sequence)
     bExecuteHomeDirect:=bExecute;
	 bHomed:=Axis.Status.Homed;
     IF fbHomeDirect.bDone THEN  //Homing ready				
	   bExecuteHomeDirect:=FALSE;				
       bSequenceReady:=TRUE;	
     END_IF	 
	 
ELSE
  fbHomeToSwitch.bCamSensor:=FALSE;
  bHomed:=Axis.Status.Homed;
END_CASE;

// Main homing block
fbHomeToSwitch(
	bExecute:=bExecuteHomeToSwitch AND bExecute AND NOT bError AND NOT bExecuteHomeDirect AND NOT bExecuteMoveVelocity,
 	bReset:=bReset,
	fHomePosition:=fHomePosition,
	Axis:=Axis
);

// Approach limit switch (error if MC_Home is used)
fbMoveVelocity(
    Execute:= bExecuteMoveVelocity AND bExecute AND NOT bError AND NOT bExecuteHomeToSwitch AND NOT bExecuteHomeDirect,
    Axis:=Axis
);

// No sequence, just set position value (nCmdDataLocal=15). Can not run if fbHomeToSwitch is executed
fbHomeDirect(
	bExecute:=bExecuteHomeDirect AND bExecute AND NOT bError  AND NOT bExecuteHomeToSwitch AND NOT bExecuteMoveVelocity,
 	bReset:=bReset,
	fHomePosition:=fHomePosition,
	Axis:=Axis
);

 
//############# Finish homing

IF NOT bexecute AND bRestoreNCDataNeeded THEN  //If homing is aborted restore is needed
	bExecuteFinish:=TRUE;
	IF fbHomeFinish.bDone THEN
	  bExecuteFinish:=FALSE;
      bRestoreNCDataNeeded:=FALSE;	
	END_IF
END_IF

fbHomeFinish(
  En:=En,
  bExecute:=bExecuteFinish,
  bReset:=bReset,
  Axis:=Axis,
);

// Error handling
IF NOT bError THEN
  IF fbHomeToSwitch.bError THEN 
	bError:=fbHomeToSwitch.bError;
	nErrorId:=fbHomeToSwitch.nErrorId;
  ELSIF fbHomeDirect.bError THEN
	bError:=fbHomeDirect.bError;
	nErrorId:=fbHomeDirect.nErrorId;
  ELSIF fbMoveVelocity.Error THEN
	bError:=fbMoveVelocity.Error;
	nErrorId:=fbMoveVelocity.ErrorId;    		    		
  END_IF;	
END_IF

// Done and busy bit
bDone:=bSequenceReady AND bExecute;
bBusy:=NOT bSequenceReady;	 

RETURN;

END_FUNCTION_BLOCK
```


POU: FB_HomeWriteNcVelocities
-----------------------------

File: Library/tc_mca_std_lib/POUs/Motion/Homing/FB_HomeWriteNcVelocities.TcPOU

```vhdl
FUNCTION_BLOCK FB_HomeWriteNcVelocities
VAR_INPUT
	En: BOOL;
	bReset: BOOL;
    bExecute: BOOL;		
	fVelocityToCam: LREAL;
	fVelocityFromCam: LREAL;	
END_VAR
VAR_IN_OUT
	Axis: AXIS_REF;
END_VAR
VAR_OUTPUT
	EnO: BOOL;	
	bBusy: BOOL;
	bDone: BOOL;
	bError: BOOL;
	nErrorId: UDINT;	
END_VAR
VAR
	fbExecuteRiseEdge: R_TRIG;
	fbWriteVelocityToCam:FB_WriteFloatParameter;
	fbWriteVelocityFromCam:FB_WriteFloatParameter;
END_VAR
En:=EnO;
IF bReset THEN
	bError:=FALSE;
	nErrorId:=0;
END_IF 

fbExecuteRiseEdge(CLK:=bExecute);

fbWriteVelocityToCam(
	bExecute:=bExecute,
	nDeviceGroup:= 16#4000,
	nIndexOffset:= 16#6,
	nData:=fVelocityToCam,
	Axis:= Axis);
	
fbWriteVelocityFromCam(
	bExecute:=bExecute,
	nDeviceGroup:= 16#4000,
	nIndexOffset:= 16#7,
	nData:=fVelocityFromCam,
	Axis:= Axis);

bBusy:=fbWriteVelocityFromCam.bBusy OR fbWriteVelocityToCam.bBusy;
bDone:=fbWriteVelocityFromCam.bDone AND fbWriteVelocityToCam.bDone AND bExecute;

bError:=fbWriteVelocityToCam.bError OR fbWriteVelocityFromCam.bError;
IF fbWriteVelocityToCam.bError THEN
  nErrorId:=fbWriteVelocityToCam.nErrorId;
ELSIF fbWriteVelocityFromCam.bError THEN
  nErrorId:=fbWriteVelocityFromCam.nErrorId;
END_IF

END_FUNCTION_BLOCK
```


POU: FB_HomeWriteSoftLimEnable
------------------------------

File: Library/tc_mca_std_lib/POUs/Motion/Homing/FB_HomeWriteSoftLimEnable.TcPOU

```vhdl
FUNCTION_BLOCK FB_HomeWriteSoftLimEnable
VAR_INPUT
	En: BOOL;
	bReset: BOOL;
    bExecute: BOOL;		
	bSofLimEnableLow: BOOL:=TRUE;
	bSofLimEnableHigh: BOOL:=TRUE;
END_VAR
VAR_IN_OUT
	Axis: AXIS_REF;
END_VAR
VAR_OUTPUT
	EnO: BOOL;	
	bBusy: BOOL;
	bDone: BOOL;
	bError: BOOL;
	nErrorId: UDINT;	
END_VAR
VAR
	fbExecuteRiseEdge: R_TRIG;
	fbWriteSoftLimEnableLow:FB_WriteParameterInNc_v1_00;
	fbWriteSoftLimEnableHigh:FB_WriteParameterInNc_v1_00;
END_VAR
En:=EnO;
IF bReset THEN
	bError:=FALSE;
	nErrorId:=0;
END_IF 

fbExecuteRiseEdge(CLK:=bExecute);

fbWriteSoftLimEnableLow(
	bExecute:=bExecute,
	nDeviceGroup:= 16#5000,
	nIndexOffset:= 16#B,
	nData:=BOOL_TO_DWORD(bSofLimEnableLow),
	Axis:= Axis);
	
fbWriteSoftLimEnableHigh(
	bExecute:=bExecute,
	nDeviceGroup:= 16#5000,
	nIndexOffset:= 16#C,
	nData:=BOOL_TO_DWORD(bSofLimEnableHigh),
	Axis:= Axis);

bBusy:=fbWriteSoftLimEnableLow.bBusy OR fbWriteSoftLimEnableHigh.bBusy;
bDone:=fbWriteSoftLimEnableLow.bDone AND fbWriteSoftLimEnableHigh.bDone AND bExecute;

bError:=fbWriteSoftLimEnableHigh.bError OR fbWriteSoftLimEnableLow.bError;
IF fbWriteSoftLimEnableHigh.bError THEN
  nErrorId:=fbWriteSoftLimEnableHigh.nErrorId;
ELSIF fbWriteSoftLimEnableLow.bError THEN
  nErrorId:=fbWriteSoftLimEnableLow.nErrorId;
END_IF

END_FUNCTION_BLOCK
```


POU: FB_MicroStepCountTest
--------------------------

File: Library/POUs/MotorTesting/FB_MicroStepCountTest.TcPOU

```vhdl
FUNCTION_BLOCK FB_MicroStepCountTest
VAR_INPUT
    bExecute: BOOL;
    fStepSize: LREAL;
    nSteps: UINT;
    fMicroStep: LREAL;
    fVelocity: LREAL;
    tSettleTime: TIME;
END_VAR
VAR_IN_OUT
    Axis: AXIS_REF;
END_VAR
VAR_OUTPUT
    nStepsCounted: UINT;
    nTheorySteps: UINT;
    fPercent: LREAL;
    fEstMicroSize: LREAL;
END_VAR
VAR
    fbMoveRel: MC_MoveRelative;
    fbSettleTimer: TON;
    bDoMove: BOOL;
    nStepCounter: UINT;

    arrPosBuffer: ARRAY [0..99] OF LREAL;
    fAvgPos: LREAL;
    nArrIndex: UINT;
    nLoopIndex: UINT;

    fStartPos: LREAL;
    fPrevPos: LREAL;
    fStepChange: LREAL;

    fStepSum: LREAL;
END_VAR
// Motion FB
fbMoveRel(Axis:=Axis,
    Execute:=bDoMove,
    Distance:=fStepSize,
    Velocity:=fVelocity);

// Settle time
fbSettleTimer(IN:=fbMoveRel.Done,
    PT:=tSettleTime);

// Re-enable the move for next cycle
bDoMove := bExecute AND nStepCounter < nSteps;

// Calculate rolling average
arrPosBuffer[nArrIndex] := Axis.NcToPlc.ActPos;
fAvgPos := 0;
FOR nLoopIndex := 0 TO 99 DO
    fAvgPos := fAvgPos + arrPosBuffer[nLoopIndex];
END_FOR;
fAvgPos := fAvgPos / 100;
nArrIndex := (nArrIndex + 1) MOD 100;

// Initialize starting variables
IF NOT bExecute THEN
    fStartPos := fAvgPos;
    fPrevPos := fAvgPos;
END_IF

// Check results
IF fbSettleTimer.Q THEN
    fStepChange := fAvgPos - fPrevPos;
    // Invert fStepChange if we were doing negative steps
    IF fStepSize < 0 THEN
        fStepChange := fStepChange * -1;
    END_IF
    IF fStepChange > fMicroStep * 0.5 THEN
        nStepsCounted := nStepsCounted + 1;
        fStepSum := fStepSum + fStepChange;
        fEstMicroSize := fStepSum / nStepsCounted;
    END_IF
    nTheorySteps := DINT_TO_UINT(TRUNC(ABS((fStartPos - fAvgPos) / fMicroStep)));
    IF nTheorySteps > 0 THEN
        fPercent := 100 * nStepsCounted / nTheorySteps;
    END_IF
    fPrevPos := fAvgPos;
    nStepCounter := nStepCounter + 1;
    // Reset the move block
    bDoMove := FALSE;
END_IF

END_FUNCTION_BLOCK
```


POU: FB_MotionPneumaticActuator
-------------------------------

File: Library/POUs/Motion/FB_MotionPneumaticActuator.TcPOU

```vhdl
(*This function blcok implements a pnuematic actuator. That can be signle or double acting by setting the ibSingleCntrl accordingly*)
(* with double acting ibCntrlHold signal should be false, while with single acting the signal should be true*)
FUNCTION_BLOCK FB_MotionPneumaticActuator
VAR_INPUT
    (*EPS Interlock Bits*)
    ibInsertOK: BOOL; (*Actuator can be Inserted*)
    ibRetractOK: BOOL; (*ACtuator can be retracted*)
    ibPMPS_OK:BOOL; (*to be linked the Arbiter bit*)
    ibSingleCntrl:BOOL;(* TRUE if Actuator requires one Output signal to be activated, FALSE if its double acting i.e two outputs are required*)
    ibCntrlHold:BOOL; (* Control Signal must retain its value, must be TRUE in the case of single acting*)
    ibOverrideInterlock:BOOL; (*if true interlocks are ignored*)
    // Reset fault
    {attribute 'pytmc' := '
    pv: FF_Reset
    '}
    i_xReset: BOOL;
END_VAR
VAR_OUTPUT
    {attribute 'pytmc' := '
    pv:
    '}
    stPneumaticActuator    :    DUT_MotionPneumaticActuator;
    {attribute 'pytmc' := '
     pv: MPS_OK
     field: ZNAM FALSE
     field: ONAM TRUE
     field: DESC TRUE if MPS signal is OK
    '}
    xMPS_OK:BOOL;
END_VAR
VAR_IN_OUT
    io_fbFFHWO    :    FB_HardwareFFOutput;
END_VAR
VAR
    // PMPS
    fbFF    :    FB_FastFault :=(
        i_DevName := 'MPA',
        i_Desc := 'Fault occurs when the device is moving',
        i_TypeCode := 10#1010);

    (*Init*)
    xFirstPass    :    BOOL;
    fbFSInit        :    R_TRIG;

    (* Timeouts*)
    tTimeOutDuration: TIME:= T#10S;
    tInserttimeout: TON;
    tRetracttimeout:TON;
    (*Limit switch latch timer*)
    tLimitSwitchLatchDuration: TIME:=T#1S;
    tInsertLimitSwitch:TON;
    tRetractLimitSwitch:TON;

    (*Logging*)
    fbLogger : FB_LogMessage := (eSubsystem:=E_SubSystem.MOTION);
    ePrevState : ENUM_PnuematicActuatorPositionState;
    tAction : R_TRIG; // Primary action of this device (Insert_DO, Retract_DO, etc.)
    tOverrideActivated : R_TRIG;

    (*IO*)
    i_xInsertedLS    AT%I*: BOOL;
    i_xRetractedLS    AT%I*: BOOL;
    q_xInsert_DO    AT%Q*: BOOL;
    q_xRetract_DO    AT%Q*: BOOL;

END_VAR
(*Initialize*)
fbFSInit( CLK := TRUE, Q => xFirstPass);
IF xFirstPass THEN
    stPneumaticActuator.eState := ENUM_PnuematicActuatorPositionState.INVALID;
    stPneumaticActuator.bRetract_SW := FALSE;
    stPneumaticActuator.bInsert_SW := FALSE;
END_IF

(*Soft IO Mapping to EPICS PVs*)
ACT_IO();

(* Manage States*)
IF stPneumaticActuator.i_bInLimitSwitch AND  stPneumaticActuator.i_bOutLimitSwitch THEN
    stPneumaticActuator.eState:=ENUM_PnuematicActuatorPositionState.INVALID;
ELSIF NOT stPneumaticActuator.i_bInLimitSwitch AND stPneumaticActuator.i_bOutLimitSwitch THEN
    stPneumaticActuator.eState:=ENUM_PnuematicActuatorPositionState.RETRACTED;
ELSIF stPneumaticActuator.i_bInLimitSwitch AND NOT stPneumaticActuator.i_bOutLimitSwitch THEN
    stPneumaticActuator.eState:=ENUM_PnuematicActuatorPositionState.INSERTED;
ELSIF NOT stPneumaticActuator.i_bInLimitSwitch AND NOT stPneumaticActuator.i_bOutLimitSwitch THEN
    stPneumaticActuator.eState:=ENUM_PnuematicActuatorPositionState.MOVING;
ELSE
    stPneumaticActuator.eState:=ENUM_PnuematicActuatorPositionState.INVALID ;
END_IF

(*Set the Done/Busy signal*)
stPneumaticActuator.bDone := (stPneumaticActuator.bRetract_SW AND stPneumaticActuator.eState=ENUM_PnuematicActuatorPositionState.RETRACTED)
                            OR (stPneumaticActuator.bInsert_SW AND stPneumaticActuator.eState=ENUM_PnuematicActuatorPositionState.INSERTED);
stPneumaticActuator.bBusy := (stPneumaticActuator.bRetract_SW AND stPneumaticActuator.eState<>ENUM_PnuematicActuatorPositionState.RETRACTED)
                            OR (stPneumaticActuator.bInsert_SW AND stPneumaticActuator.eState<>ENUM_PnuematicActuatorPositionState.INSERTED);
(*MPS FAULT*)
(* MPS Faults when the actuator is in motion*)
xMPS_OK := (stPneumaticActuator.eState=ENUM_PnuematicActuatorPositionState.RETRACTED) OR (stPneumaticActuator.eState=ENUM_PnuematicActuatorPositionState.INSERTED);
(*PMPS PERMISSION*)
// yet to be implemented

(* Can't have bRetract_SW and  bInsert_SW both be true*)
If (stPneumaticActuator.bRetract_SW) AND (stPneumaticActuator.bInsert_SW) THEN
    stPneumaticActuator.bRetract_SW := FALSE;
    stPneumaticActuator.bInsert_SW := FALSE;
END_IF
//Redundant??
(*Check if both digital outputs active at the same time, and clear all*)
IF stPneumaticActuator.q_bInsert THEN
    stPneumaticActuator.q_bRetract := FALSE;
    stPneumaticActuator.bRetract_SW:= FALSE;
END_IF;
IF stPneumaticActuator.q_bRetract THEN
    stPneumaticActuator.q_bInsert := FALSE;
    stPneumaticActuator.bInsert_SW:= FALSE;
END_IF;

(*Actuate the device*)
stPneumaticActuator.q_bRetract := stPneumaticActuator.bRetractOK AND stPneumaticActuator.bRetract_SW AND NOT stPneumaticActuator.bInsert_SW ;
stPneumaticActuator.q_bInsert := stPneumaticActuator.bInsertOK AND stPneumaticActuator.bInsert_SW AND NOT stPneumaticActuator.bRetract_SW ;

(*Reset the Control signal when command has been executed and give time to ensure the actuator is fully seated in either direction*)
IF (NOT ibSingleCntrl AND NOT ibCntrlHold) THEN
   IF (stPneumaticActuator.bRetract_SW AND stPneumaticActuator.i_bOutLimitSwitch AND tRetractLimitSwitch.Q ) THEN stPneumaticActuator.q_bRetract := FALSE; END_IF
   IF (stPneumaticActuator.bInsert_SW AND stPneumaticActuator.i_bInLimitSwitch AND tInsertLimitSwitch.Q) THEN stPneumaticActuator.q_bInsert := FALSE; END_IF
END_IF

(*Timers*)
tInserttimeout(IN:= stPneumaticActuator.q_bInsert, PT := tTimeOutDuration );
tRetracttimeout(IN:= stPneumaticActuator.q_bRetract, PT := tTimeOutDuration);
tInsertLimitSwitch(IN:= stPneumaticActuator.i_bInLimitSwitch, PT := tLimitSwitchLatchDuration);
tRetractLimitSwitch(IN:= stPneumaticActuator.i_bOutLimitSwitch, PT := tLimitSwitchLatchDuration);


///Check moving postion timout
IF NOT stPneumaticActuator.i_bInLimitSwitch AND tInserttimeout.Q THEN
    stPneumaticActuator.bError := TRUE;
    stPneumaticActuator.sErrorMessage:= 'Actuator insert timeout';
ELSIF NOT stPneumaticActuator.i_bOutLimitSwitch AND tRetracttimeout.Q THEN
    stPneumaticActuator.bError := TRUE;
    stPneumaticActuator.sErrorMessage:= 'Actuator retract timeout';
END_IF
// Reset error
stPneumaticActuator.bError R= stPneumaticActuator.bReset;

(*FAST FAULT*)
fbFF(i_xOK := xMPS_OK,
    i_xReset := i_xReset,
    io_fbFFHWO := io_fbFFHWO);

(*Soft IO Mapping to Epics pvs*)
ACT_IO();

END_FUNCTION_BLOCK
ACTION ACT_IO:
(*Inputs*)
stPneumaticActuator.i_bInLimitSwitch :=  i_xInsertedLS;
stPneumaticActuator.i_bOutLimitSwitch := i_xRetractedLS;

(*outputs*)
q_xInsert_DO:=stPneumaticActuator.q_bInsert;
q_xRetract_DO:=stPneumaticActuator.q_bRetract;

(*EPICS*)
stPneumaticActuator.bRetractOK := ibRetractOK;
stPneumaticActuator.bInsertOK := ibInsertOK;
END_ACTION
ACTION ACT_Logger:
// Log Valve timeouts
IF (tInserttimeout.Q OR tRetracttimeout.Q) THEN fbLogger(sMsg:=stPneumaticActuator.sErrorMessage, eSevr:=TcEventSeverity.Warning); END_IF

// Log Actuator commands
// Log valve open
tAction(CLK:= (stPneumaticActuator.q_bRetract OR stPneumaticActuator.q_bInsert));
IF tAction.Q THEN
   IF(stPneumaticActuator.q_bRetract) THEN fbLogger(sMsg:='Actuator commanded retract', eSevr:=TcEventSeverity.Info); END_IF
   IF(stPneumaticActuator.q_bInsert) THEN fbLogger(sMsg:='Actuator commanded insert', eSevr:=TcEventSeverity.Info); END_IF
END_IF


// State Logging
IF ePrevState <> stPneumaticActuator.eState THEN
      CASE stPneumaticActuator.eState OF
        ENUM_PnuematicActuatorPositionState.INVALID:
            fbLogger(sMsg:='Actuator invalid position.', eSevr:=TcEventSeverity.Critical);
          ENUM_PnuematicActuatorPositionState.MOVING:
            fbLogger(sMsg:='Actuator moving', eSevr:=TcEventSeverity.Warning);
        ENUM_PnuematicActuatorPositionState.RETRACTED:
            fbLogger(sMsg:='Actuator Retracted.', eSevr:=TcEventSeverity.Info);
        ENUM_PnuematicActuatorPositionState.INSERTED:
            fbLogger(sMsg:='Actuator Inserted.', eSevr:=TcEventSeverity.Info);
      END_CASE
      ePrevState := stPneumaticActuator.eState;
  END_IF
END_ACTION
```


POU: FB_MotionRequest
---------------------

File: Library/POUs/Motion/FB_MotionRequest.TcPOU

```vhdl
FUNCTION_BLOCK FB_MotionRequest
(*
    Request a move from an axis controlled via EPICS using FB_MotionStage
    This exists to manage situations where different bits of code may need to move the same motor.
    With just the DUT_MotionStage/FB_MotionStage setup it is possible for two function blocks to
    fight with and interfere with each other and with the EPICS commands.
*)
VAR_IN_OUT
    // Motor to move
    stMotionStage: DUT_MotionStage;
END_VAR
VAR_INPUT
    // Start move on rising edge, stop move on falling edge
    bExecute: BOOL;
    // Reset errors on rising edge
    bReset: BOOL;
    // Define behavior for when the motor is already moving
    enumMotionRequest: ENUM_MotionRequest := ENUM_MotionRequest.WAIT;
    // Goal position
    fPos: LREAL;
    // Move velocity
    fVel: LREAL;
    // Optional acceleration
    fAcc: LREAL;
    // Optional deceleration
    fDec: LREAL;
END_VAR
VAR_OUTPUT
    // True if in error state
    bError: BOOL;
    // Error code
    nErrorId: UDINT;
    // What the error code means
    sErrorMessage: STRING;
    // If TRUE, we are moving the motor
    bBusy: BOOL;
    // If TRUE, we are not moving the motor and our most recent move was successful
    bDone: BOOL;
END_VAR
VAR
    rtExec: R_TRIG;
    ftExec: F_TRIG;
    rtReset: R_TRIG;
    ftBusy: F_TRIG;
    nState: UINT := 0;
    bMyMove: BOOL;
    bCausedError: BOOL;
END_VAR
// Define local constants for our state machine states
VAR CONSTANT
    INIT: UINT := 0;
    WAIT_EXEC: UINT := 1;
    PICK_REQUEST: UINT := 2;
    WAIT_OTHER_MOVE: UINT := 3;
    STOP_OTHER_MOVE: UINT := 4;
    START_MOVE: UINT := 5;
    WAIT_MY_MOVE: UINT := 6;
    STOP_MY_MOVE: UINT := 7;
    DONE_MOVING: UINT := 8;
    ERROR: UINT := 9;
END_VAR
rtExec(CLK:=bExecute);
ftExec(CLK:=bExecute);
rtReset(CLK:=bReset);

// Go back to INIT state on reset
IF rtReset.Q THEN
    nState := INIT;
    IF bError AND stMotionStage.bError AND bCausedError THEN
        stMotionStage.bReset := TRUE;
    END_IF
END_IF
IF rtExec.Q OR ftExec.Q THEN
    bDone := FALSE;
END_IF

CASE nState OF
    // Start by setting everything to a known value
    INIT:
        nState := WAIT_EXEC;
        bError := FALSE;
        sErrorMessage := '';
        bDone := FALSE;
        bCausedError := FALSE;
    // Normal "waiting for move command" state
    WAIT_EXEC:
        bMyMove := FALSE;
        // Looking for a rising edge on bExecute
        IF rtExec.Q THEN
            bDone := FALSE;
            nState := PICK_REQUEST;
        END_IF
    // Decide how to handle the request
    PICK_REQUEST:
        IF stMotionStage.bBusy THEN
            CASE enumMotionRequest OF
                ENUM_MotionRequest.WAIT:
                    nState := WAIT_OTHER_MOVE;
                ENUM_MotionRequest.INTERRUPT:
                    nState := STOP_OTHER_MOVE;
                ENUM_MotionRequest.ABORT:
                    nState := ERROR;
                    bError := TRUE;
                    nErrorId := 16#7900;
            END_CASE
        ELSE
            nState := START_MOVE;
        END_IF
    // Watch the other move, then see if it's our turn
    WAIT_OTHER_MOVE:
        IF NOT stMotionStage.bBusy THEN
            // Try to pick request again next cycle once the move is over
            nState := PICK_REQUEST;
        END_IF
    // Interrupt the other move, then go to start ours
    STOP_OTHER_MOVE:
        stMotionStage.bExecute := FALSE;
        IF NOT stMotionStage.bBusy THEN
            nState := START_MOVE;
        END_IF
    // Set the correct values on DUT_MotionStage to start a new absolute move
    START_MOVE:
        bMyMove := TRUE;
        stMotionStage.bExecute := TRUE;
        stMotionStage.nCommand := ENUM_EpicsMotorCmd.MOVE_ABSOLUTE;
        stMotionStage.fPosition := fPos;
        stMotionStage.fVelocity := fVel;
        stMotionStage.fAcceleration := fAcc;
        stMotionStage.fDeceleration := fDec;
        nState := WAIT_MY_MOVE;
    // Watch our ongoing move, look for the move to end or requests to stop the move from this FB
    WAIT_MY_MOVE:
        ftBusy(CLK:=stMotionStage.bBusy);
        IF ftBusy.Q THEN
            nState := DONE_MOVING;
        END_IF
        // Implement stop on falling trigger
        IF ftExec.Q THEN
            nState := STOP_MY_MOVE;
        END_IF
    // Request a stop and wait for it to happen
    STOP_MY_MOVE:
        stMotionStage.bExecute := FALSE;
        IF NOT stMotionStage.bBusy THEN
            nState := DONE_MOVING;
        END_IF
    // Pick out the bDone state and return to waiting
    DONE_MOVING:
        bDone := stMotionStage.bDone;
        nState := WAIT_EXEC;
    // Lock us into the error state until the FB is reset
    ERROR:
        bMyMove := FALSE;
END_CASE

// Transition to the ERROR state if applicable
IF bMyMove AND stMotionStage.bError THEN
    nState := ERROR;
    bError := TRUE;
    nErrorId := stMotionStage.nErrorId;
    bCausedError := TRUE;
END_IF
sErrorMessage := F_MotionErrorCodeLookup(nErrorId := nErrorId);

CASE nState OF
INIT, WAIT_EXEC, ERROR:
    bBusy := FALSE;
ELSE
    bBusy := TRUE;
END_CASE

END_FUNCTION_BLOCK
```


POU: FB_MotionStage
-------------------

File: Library/POUs/Motion/FB_MotionStage.TcPOU

```vhdl
FUNCTION_BLOCK FB_MotionStage
(*
    Default implementation for PLC behavior when motor IOC asks for a move
    This can be extended or replaced in your PLC project if you want
    non-default behavior to arise from the motor record processing
*)
VAR_IN_OUT
    stMotionStage: DUT_MotionStage;
END_VAR
VAR
    fbDriveVirtual: FB_DriveVirtual;
    bExecute: BOOL;
    bFwdHit: BOOL;
    bBwdHit: BOOL;
    ftExec: F_TRIG;
    rtExec: R_TRIG;
    rtUserExec: R_TRIG;
    rtTarget: R_TRIG;
    fbSetEnables: FB_SetEnables;
    bPosGoal: BOOL;
    bNegGoal: BOOL;
END_VAR
// Start with an accurate status
stMotionStage.Axis.ReadStatus();

rtUserExec(CLK := stMotionStage.bExecute);
bPosGoal := stMotionStage.stAxisStatus.fActPosition < stMotionStage.fPosition;
bNegGoal := stMotionStage.stAxisStatus.fActPosition > stMotionStage.fPosition;

// Handle auto-enable timing
CASE stMotionStage.nEnableMode OF
    ENUM_StageEnableMode.ALWAYS:
        stMotionStage.bEnable := TRUE;
        bExecute := stMotionStage.bExecute;
    ENUM_StageEnableMode.NEVER:
        bExecute := stMotionStage.bExecute;
    ENUM_StageEnableMode.DURING_MOTION:
        IF rtUserExec.Q THEN
            IF bPosGoal THEN
                IF stMotionStage.bAllForwardEnable THEN
                    stMotionStage.bEnable := TRUE;
                ELSE
                    stMotionStage.bError := TRUE;
                    stMotionStage.nErrorId := 16#4358;
                END_IF
            ELSIF bNegGoal THEN
                IF stMotionStage.bAllBackwardEnable THEN
                    stMotionStage.bEnable := TRUE;
                ELSE
                    stMotionStage.bError := TRUE;
                    stMotionStage.nErrorId := 16#4357;
                END_IF
            END_IF
        END_IF
        bExecute := stMotionStage.bExecute AND stMotionStage.bEnableDone;
END_CASE

// Automatically fill the correct nCmdData for homing
IF stMotionStage.nCommand = ENUM_EpicsMotorCmd.HOME THEN
    stMotionStage.nCmdData := stMotionStage.nHomingMode;
END_IF

// Update all enable booleans
fbSetEnables(stMotionStage:=stMotionStage);

// No moves allowed in error states
IF stMotionStage.bError THEN
    bExecute := FALSE;
END_IF

// Handle standard commands using ESS's FB
fbDriveVirtual(En:=TRUE,
    bEnable:=stMotionStage.bAllEnable,
    bReset:=stMotionStage.bReset,
    bExecute:=bExecute,
    nCommand:=INT_TO_UINT(stMotionStage.nCommand),
    nCmdData:=INT_TO_UINT(stMotionStage.nCmdData),
    fVelocity:=stMotionStage.fVelocity,
    fPosition:=stMotionStage.fPosition,
    fAcceleration:=stMotionStage.fAcceleration,
    fDeceleration:=stMotionStage.fDeceleration,
    bLimitFwd:=stMotionStage.bAllForwardEnable,
    bLimitBwd:=stMotionStage.bAllBackwardEnable,
    bHomeSensor:=stMotionStage.bHome,
    fHomePosition:=stMotionStage.fHomePosition,
    bPowerSelf:=stMotionStage.bPowerSelf,
    nMotionAxisID=>stMotionStage.nMotionAxisID,
    Axis:=stMotionStage.Axis);

// Update status again after the move starts or stops
stMotionStage.Axis.ReadStatus();

// Check for a new error
IF NOT stMotionStage.bError THEN
    stMotionStage.bError := fbDriveVirtual.bError;
    stMotionStage.nErrorId := fbDriveVirtual.nErrorId;
END_IF

// Set the error message if we have one
stMotionStage.sErrorMessage := F_MotionErrorCodeLookup(nErrorId := stMotionStage.nErrorId);

// When we start, set the busy/done appropriately
rtExec(CLK:=bExecute);
IF rtExec.Q THEN
    stMotionStage.bBusy := TRUE;
    stMotionStage.bDone := FALSE;
END_IF

// Force everything off in case of error
IF stMotionStage.bError THEN
    stMotionStage.bBusy := FALSE;
    stMotionStage.bDone := FALSE;
    stMotionStage.bEnable := FALSE;
END_IF

// Check the limits and cancel execution if appropriate. Without this block we have infinite error spam
bFwdHit := stMotionStage.Axis.Status.PositiveDirection AND NOT stMotionStage.bAllForwardEnable;
bBwdHit := stMotionStage.Axis.Status.NegativeDirection AND NOT stMotionStage.bAllBackwardEnable;
IF bFwdHit OR bBwdHit THEN
    stMotionStage.bExecute := FALSE;
END_IF

// Check done moving via fbDriveVirtual and from Target Position Monitoring. Must satisfy both conditions.
ftExec(CLK:=stMotionStage.bExecute);
rtTarget(CLK:=stMotionStage.Axis.Status.InTargetPosition AND fbDriveVirtual.bDone);
IF rtTarget.Q OR ftExec.Q THEN
    IF NOT stMotionStage.bDone THEN
        stMotionStage.bDone := TRUE;
        stMotionStage.bBusy := FALSE;
        IF NOT stMotionStage.Axis.Status.Error THEN
            bExecute := FALSE;
            stMotionStage.bExecute := FALSE;
        END_IF
    END_IF
END_IF

// Handle auto-disable timing
IF stMotionStage.nEnableMode = ENUM_StageEnableMode.DURING_MOTION AND NOT stMotionStage.bExecute THEN
    IF stMotionStage.Axis.Status.MotionState = MC_AXISSTATE_STANDSTILL THEN
        stMotionStage.bEnable := FALSE;
    END_IF
END_IF

// Get a definitive bEnabled reading
CASE stMotionStage.Axis.Status.MotionState OF
    // We are not enabled if there is an issue
    MC_AXISSTATE_UNDEFINED, MC_AXISSTATE_DISABLED, MC_AXISSTATE_ERRORSTOP:
        stMotionStage.bEnableDone := FALSE;
    ELSE
        stMotionStage.bEnableDone := TRUE;
END_CASE

// Handle the brake. TRUE means brake disabled/released
IF stMotionStage.nBrakeMode <> ENUM_StageBrakeMode.NO_BRAKE THEN
    CASE stMotionStage.Axis.Status.MotionState OF
        MC_AXISSTATE_UNDEFINED,
        MC_AXISSTATE_DISABLED,
        MC_AXISSTATE_ERRORSTOP:
            stMotionStage.bBrakeRelease := FALSE;
        MC_AXISSTATE_STANDSTILL:
            IF stMotionStage.nBrakeMode = ENUM_StageBrakeMode.IF_MOVING THEN
                stMotionStage.bBrakeRelease := FALSE;
            ELSE
                stMotionStage.bBrakeRelease := TRUE;
            END_IF
        ELSE
            stMotionStage.bBrakeRelease := TRUE;
    END_CASE
END_IF

// Sync the epics status struct
stMotionStage.stAxisStatus := fbDriveVirtual.stAxisStatus;
stMotionStage.stAxisStatus.bEnabled := stMotionStage.bEnableDone;

// Reset everything when bReset is flagged
IF stMotionStage.bReset THEN
    stMotionStage.bEnable := FALSE;
    stMotionStage.bReset := FALSE;
    stMotionStage.bExecute := FALSE;
    stMotionStage.bError := FALSE;
    stMotionStage.nErrorId := 0;
    stMotionStage.sErrorMessage := '';
    bExecute := FALSE;
END_IF

// Ignore homing if we have the setting for it
// e.g. for pre-calibrated absolute encoders
IF stMotionStage.nHomingMode = ENUM_EpicsHomeCmd.NONE THEN
    stMotionStage.stAxisStatus.bHomed := TRUE;
END_IF

END_FUNCTION_BLOCK
```


POU: FB_MotionStageSim
----------------------

File: Library/POUs/Motion/FB_MotionStageSim.TcPOU

```vhdl
FUNCTION_BLOCK FB_MotionStageSim
(*
    Set all the values needed for a fake motor to be movable
    via the IOC, then call FB_MotionStage
*)
VAR_IN_OUT
    stMotionStage: DUT_MotionStage;
END_VAR
VAR
    fbMotionStage: FB_MotionStage;
    bInit: BOOL;
END_VAR
IF NOT bInit THEN
    bInit := TRUE;
    // Stand-in for no forward limit
    stMotionStage.bLimitForwardEnable := TRUE;
    // Stand-in for no reverse limit
    stMotionStage.bLimitBackwardEnable := TRUE;
    // Stand-in for no STO button
    stMotionStage.bHardwareEnable := TRUE;
    // Stand-in for no PMPS governer
    stMotionStage.bPowerSelf := TRUE;
    // Always keep it enabled for testing ease
    stMotionStage.nEnableMode := ENUM_StageEnableMode.ALWAYS;
END_IF
// Call FB_MotionStage to do the thing
fbMotionStage(stMotionStage := stMotionStage);

END_FUNCTION_BLOCK
```


POU: FB_NcAxis
--------------

File: Library/tc_mca_std_lib/POUs/Motion/FB_NcAxis.TcPOU

```vhdl
///#########################################################
///Function block to communicate between Nc and Plc.
///
///	Library:		
///	Tc2_MC2.lib
///
///	Global Variables:
///	
///	Data types:
///	
///	External functions:
///
///###########################################################
FUNCTION_BLOCK FB_NcAxis
VAR
	sVersion: STRING:='1.0.0';
END_VAR
VAR_INPUT
	En: BOOL;
END_VAR
VAR_OUTPUT
	EnO: BOOL;
	bError: BOOL;
	Status: ST_AxisStatus;
END_VAR
VAR
	Axis: AXIS_REF;
	InfoData_State AT %I*: UINT;
END_VAR
EnO:=En;

IF En AND InfoData_State<>16#8 THEN
	bError:=TRUE;
ELSE
	bError:=FALSE;
END_IF

IF En THEN
	Axis.ReadStatus();
	Status:=Axis.Status;
END_IF

END_FUNCTION_BLOCK
```


POU: FB_PositionStateLock
-------------------------

File: Library/POUs/Motion/States/FB_PositionStateLock.TcPOU

```vhdl
FUNCTION_BLOCK FB_PositionStateLock
(*
    Implements immutability for a locked DUT_PositionState
    Once this is called the first time, the parameters at the time of the call will be restored on all subsequent calls.
*)
VAR_IN_OUT
    stPositionState: DUT_PositionState;
END_VAR
VAR
    stCachedPositionState: DUT_PositionState;
    bInit: BOOL := FALSE;
END_VAR
// Force values to be cached if we've cached something
IF bInit AND stPositionState.bLocked THEN
    stPositionState.sName := stCachedPositionState.sName;
    stPositionState.fPosition := stCachedPositionState.fPosition;
    stPositionState.fDelta := stCachedPositionState.fDelta;
    stPositionState.fVelocity := stCachedPositionState.fVelocity;
    stPositionState.fAccel := stCachedPositionState.fAccel;
    stPositionState.fDecel := stCachedPositionState.fDecel;
// If we haven't cached and we should, make the cache. Note that we skip bLocked, bValid, and bMoveOk
ELSIF NOT bInit AND stPositionState.bLocked THEN
    stCachedPositionState.sName := stPositionState.sName;
    stCachedPositionState.fPosition := stPositionState.fPosition;
    stCachedPositionState.fDelta := stPositionState.fDelta;
    stCachedPositionState.fVelocity := stPositionState.fVelocity;
    stCachedPositionState.fAccel := stPositionState.fAccel;
    stCachedPositionState.fDecel := stPositionState.fDecel;
    bInit := TRUE;
// Do nothing, or unlock the state if bLocked goes FALSE
ELSIF NOT stPositionState.bLocked THEN
    bInit := FALSE;
END_IF

END_FUNCTION_BLOCK
```


POU: FB_PositionStateManager
----------------------------

File: Library/POUs/Motion/States/FB_PositionStateManager.TcPOU

```vhdl
FUNCTION_BLOCK FB_PositionStateManager
(*
    Handles EPICS moves between multiple states for a single axis
    Should be wrapped inside a block with enums for states,
    see FB_EpicsInOut for an example.
*)
VAR_IN_OUT
    // Motor to move
    stMotionStage: DUT_MotionStage;

    // Allocated space for 15 states besides Unknown (16 is the max for an EPICS MBBI)
    {attribute 'pytmc' := '
        pv:
        io: io
        expand: %.2d
    '}
    arrStates: ARRAY[1..15] OF DUT_PositionState;

    // Corresponding arrStates index to move to, or 0 if no move selected
    setState: INT;
END_VAR
VAR_INPUT
    // If TRUE, start a move when setState transitions to a nonzero number
    bEnable: BOOL;
    // On rising edge, reset this FB
    {attribute 'pytmc' := '
        pv: RESET
        io: io
        field: ZNAM False
        field: ONAM True
    '}
    bReset: BOOL;
END_VAR
VAR_OUTPUT
    // If TRUE, there is an error
    {attribute 'pytmc' := '
        pv: ERR
        io: i
        field: ZNAM False
        field: ONAM True
    '}
    bError: BOOL;
    // Error ID
    {attribute 'pytmc' := '
        pv: ERRID
        io: i
    '}
    nErrorId: UDINT;
    // The error that caused bError to flip TRUE
    {attribute 'pytmc' := '
        pv: ERRMSG
        io: i
    '}
    sErrorMessage: STRING;
    // If TRUE, we are moving the motor
    {attribute 'pytmc' := '
        pv: BUSY
        io: i
        field: ZNAM False
        field: ONAM True
    '}
    bBusy: BOOL;
    // If TRUE, we are not moving the motor and the last move completed successfully
    {attribute 'pytmc' := '
        pv: DONE
        io: i
        field: ZNAM False
        field: ONAM True
    '}
    bDone: BOOL;

    // The current position we are trying to reach, or 0
    goalState: INT;
    // The readback position
    getState: INT;
END_VAR
VAR
    bInit: BOOL;
    stUnknown: DUT_PositionState;
    stGoal: DUT_PositionState;
    fbStateMove: FB_PositionStateMove;
    nIndex: INT;
    bNewGoal: BOOL;
    bInnerExec: BOOL;
    bInnerReset: BOOL;
    rtReset: R_TRIG;
    bMoveRequested: BOOL;
END_VAR
// Reset just goes through the first-cycle init again
rtReset(CLK:=bReset);
IF rtReset.Q THEN
    bInit := FALSE;
END_IF

// First-cycle init
IF NOT bInit THEN
    bError := FALSE;
    sErrorMessage := '';
    bBusy := FALSE;
    bDone := FALSE;
    bNewGoal := FALSE;
    bInnerExec := FALSE;
    bInnerReset := TRUE;
    setState := 0;
    goalState := 0;
END_IF

// Check where we are by going through all possible states.
// Note this favors the highest-number state that we're at, it's up to you to make your states mutually exclusive.
getState := 0;
FOR nIndex := 1 TO 15 DO
    IF F_AtPositionState(stMotionStage:=stMotionStage, stPositionState:=arrStates[nIndex]) THEN
        getState := nIndex;
    END_IF
END_FOR

// Use the changing set pv as a rising-edge trigger
IF setState <> goalState THEN
    goalState := setState;
    bNewGoal := TRUE;
END_IF

// Special move handling for error/enable state
IF bError OR NOT bEnable THEN
    bInnerExec := FALSE;
// Reset inner block this cycle if we were already moving but want a new move
ELSIF bInnerExec AND bNewGoal THEN
    bInnerExec := FALSE;
    bInnerReset := TRUE;
// If we hit this branch, we're starting a new move
ELSIF bNewGoal THEN
    bInnerExec := TRUE;
    bInnerReset := FALSE;
    bNewGoal := FALSE;
END_IF

// Pick the correct goal structure or Unknown
IF goalState = 0 THEN
    stGoal := stUnknown;
ELSE
    stGoal := arrStates[goalState];
END_IF

// Do the move
fbStateMove(
    stMotionStage := stMotionStage,
    stPositionState := stGoal,
    bExecute := bInnerExec,
    bReset := bInnerReset,
    enumMotionRequest := ENUM_MotionRequest.INTERRUPT,
    bBusy => bBusy);

// Only pass up bDone information if this FB is active
IF bInnerExec THEN
    bDone := fbStateMove.bDone;
END_IF

// Pick up any new errors, but don't override uncleared existing errors
IF NOT bError THEN
    bError := fbStateMove.bError;
    nErrorId := fbStateMove.nErrorId;
    sErrorMessage := fbStateMove.sErrorMessage;
END_IF

// Reset the setpoint and goal to 0 if we're not doing anything
// because FB is waiting for a change from 0 to "something"
bMoveRequested := bInnerExec AND NOT bDone;
IF NOT bError AND NOT bNewGoal AND NOT bMoveRequested THEN
    setState := 0;
    goalState := 0;
    bInnerExec := FALSE;
END_IF

// Bring inner reset back low at the end of the init cycle so that it can be triggered again later
IF NOT bInit THEN
    bInit := TRUE;
    bInnerReset := FALSE;
END_IF

END_FUNCTION_BLOCK
```


POU: FB_PositionStateMove
-------------------------

File: Library/POUs/Motion/States/FB_PositionStateMove.TcPOU

```vhdl
FUNCTION_BLOCK FB_PositionStateMove
// Request a move to a particular state from an axis controlled via EPICS
// pytmc PVs here only exposed if using directly and not through FB_PositionStateManager
VAR_IN_OUT
    // Motor to move
    stMotionStage: DUT_MotionStage;

    // State to move to
    {attribute 'pytmc' := '
        pv:
    '}
    stPositionState: DUT_PositionState;
END_VAR
VAR_INPUT
    // Start move on rising edge, stop move on falling edge
    {attribute 'pytmc' := '
        pv: GO
        io: io
        field: ZNAM False
        field: ONAM True
    '}
    bExecute: BOOL;

    // Rising edge error reset
    {attribute 'pytmc' := '
        pv: RESET
        io: io
        field: ZNAM False
        field: ONAM True
    '}
    bReset: BOOL;

    // Define behavior for when a move is already active
    enumMotionRequest: ENUM_MotionRequest := ENUM_MotionRequest.WAIT;
END_VAR
VAR_OUTPUT
    // TRUE if the motor is at this state
    {attribute 'pytmc' := '
        pv: AT_STATE
        io: input
        field: ZNAM False
        field: ONAM True
    '}
    bAtState: BOOL;

    // TRUE if we have an error
    {attribute 'pytmc' := '
        pv: ERR
        io: input
        field: ZNAM False
        field: ONAM True
    '}
    bError: BOOL;

    // Error code
    {attribute 'pytmc' := '
        pv: ERRID
        io: input
    '}
    nErrorID: UDINT;

    // Error description
    {attribute 'pytmc' := '
        pv: ERRMSG
        io: input
    '}
    sErrorMessage: STRING;

    // TRUE if we are moving to a state
    {attribute 'pytmc' := '
        pv: BUSY
        io: input
        field: ZNAM False
        field: ONAM True
    '}
    bBusy: BOOL;

    // TRUE if we are note moving and we reached a state successfully on our last move
    {attribute 'pytmc' := '
        pv: DONE
        io: input
        field: ZNAM False
        field: ONAM True
    '}
    bDone: BOOL;
END_VAR
VAR
    fbMotionRequest: FB_MotionRequest;
    bAllowMove: BOOL;
END_VAR
// Veto the move for uninitialized and unsafe states
bAllowMove := stPositionState.bMoveOk AND stPositionState.bValid;

// Do the move
fbMotionRequest(
    stMotionStage := stMotionStage,
    bExecute := bExecute AND bAllowMove,
    bReset := bReset,
    enumMotionRequest := enumMotionRequest,
    fPos := stPositionState.fPosition,
    fVel := stPositionState.fVelocity,
    fAcc := stPositionState.fAccel,
    fDec := stPositionState.fDecel,
    bError => bError,
    nErrorId => nErrorId,
    sErrorMessage => sErrorMessage,
    bBusy => bBusy,
    bDone => bDone);

// Inject custom error if we can't move because of bMoveOk or bValid
IF bExecute AND NOT bAllowMove THEN
    bError := TRUE;
    IF stPositionState.bValid THEN
        nErrorId := 16#7901;
    ELSE
        nErrorId := 16#7902;
    END_IF
    sErrorMessage := F_MotionErrorCodeLookup(nErrorId := nErrorID);
END_IF

// This can be useful if we're running this FB standalone for some reason
bAtState := F_AtPositionState(stMotionStage:=stMotionStage, stPositionState:=stPositionState);

END_FUNCTION_BLOCK
```


POU: FB_ReadFloatParameter
--------------------------

File: Library/tc_mca_std_lib/POUs/ChangeConfig/FB_ReadFloatParameter.TcPOU

```vhdl
FUNCTION_BLOCK FB_ReadFloatParameter
VAR_INPUT
	bExecute: BOOL;
	///16#4000=Axisdata, 16#5000=Encoderdata, 16#6000=Controldata, 16#7000=Drivedata
	nDeviceGroup: UDINT;
	nIndexOffset: UDINT;
END_VAR
VAR_OUTPUT
	nData: LREAL;
	bBusy: BOOL;
	bDone: BOOL;
	bError: BOOL;
	nErrorId: UDINT;
END_VAR
VAR_IN_OUT
	Axis: AXIS_REF;
END_VAR
VAR
	nState: UINT;
	fbADSREAD: ADSREAD;
END_VAR
(*Sequence to read parameter in Nc*)
CASE nState OF
0:  (*Start sequence. Wait until bExecute is TRUE*)
	IF bExecute THEN
		bBusy:=TRUE;
		bError:=FALSE;
		nErrorId:=0;
		nState:=10;
	END_IF

10: (*Read parameter in Nc*)
	fbADSREAD(
		PORT:=500,
		IDXGRP:=nDeviceGroup+Axis.NcToPlc.AxisId,
		IDXOFFS:=nIndexOffset,
		LEN:=SIZEOF(nData),
		DESTADDR:=ADR(nData),
		READ:=TRUE);

	(*Wait until it's done or if an error occurs*)
	IF NOT fbADSREAD.ERR THEN
		IF NOT fbADSREAD.BUSY THEN
			fbADSREAD(READ:=FALSE);
			nState:=20;
		END_IF
	ELSE
		nErrorId:=fbADSREAD.ERRID;
		nState:=999;
	END_IF

20: (*Sequense is done. Waits until bExecute is FALSE*)
	bBusy:=FALSE;
	bDone:=TRUE;
	IF NOT bExecute THEN
		bDone:=FALSE;
		nState:=0;
	END_IF

999: (*Error in sequence*)
	bError:=TRUE;
	bBusy:=FALSE;
	bDone:=FALSE;
	fbADSREAD(READ:=FALSE);
	IF NOT bExecute THEN
		nState:=0;
	END_IF

END_CASE

END_FUNCTION_BLOCK
```


POU: FB_ReadParameterInNc_v1_00
-------------------------------

File: Library/tc_mca_std_lib/POUs/ChangeConfig/FB_ReadParameterInNc_v1_00.TcPOU

```vhdl
///#########################################################
///Function block to read parameter in Nc.
///
///	Library:		
///	Tc2_MC2.lib
/// Tc2_System.lib
///
///	Global Variables:
///	
///	Data types:
///	
///	External functions:
///
///	History:
///	2014-02-05	v1.00	NB	Release code.
///
///	Known bugs:
///
///
///
///###########################################################
FUNCTION_BLOCK FB_ReadParameterInNc_v1_00
VAR_INPUT
	bExecute: BOOL;
	///16#4000=Axisdata, 16#5000=Encoderdata, 16#6000=Controldata, 16#7000=Drivedata
	nDeviceGroup: UDINT;
	nIndexOffset: UDINT;
END_VAR
VAR_OUTPUT
	nData: DWORD;
	bBusy: BOOL;
	bDone: BOOL;
	bError: BOOL;
	nErrorId: UDINT;
END_VAR
VAR_IN_OUT
	Axis: AXIS_REF;
END_VAR
VAR
	nState: UINT;
	fbADSREAD: ADSREAD;
END_VAR
(*Sequence to read parameter in Nc*)
CASE nState OF
0:  (*Start sequence. Wait until bExecute is TRUE*)
	IF bExecute THEN
		bBusy:=TRUE;
		bError:=FALSE;
		nErrorId:=0;
		nState:=10;
	END_IF

10: (*Read parameter in Nc*)
	fbADSREAD(
		PORT:=500,
		IDXGRP:=nDeviceGroup+Axis.NcToPlc.AxisId,
		IDXOFFS:=nIndexOffset,
		LEN:=SIZEOF(nData),
		DESTADDR:=ADR(nData),
		READ:=TRUE);

	(*Wait until it's done or if an error occurs*)
	IF NOT fbADSREAD.ERR THEN
		IF NOT fbADSREAD.BUSY THEN
			fbADSREAD(READ:=FALSE);
			nState:=20;
		END_IF
	ELSE
		nErrorId:=fbADSREAD.ERRID;
		nState:=999;
	END_IF

20: (*Sequense is done. Waits until bExecute is FALSE*)
	bBusy:=FALSE;
	bDone:=TRUE;
	IF NOT bExecute THEN
		bDone:=FALSE;
		nState:=0;
	END_IF

999: (*Error in sequence*)
	bError:=TRUE;
	bBusy:=FALSE;
	bDone:=FALSE;
	fbADSREAD(READ:=FALSE);
	IF NOT bExecute THEN
		nState:=0;
	END_IF

END_CASE

END_FUNCTION_BLOCK
```


POU: FB_SetEnables
------------------

File: Library/POUs/Motion/Utils/FB_SetEnables.TcPOU

```vhdl
FUNCTION_BLOCK FB_SetEnables
// Update the all enable booleans based on the booleans that make them up
VAR_IN_OUT
    stMotionStage: DUT_MotionStage;
END_VAR
stMotionStage.bAllForwardEnable := stMotionStage.bLimitForwardEnable AND (stMotionStage.bGantryForwardEnable OR NOT stMotionStage.bGantryAxis);
stMotionStage.bAllBackwardEnable := stMotionStage.bLimitBackwardEnable AND (stMotionStage.bGantryBackwardEnable OR NOT stMotionStage.bGantryAxis);

stMotionStage.bAllEnable := stMotionStage.bEnable AND stMotionStage.bHardwareEnable;

END_FUNCTION_BLOCK
```


POU: FB_StatePTPMove
--------------------

File: Library/POUs/Deprecated/FB_StatePTPMove.TcPOU

```vhdl
FUNCTION_BLOCK FB_StatePTPMove
// Do not use, this is deprecated
VAR_INPUT
    {attribute 'pytmc' := '
        pv:
    '}
    stPositionState: DUT_PositionState;

    {attribute 'pytmc' := '
        pv: GO
        io: io
        field: ZNAM False
        field: ONAM True
    '}
    bExecute: BOOL;

    bMoveOk: BOOL;
END_VAR
VAR_IN_OUT
    stMotionStage: DUT_MotionStage;
END_VAR
VAR_OUTPUT
    {attribute 'pytmc' := '
        pv: AT_STATE
        io: input
        field: ZNAM False
        field: ONAM True
    '}
    bAtState: BOOL;

    {attribute 'pytmc' := '
        pv: DMOV
        io: input
        field: ZNAM False
        field: ONAM True
    '}
    bDone: BOOL;

    {attribute 'pytmc' := '
        pv: BUSY
        io: input
        field: ZNAM False
        field: ONAM True
    '}
    bBusy: BOOL;

    {attribute 'pytmc' := '
        pv: ERR
        io: input
        field: ZNAM False
        field: ONAM True
    '}
    bError: BOOL;

    {attribute 'pytmc' := '
        pv: ERRMSG
        io: input
    '}
    sError: STRING;
END_VAR
VAR
    bExecTrig: R_TRIG;
    bExecEnd: F_TRIG;
    fActPosition: LREAL;
    fLowPos: LREAL;
    fHighPos: LREAL;
END_VAR
bExecTrig(CLK:=bExecute);
IF bExecTrig.Q AND bMoveOk THEN
    IF NOT stMotionStage.bBusy AND NOT stMotionStage.bError THEN
        stMotionStage.bExecute := TRUE;
        stMotionStage.nCommand := ENUM_EpicsMotorCmd.MOVE_ABSOLUTE;
        stMotionStage.fPosition := stPositionState.fPosition;
        stMotionStage.fVelocity := stPositionState.fVelocity;
        stMotionStage.fAcceleration := stPositionState.fAccel;
        stMotionStage.fDeceleration := stPositionState.fDecel;
        bDone := FALSE;
        bBusy := TRUE;
    END_IF
END_IF
bError := stMotionStage.bError;
sError := stMotionStage.sErrorMessage;

fActPosition := stMotionStage.stAxisStatus.fActPosition;
fLowPos := stPositionState.fPosition - stPositionState.fDelta;
fHighPos := stPositionState.fPosition + stPositionState.fDelta;
IF (fLowPos < fActPosition) AND (fHighPos > fActPosition) THEN
    bAtState := TRUE;
    IF NOT stMotionStage.bBusy THEN
        bDone := TRUE;
        bBusy := FALSE;
        bExecute := FALSE;
    END_IF
ELSE
    bAtState := FALSE;
END_IF

bExecEnd(CLK:=bExecute);
IF bExecEnd.Q AND bBusy THEN
    stMotionStage.bExecute := FALSE;
END_IF

IF NOT stMotionStage.bExecute OR NOT bExecute THEN
    bDone := TRUE;
    bBusy := FALSE;
    bExecute := FALSE;
END_IF

END_FUNCTION_BLOCK
```


POU: FB_TerminalError
---------------------

File: Library/tc_mca_std_lib/POUs/ErrorHandling/FB_TerminalError.TcPOU

```vhdl
FUNCTION_BLOCK FB_TerminalError

VAR_INPUT
	En					: BOOL;
	iTerminal_ID		: INT;
	bWcState			: BOOL;
	uiInfoData_State	: UINT;
	pErrorSystem		: POINTER TO ST_ErrorSystem;					//Pointer to the error system
END_VAR

VAR_OUTPUT
	EnO : BOOL;
	bError : BOOL := FALSE;
END_VAR

VAR
	iStateError : UINT;
	iOtherError : UINT;
	ErrorData	: DUT_TerminalError;
	nErrSysCNT	: UINT;
	
	//testing
	bStateChanged : BOOL;						//Indicate if state change happened
	uiInfoData_State_Prev : UINT := 16#8;		//Previous value of Infodata.State
	bWcState_Prev : BOOL := FALSE;				//Previous state of WcState
	
	//FB-s
	
END_VAR
(*
Currently:

Problem:

TODO:

*)

//Connect EN to EnO
EnO:=En;

//Check if pointer is OK
IF pErrorSystem=0 THEN RETURN; END_IF

//Any difference from normal state creates an error
IF En AND (bWcState OR uiInfoData_State<>16#8) THEN
	bError:=TRUE;
ELSE
	bError:=FALSE;
END_IF

//Change detection
IF uiInfoData_State <> uiInfoData_State_Prev OR bWcState <> bWcState_Prev THEN
	bStateChanged := TRUE;
ELSE
	bStateChanged := FALSE;
END_IF

//Update previous values
uiInfoData_State_Prev := uiInfoData_State;
bWcState_Prev := bWcState;

//Decision tree
IF bStateChanged THEN
	IF bError THEN
		IF ErrorData.ErrorState = DUT_ErrorState.Active THEN
			//Close active error
			//Read system time
			ErrorData.nDateTimeOff := Tc2_EtherCAT.F_GetActualDcTime64();
			ErrorData.sDateTimeOff := Tc2_EtherCat.DCTIME64_TO_STRING(ErrorData.nDateTimeOff);
			ErrorData.ErrorState := DUT_ErrorState.Inactive;
			//Write Off-time to Error System
			FOR nErrSysCNT := 0 TO GVL_ErrorSystem.cSizeOfErrorData - 1 DO
				IF pErrorSystem^.aErrorData[nErrSysCNT].Error_ID = ErrorData.Error_ID THEN
					pErrorSystem^.aErrorData[nErrSysCNT].nDateTimeOff := ErrorData.nDateTimeOff;
					pErrorSystem^.aErrorData[nErrSysCNT].sDateTimeOff := ErrorData.sDateTimeOff;
					pErrorSystem^.aErrorData[nErrSysCNT].ErrorState := DUT_ErrorState.Inactive;
					EXIT;
				END_IF
			END_FOR
				
			//Clear ErrorData
			MEMSET(ADR(ErrorData), 0, SIZEOF(ErrorData));
		END_IF
		
		//Open a new error
		ErrorData.ErrorState := DUT_ErrorState.Active;												//Set Error State
		ErrorData.nDateTimeOn := Tc2_EtherCAT.F_GetActualDcTime64();								//Get system time
		ErrorData.sDateTimeOn := Tc2_EtherCat.DCTIME64_TO_STRING(ErrorData.nDateTimeOn);			//Convert to string
		ErrorData.iTerminalID := iTerminal_ID;														//Terminal_ID
		ErrorData.bWcState := bWcState;																//WcState bit
		ErrorData.uiInfoDataState := uiInfoData_State;												//uiInfoData_State
		
		//Error message according to uiInfoData_State and WcState
		iStateError := (uiInfoData_State AND 16#000F);												//Mask for operation state 
		iOtherError := (uiInfoData_State AND 16#00F0);												//Mask for the other 3 kind of errors
		//Error messages according to the least significant digit
		CASE iStateError OF
			16#0001 : ErrorData.sErrorMessage := 'Slave in INIT state;   ';
			16#0002 : ErrorData.sErrorMessage := 'Slave in PREOP state;   ';
			16#0003 : ErrorData.sErrorMessage := 'Slave in BOOT state;   ';
			16#0004 : ErrorData.sErrorMessage := 'Slave in SAFEOP state;   ';
			16#0008 : ;																			//Normal operation state
		ELSE
			ErrorData.sErrorMessage := 'Undefined State of operation;   ';						//I hope we will never see this message
			ErrorData.sErrorMessage := CONCAT (ErrorData.sErrorMessage, UINT_TO_STRING(iStateError));
			ErrorData.sErrorMessage := CONCAT (ErrorData.sErrorMessage, '   ');
		END_CASE
		
		//Error messages according to the second least significant digit
		CASE iOtherError OF
			16#0000 : ;																			//No error case
			16#0010 : ErrorData.sErrorMessage := CONCAT (ErrorData.sErrorMessage, 'Slave signals error;   ');
			16#0020 : ErrorData.sErrorMessage := CONCAT (ErrorData.sErrorMessage, 'Invalid vendorID/productCode read;   ');
			16#0040 : ErrorData.sErrorMessage := CONCAT (ErrorData.sErrorMessage, 'Initialisation error occured;   ');
		ELSE
			ErrorData.sErrorMessage := CONCAT (ErrorData.sErrorMessage, 'Undefined Error ID: ');
			ErrorData.sErrorMessage := CONCAT (ErrorData.sErrorMessage, UINT_TO_STRING(iOtherError));
			ErrorData.sErrorMessage := CONCAT (ErrorData.sErrorMessage, '   ');
		END_CASE
	
		//Errormessage according to WcState bit
		IF bWcState THEN
			ErrorData.sErrorMessage := CONCAT (ErrorData.sErrorMessage, 'Invalid Data;');
		END_IF
		
		//Check for overflow
		IF pErrorSystem^.nNoErrors = GVL_ErrorSystem.cSizeOfErrorData THEN
			pErrorSystem^.nNoOverflows := pErrorSystem^.nNoOverflows+1;
		END_IF
		
		//Write Error Data into Error System
		ErrorData.Error_ID := pErrorSystem^.lNextErrorID ;
		MEMMOVE( ADR(pErrorSystem^.aErrorData[1]), ADR(pErrorSystem^.aErrorData[0]), (GVL_ErrorSystem.cSizeOfErrorData-1) * SIZEOF(DUT_TerminalError));
		pErrorSystem^.aErrorData[0] := ErrorData;
		pErrorSystem^.lNextErrorID := pErrorSystem^.lNextErrorID+1;
		
	ELSE
		//Close Active Error
		//Read system time
		ErrorData.nDateTimeOff := Tc2_EtherCAT.F_GetActualDcTime64();
		ErrorData.sDateTimeOff := Tc2_EtherCat.DCTIME64_TO_STRING(ErrorData.nDateTimeOff);
		ErrorData.ErrorState := DUT_ErrorState.Inactive;
		
		//Write Off time to Error System
		FOR nErrSysCNT := 0 TO GVL_ErrorSystem.cSizeOfErrorData - 1 DO
			IF pErrorSystem^.aErrorData[nErrSysCNT].Error_ID = ErrorData.Error_ID THEN
				pErrorSystem^.aErrorData[nErrSysCNT].nDateTimeOff := ErrorData.nDateTimeOff;
				pErrorSystem^.aErrorData[nErrSysCNT].sDateTimeOff := ErrorData.sDateTimeOff;
				pErrorSystem^.aErrorData[nErrSysCNT].ErrorState := DUT_ErrorState.Inactive;
				EXIT;
			END_IF
		END_FOR
			
		//Clear ErrorData
		MEMSET(ADR(ErrorData), 0, SIZEOF(ErrorData));
	END_IF
END_IF

END_FUNCTION_BLOCK
```


POU: FB_WriteFloatParameter
---------------------------

File: Library/tc_mca_std_lib/POUs/ChangeConfig/FB_WriteFloatParameter.TcPOU

```vhdl
///#########################################################
///Function block to write parameter in Nc.
///
///	Library:		
///	Tc2_MC2.lib
/// Tc2_System.lib
///
///	Global Variables:
///	
///	Data types:
///	
///	External functions:
///
///	History:
///	2014-02-05	v1.00	NB	Release code.
///
///	Known bugs:
///
///
///
///###########################################################
FUNCTION_BLOCK FB_WriteFloatParameter
VAR_INPUT
	bExecute: BOOL;
	///16#4000=Axisdata, 16#5000=Encoderdata, 16#6000=Controldata, 16#7000=Drivedata
	nDeviceGroup: UDINT;
	nIndexOffset: UDINT;
	nData: LREAL;
END_VAR
VAR_OUTPUT
	bBusy: BOOL;
	bDone: BOOL;
	bError: BOOL;
	nErrorId: UDINT;
END_VAR
VAR_IN_OUT
	Axis: AXIS_REF;
END_VAR
VAR
	nState: UINT;
	fbADSWRITE: ADSWRITE;
END_VAR
(*Sequence to write parameter in Nc*)
CASE nState OF
0:  (*Start sequence. Wait until bExecute is TRUE*)
	IF bExecute THEN
		bBusy:=TRUE;
		bError:=FALSE;
		nErrorId:=0;
		nState:=10;
	END_IF

10: (*Write parameter in Nc*)
	fbADSWRITE(
		PORT:=500,
		IDXGRP:=nDeviceGroup+Axis.NcToPlc.AxisId,
		IDXOFFS:=nIndexOffset,
		LEN:=SIZEOF(nData),
		SRCADDR:=ADR(nData),
		WRITE:=TRUE);

	(*Wait until it's done or if an error occurs*)
	IF NOT fbADSWRITE.ERR THEN
		IF NOT fbADSWRITE.BUSY THEN
			fbADSWRITE(WRITE:=FALSE);
			nState:=20;
		END_IF
	ELSE
		nErrorId:=fbADSWRITE.ERRID;
		nState:=999;
	END_IF

20: (*Sequense is done. Waits until bExecute is FALSE*)
	bBusy:=FALSE;
	bDone:=TRUE;
	IF NOT bExecute THEN
		bDone:=FALSE;
		nState:=0;
	END_IF

999: (*Error in sequence*)
	bError:=TRUE;
	bBusy:=FALSE;
	bDone:=FALSE;
	fbADSWRITE(WRITE:=FALSE);
	IF NOT bExecute THEN
		nState:=0;
	END_IF

END_CASE

END_FUNCTION_BLOCK
```


POU: FB_WriteParameterInNc_v1_00
--------------------------------

File: Library/tc_mca_std_lib/POUs/ChangeConfig/FB_WriteParameterInNc_v1_00.TcPOU

```vhdl
///#########################################################
///Function block to write parameter in Nc.
///
///	Library:		
///	Tc2_MC2.lib
/// Tc2_System.lib
///
///	Global Variables:
///	
///	Data types:
///	
///	External functions:
///
///	History:
///	2014-02-05	v1.00	NB	Release code.
///
///	Known bugs:
///
///
///
///###########################################################
FUNCTION_BLOCK FB_WriteParameterInNc_v1_00
VAR_INPUT
	bExecute: BOOL;
	///16#4000=Axisdata, 16#5000=Encoderdata, 16#6000=Controldata, 16#7000=Drivedata
	nDeviceGroup: UDINT;
	nIndexOffset: UDINT;
	nData: DWORD;
END_VAR
VAR_OUTPUT
	bBusy: BOOL;
	bDone: BOOL;
	bError: BOOL;
	nErrorId: UDINT;
END_VAR
VAR_IN_OUT
	Axis: AXIS_REF;
END_VAR
VAR
	nState: UINT;
	fbADSWRITE: ADSWRITE;
END_VAR
(*Sequence to write parameter in Nc*)
CASE nState OF
0:  (*Start sequence. Wait until bExecute is TRUE*)
	IF bExecute THEN
		bBusy:=TRUE;
		bError:=FALSE;
		nErrorId:=0;
		nState:=10;
	END_IF

10: (*Write parameter in Nc*)
	fbADSWRITE(
		PORT:=500,
		IDXGRP:=nDeviceGroup+Axis.NcToPlc.AxisId,
		IDXOFFS:=nIndexOffset,
		LEN:=SIZEOF(nData),
		SRCADDR:=ADR(nData),
		WRITE:=TRUE);

	(*Wait until it's done or if an error occurs*)
	IF NOT fbADSWRITE.ERR THEN
		IF NOT fbADSWRITE.BUSY THEN
			fbADSWRITE(WRITE:=FALSE);
			nState:=20;
		END_IF
	ELSE
		nErrorId:=fbADSWRITE.ERRID;
		nState:=999;
	END_IF

20: (*Sequense is done. Waits until bExecute is FALSE*)
	bBusy:=FALSE;
	bDone:=TRUE;
	IF NOT bExecute THEN
		bDone:=FALSE;
		nState:=0;
	END_IF

999: (*Error in sequence*)
	bError:=TRUE;
	bBusy:=FALSE;
	bDone:=FALSE;
	fbADSWRITE(WRITE:=FALSE);
	IF NOT bExecute THEN
		nState:=0;
	END_IF

END_CASE

END_FUNCTION_BLOCK
```


POU: F_AtPositionState
----------------------

File: Library/POUs/Motion/States/F_AtPositionState.TcPOU

```vhdl
FUNCTION F_AtPositionState : BOOL
    // Check if the motor is within the state bounds
VAR_INPUT
    stMotionStage: DUT_MotionStage;
    stPositionState: DUT_PositionState;
END_VAR
VAR
END_VAR
F_AtPositionState := FALSE;
// We can never be at invalid states. We are also not at a state if a move has been requested, we are instead transitioning.
IF stPositionState.bValid AND NOT stMotionStage.bExecute THEN
    IF stMotionStage.stAxisStatus.fActPosition < stPositionState.fPosition + ABS(stPositionState.fDelta) AND
       stMotionStage.stAxisStatus.fActPosition > stPositionState.fPosition - ABS(stPositionState.fDelta) THEN
       F_AtPositionState := TRUE;
    END_IF
END_IF

END_FUNCTION
```


POU: F_MotionErrorCodeLookup
----------------------------

File: Library/POUs/Motion/Utils/F_MotionErrorCodeLookup.TcPOU

```vhdl
FUNCTION F_MotionErrorCodeLookup : STRING
VAR_INPUT
    nErrorId: UDINT;
END_VAR
VAR
    msg: STRING;
END_VAR
CASE nErrorId OF
    // Common NC errors
    16#4221: msg:='Requested set velocity is not allowed';
    16#4222: msg:='Requested set position is not allowed';
    16#4225: msg:='Drive not ready during axis start';
    16#4260: msg:='Drive disabled';
    16#4357: msg:='Negative limit hit';
    16#4358: msg:='Positive limit hit';
    16#4550: msg:='Stall: position lag monitoring error';

    // Custom error definitions
    16#7900: msg:='Aborted move request with active move in progress';
    16#7901: msg:='Position state unsafe';
    16#7902: msg:='Position state invalid';

    // Fallbacks
    0: msg:='';
    ELSE
        msg:='Contact PCDS to add new message';
END_CASE
F_MotionErrorCodeLookup := msg;

END_FUNCTION
```


POU: Interactive
----------------

File: Library/UnitTests/Interactive.TcPOU

```vhdl
PROGRAM Interactive
VAR
    bInit: BOOL := FALSE;

    M1: DUT_MotionStage;
    fbMotionStageSim: FB_MotionStageSim;
    nCounter: UINT;

    stOut: DUT_PositionState;
    fbGoOut: FB_PositionStateMove;
    bOut: BOOL;
    bGoOut: BOOL;
    stIn: DUT_PositionState;
    fbGoIn: FB_PositionStateMove;
    bIn: BOOL;
    bGoIn: BOOL;
    stUnsafe: DUT_PositionState;
    fbGoBad: FB_PositionStateMove;
    bHCF: BOOL;
    bGoHCF: BOOL;

    {attribute 'pytmc' := '
        pv: TST:STATE
        io: io
    '}
    fbEpicsInOut: FB_EpicsInOut;

    fbStateManager: FB_PositionStateManager;
    setState: INT;
    arrStates: ARRAY [1..15] OF DUT_PositionState;
END_VAR
BasicTests();

fbMotionStageSim(stMotionStage:=M1);
nCounter := nCounter + 1;

IF NOT bInit THEN
    bInit := TRUE;

    stOut.sName := 'Out';
    stOut.fPosition := 100;
    stOut.fDelta := 20;
    stOut.fVelocity := 10;
    stOut.bValid := TRUE;
    stOut.bMoveOk := TRUE;

    stIn.sName := 'In';
    stIn.fPosition := 0;
    stIn.fDelta := 0.1;
    stIn.fVelocity := 5;
    stIn.bValid := TRUE;
    stIn.bMoveOk := TRUE;

    stUnsafe.sName := 'HCF';
    stUnsafe.fPosition := -999;
    stUnsafe.fDelta := 6;
    stUnsafe.fVelocity := 42;
    stUnsafe.bValid := TRUE;
    stUnsafe.bMoveOk := FALSE;

    fbEpicsInOut.bEnable := TRUE;
    fbStateManager.bEnable := TRUE;
END_IF

fbGoOut(
    bExecute:=bGoOut,
    stMotionStage:=M1,
    stPositionState:=stOut,
    bAtState=>bOut);
fbGoIn(
    bExecute:=bGoIn,
    stMotionStage:=M1,
    stPositionState:=stIn,
    bAtState=>bIn);
fbGoBad(
    bExecute:=bGoHCF,
    stMotionStage:=M1,
    stPositionState:=stUnsafe,
    bAtState=>bHCF);

arrStates[1] := stOut;
arrStates[2] := stIn;
arrStates[3] := stUnsafe;

fbEpicsInOut(
    stMotionStage := M1,
    stOut := stOut,
    stIn := stIn);

fbStateManager(
    stMotionStage := M1,
    arrStates := arrStates,
    setState := setState);

END_PROGRAM
```


Symbols
-------

    BasicTests.Motor : DUT_MotionStage (4546112 11264)
    BasicTests.Motor.Axis.NcToPlc : NCTOPLC_AXIS_REF (4547200 2048)
    BasicTests.Motor.Axis.PlcToNc : PLCTONC_AXIS_REF (4546176 1024)
    BasicTests.Motor.bBrakeRelease : BOOL (4555160 8)
    BasicTests.Motor.bHardwareEnable : BOOL (4555168 8)
    BasicTests.Motor.bHome : BOOL (4555152 8)
    BasicTests.Motor.bLimitBackwardEnable : BOOL (4555144 8)
    BasicTests.Motor.bLimitForwardEnable : BOOL (4555136 8)
    BasicTests.bError : BOOL (4323376 8)
    BasicTests.errState : Tc2_MC2.MC_AxisStates (4711680 16)
    BasicTests.fbMotion : FB_MotionStageSim (4557376 152704)
    BasicTests.fbMotion.fbMotionStage.fbDriveVirtual.MasterAxis.NcToPlc : NCTOPLC_AXIS_REF (4559936 2048)
    BasicTests.fbMotion.fbMotionStage.fbDriveVirtual.MasterAxis.PlcToNc : PLCTONC_AXIS_REF (4558912 1024)
    BasicTests.fbRequest : FB_MotionRequest (4710080 1600)
    Constants.CompilerVersion : VERSION (4714576 64)
    Constants.CompilerVersionNumeric : DWORD (4714720 32)
    Constants.RuntimeVersion : VERSION (4714512 64)
    Constants.RuntimeVersionNumeric : DWORD (4714688 32)
    Constants.bFPUSupport : BOOL (4714672 8)
    Constants.bLittleEndian : BOOL (4714496 8)
    Constants.bSimulationMode : BOOL (4714504 8)
    Constants.nPackMode : UINT (4714656 16)
    Constants.nRegisterSize : WORD (4714640 16)
    GVL.nHomingError : UDINT (4714464 32)
    GVL_ErrorSystem.cSizeOfErrorData : UINT (4711696 16)
    Global_Variables.ADSIGRP_DEVICE_DATA : UDINT (4097664 32)
    Global_Variables.ADSIGRP_IOIMAGE_CLEARI : UDINT (4097568 32)
    Global_Variables.ADSIGRP_IOIMAGE_CLEARO : UDINT (4097600 32)
    Global_Variables.ADSIGRP_IOIMAGE_RISIZE : UDINT (4097440 32)
    Global_Variables.ADSIGRP_IOIMAGE_ROSIZE : UDINT (4097536 32)
    Global_Variables.ADSIGRP_IOIMAGE_RWIB : UDINT (4097376 32)
    Global_Variables.ADSIGRP_IOIMAGE_RWIOB : UDINT (4097632 32)
    Global_Variables.ADSIGRP_IOIMAGE_RWIX : UDINT (4097408 32)
    Global_Variables.ADSIGRP_IOIMAGE_RWOB : UDINT (4097472 32)
    Global_Variables.ADSIGRP_IOIMAGE_RWOX : UDINT (4097504 32)
    Global_Variables.ADSIGRP_SYMNAME : UDINT (4096960 32)
    Global_Variables.ADSIGRP_SYMNOTE : UDINT (4097344 32)
    Global_Variables.ADSIGRP_SYMTAB : UDINT (4096928 32)
    Global_Variables.ADSIGRP_SYMVAL : UDINT (4096992 32)
    Global_Variables.ADSIGRP_SYM_DOWNLOAD : UDINT (4097248 32)
    Global_Variables.ADSIGRP_SYM_HNDBYNAME : UDINT (4097024 32)
    Global_Variables.ADSIGRP_SYM_INFOBYNAME : UDINT (4097152 32)
    Global_Variables.ADSIGRP_SYM_INFOBYNAMEEX : UDINT (4097216 32)
    Global_Variables.ADSIGRP_SYM_RELEASEHND : UDINT (4097120 32)
    Global_Variables.ADSIGRP_SYM_UPLOAD : UDINT (4097280 32)
    Global_Variables.ADSIGRP_SYM_UPLOADINFO : UDINT (4097312 32)
    Global_Variables.ADSIGRP_SYM_VALBYHND : UDINT (4097088 32)
    Global_Variables.ADSIGRP_SYM_VALBYNAME : UDINT (4097056 32)
    Global_Variables.ADSIGRP_SYM_VERSION : UDINT (4097184 32)
    Global_Variables.ADSIOFFS_DEVDATA_ADSSTATE : UDINT (4097696 32)
    Global_Variables.ADSIOFFS_DEVDATA_DEVSTATE : UDINT (4097728 32)
    Global_Variables.ADSLOG_MSGTYPE_ERROR : DWORD (4098784 32)
    Global_Variables.ADSLOG_MSGTYPE_HINT : DWORD (4098720 32)
    Global_Variables.ADSLOG_MSGTYPE_LOG : DWORD (4098816 32)
    Global_Variables.ADSLOG_MSGTYPE_MSGBOX : DWORD (4098848 32)
    Global_Variables.ADSLOG_MSGTYPE_RESOURCE : DWORD (4098880 32)
    Global_Variables.ADSLOG_MSGTYPE_STRING : DWORD (4098912 32)
    Global_Variables.ADSLOG_MSGTYPE_WARN : DWORD (4098752 32)
    Global_Variables.ADSSTATE_CONFIG : UINT (4096832 16)
    Global_Variables.ADSSTATE_ERROR : UINT (4096768 16)
    Global_Variables.ADSSTATE_EXCEPTION : UINT (4096896 16)
    Global_Variables.ADSSTATE_IDLE : UINT (4096608 16)
    Global_Variables.ADSSTATE_INCOMPATIBLE : UINT (4096880 16)
    Global_Variables.ADSSTATE_INIT : UINT (4096640 16)
    Global_Variables.ADSSTATE_INVALID : UINT (4096592 16)
    Global_Variables.ADSSTATE_LOADCFG : UINT (4096720 16)
    Global_Variables.ADSSTATE_MAXSTATES : UINT (4096912 16)
    Global_Variables.ADSSTATE_POWERFAILURE : UINT (4096736 16)
    Global_Variables.ADSSTATE_POWERGOOD : UINT (4096752 16)
    Global_Variables.ADSSTATE_RECONFIG : UINT (4096848 16)
    Global_Variables.ADSSTATE_RESET : UINT (4096624 16)
    Global_Variables.ADSSTATE_RESUME : UINT (4096816 16)
    Global_Variables.ADSSTATE_RUN : UINT (4096672 16)
    Global_Variables.ADSSTATE_SAVECFG : UINT (4096704 16)
    Global_Variables.ADSSTATE_SHUTDOWN : UINT (4096784 16)
    Global_Variables.ADSSTATE_START : UINT (4096656 16)
    Global_Variables.ADSSTATE_STOP : UINT (4096688 16)
    Global_Variables.ADSSTATE_STOPPING : UINT (4096864 16)
    Global_Variables.ADSSTATE_SUSPEND : UINT (4096800 16)
    Global_Variables.AMSLOGGER_IGR_GENERAL : UDINT (4164512 32)
    Global_Variables.AMSLOGGER_IOF_MODE : UDINT (4164544 32)
    Global_Variables.AMSPORT_AMSLOGGER : UINT (4163248 16)
    Global_Variables.AMSPORT_EVENTLOG : UINT (4096304 16)
    Global_Variables.AMSPORT_LOGGER : UINT (4096288 16)
    Global_Variables.AMSPORT_R0_CAM : UINT (4096528 16)
    Global_Variables.AMSPORT_R0_CAMTOOL : UINT (4096544 16)
    Global_Variables.AMSPORT_R0_CNC : UINT (4096416 16)
    Global_Variables.AMSPORT_R0_IO : UINT (4096336 16)
    Global_Variables.AMSPORT_R0_ISG : UINT (4096400 16)
    Global_Variables.AMSPORT_R0_LINE : UINT (4096432 16)
    Global_Variables.AMSPORT_R0_NC : UINT (4096352 16)
    Global_Variables.AMSPORT_R0_NCSAF : UINT (4096368 16)
    Global_Variables.AMSPORT_R0_NCSVB : UINT (4096384 16)
    Global_Variables.AMSPORT_R0_PLC : UINT (4096448 16)
    Global_Variables.AMSPORT_R0_PLC_RTS1 : UINT (4096464 16)
    Global_Variables.AMSPORT_R0_PLC_RTS2 : UINT (4096480 16)
    Global_Variables.AMSPORT_R0_PLC_RTS3 : UINT (4096496 16)
    Global_Variables.AMSPORT_R0_PLC_RTS4 : UINT (4096512 16)
    Global_Variables.AMSPORT_R0_RTIME : UINT (4096320 16)
    Global_Variables.AMSPORT_R3_SCOPESERVER : UINT (4096576 16)
    Global_Variables.AMSPORT_R3_SYSSERV : UINT (4096560 16)
    Global_Variables.BOOTDATAFLAGS_PERSISTENT_INVALID : BYTE (4098976 8)
    Global_Variables.BOOTDATAFLAGS_PERSISTENT_LOADED : BYTE (4098968 8)
    Global_Variables.BOOTDATAFLAGS_RETAIN_INVALID : BYTE (4098952 8)
    Global_Variables.BOOTDATAFLAGS_RETAIN_LOADED : BYTE (4098944 8)
    Global_Variables.BOOTDATAFLAGS_RETAIN_REQUESTED : BYTE (4098960 8)
    Global_Variables.DATE_AND_TIME_SECPERDAY : DWORD (4177472 32)
    Global_Variables.DATE_AND_TIME_SECPERWEEK : DWORD (4177504 32)
    Global_Variables.DBG_OUTPUT_FILE : DWORD (4183776 32)
    Global_Variables.DBG_OUTPUT_LOG : DWORD (4183744 32)
    Global_Variables.DBG_OUTPUT_NONE : DWORD (4183712 32)
    Global_Variables.DBG_OUTPUT_VISU : DWORD (4183808 32)
    Global_Variables.DEFAULT_ADS_TIMEOUT : TIME (4099712 32)
    Global_Variables.DEFAULT_BACKLASHVALUE : LREAL (4310848 64)
    Global_Variables.DEFAULT_CSV_FIELD_DOUBLE_QUOTE : BYTE (4300976 8)
    Global_Variables.DEFAULT_CSV_FIELD_SEP : BYTE (4101240 8)
    Global_Variables.DEFAULT_CSV_RECORD_SEP_CR : BYTE (4300984 8)
    Global_Variables.DEFAULT_CSV_RECORD_SEP_LF : BYTE (4300992 8)
    Global_Variables.DEFAULT_HOME_POSITION : LREAL (4310784 64)
    Global_Variables.EMPTY_ARG_VALUE : Tc2_Utilities.T_Arg (4165120 96)
    Global_Variables.EMPTY_GUID_REGSTRING : STRING(38) (4303176 312)
    Global_Variables.EMPTY_GUID_STRING : STRING(36) (4302880 296)
    Global_Variables.EMPTY_GUID_STRUCT : GUID (4302752 128)
    Global_Variables.EMPTY_ROUTE_ENTRY : Tc2_Utilities.ST_AmsRouteEntry (4163264 1184)
    Global_Variables.FLOATREC_EXP_IS_INF : INT (4164608 16)
    Global_Variables.FLOATREC_EXP_IS_NAN : INT (4164592 16)
    Global_Variables.FLOATREC_MAX_DIGITS : INT (4164624 16)
    Global_Variables.FLOATREC_MAX_PRECISION : INT (4164640 16)
    Global_Variables.FLOATREC_MIN_PRECISION : INT (4164656 16)
    Global_Variables.FMTERR_ARGTYPEINVALID : DWORD (4164960 32)
    Global_Variables.FMTERR_ASTERISKPOSITION : DWORD (4164736 32)
    Global_Variables.FMTERR_DESTBUFFOVERFLOW : DWORD (4165056 32)
    Global_Variables.FMTERR_FLAGPOSITION : DWORD (4164832 32)
    Global_Variables.FMTERR_INSUFFICIENTARGS : DWORD (4165024 32)
    Global_Variables.FMTERR_INVALIDPOINTERINPUT : DWORD (4165088 32)
    Global_Variables.FMTERR_NOERROR : DWORD (4164672 32)
    Global_Variables.FMTERR_PERCENTSIGNPOSITION : DWORD (4164704 32)
    Global_Variables.FMTERR_PRECISIONDOTPOSITION : DWORD (4164896 32)
    Global_Variables.FMTERR_PRECISIONVALUE : DWORD (4164800 32)
    Global_Variables.FMTERR_TYPEFIELDVALUE : DWORD (4164928 32)
    Global_Variables.FMTERR_UNACCEPTEDPARAMETER : DWORD (4164992 32)
    Global_Variables.FMTERR_WIDTHPRECISIONVALPOS : DWORD (4164864 32)
    Global_Variables.FMTERR_WIDTHVALUE : DWORD (4164768 32)
    Global_Variables.FOPEN_MODEAPPEND : DWORD (4099072 32)
    Global_Variables.FOPEN_MODEBINARY : DWORD (4099136 32)
    Global_Variables.FOPEN_MODEPLUS : DWORD (4099104 32)
    Global_Variables.FOPEN_MODEREAD : DWORD (4099008 32)
    Global_Variables.FOPEN_MODETEXT : DWORD (4099168 32)
    Global_Variables.FOPEN_MODEWRITE : DWORD (4099040 32)
    Global_Variables.FORMAT_DECASC_CODES : ARRAY[0..9] OF BYTE (4165472 80)
    Global_Variables.FORMAT_HEXASC_CODES : ARRAY[0..1] OF BYTE (4165216 256)
    Global_Variables.FORMAT_MAX_ARGS : INT (4164576 16)
    Global_Variables.GLOBAL_DCF77_PULSE_SPLIT : TIME (4101248 32)
    Global_Variables.GLOBAL_DCF77_SEQUENCE_CHECK : BOOL (4101232 8)
    Global_Variables.GLOBAL_FORMAT_HASH_PREFIX_TYPE : Tc2_Utilities.E_HashPrefixTypes (4101200 16)
    Global_Variables.GLOBAL_SBCS_TABLE : Tc2_Utilities.E_SBCSType (4101216 16)
    Global_Variables.HKEY_MAX_BINARY_DATA_SIZE : UDINT (4164480 32)
    Global_Variables.IPHELPERAPI_ADAPTERSINFO : UDINT (4162912 32)
    Global_Variables.IPHELPERAPI_IPADDRBYHOSTNAME : UDINT (4162944 32)
    Global_Variables.MAX_ADAPTER_ADDRESS_LENGTH : UDINT (4162816 32)
    Global_Variables.MAX_ADAPTER_DESCRIPTION_LENGTH : UDINT (4162784 32)
    Global_Variables.MAX_ADAPTER_NAME_LENGTH : UDINT (4162752 32)
    Global_Variables.MAX_AVERAGE_MEASURES : INT (4101184 16)
    Global_Variables.MAX_LOCAL_ADAPTERS : UDINT (4162976 32)
    Global_Variables.MAX_REMOTE_PCS : INT (4163104 16)
    Global_Variables.MAX_ROUTE_ADDR_LEN : BYTE (4163128 8)
    Global_Variables.MAX_ROUTE_NAME_LEN : BYTE (4163120 8)
    Global_Variables.MAX_ROUTE_TRANSPORT : BYTE (4163240 8)
    Global_Variables.MAX_STRING_LENGTH : UDINT (4099744 32)
    Global_Variables.MIN_ROUTE_TRANSPORT : BYTE (4163232 8)
    Global_Variables.PI : LREAL (4099648 64)
    Global_Variables.ROUTE_FLAG_DYNAMIC : DWORD (4163168 32)
    Global_Variables.ROUTE_FLAG_NOOVERRIDE : DWORD (4163200 32)
    Global_Variables.ROUTE_FLAG_TEMPORARY : DWORD (4163136 32)
    Global_Variables.SYSTEMSERVICE_ADDREMOTE : UDINT (4163008 32)
    Global_Variables.SYSTEMSERVICE_CHANGENETID : UDINT (4098528 32)
    Global_Variables.SYSTEMSERVICE_CLOSEHANDLE : UDINT (4097888 32)
    Global_Variables.SYSTEMSERVICE_CREATEFILE : UDINT (4097856 32)
    Global_Variables.SYSTEMSERVICE_DELREMOTE : UDINT (4163040 32)
    Global_Variables.SYSTEMSERVICE_ENUMREMOTE : UDINT (4163072 32)
    Global_Variables.SYSTEMSERVICE_FCLOSE : UDINT (4097952 32)
    Global_Variables.SYSTEMSERVICE_FDELETE : UDINT (4098272 32)
    Global_Variables.SYSTEMSERVICE_FEOF : UDINT (4098240 32)
    Global_Variables.SYSTEMSERVICE_FFILEFIND : UDINT (4164448 32)
    Global_Variables.SYSTEMSERVICE_FGETS : UDINT (4098112 32)
    Global_Variables.SYSTEMSERVICE_FOPEN : UDINT (4097920 32)
    Global_Variables.SYSTEMSERVICE_FPRINTF : UDINT (4098208 32)
    Global_Variables.SYSTEMSERVICE_FPUTS : UDINT (4098144 32)
    Global_Variables.SYSTEMSERVICE_FREAD : UDINT (4097984 32)
    Global_Variables.SYSTEMSERVICE_FRENAME : UDINT (4098304 32)
    Global_Variables.SYSTEMSERVICE_FSCANF : UDINT (4098176 32)
    Global_Variables.SYSTEMSERVICE_FSEEK : UDINT (4098048 32)
    Global_Variables.SYSTEMSERVICE_FTELL : UDINT (4098080 32)
    Global_Variables.SYSTEMSERVICE_FWRITE : UDINT (4098016 32)
    Global_Variables.SYSTEMSERVICE_IPHELPERAPI : UDINT (4162848 32)
    Global_Variables.SYSTEMSERVICE_IPHOSTNAME : UDINT (4162880 32)
    Global_Variables.SYSTEMSERVICE_MKDIR : UDINT (4098336 32)
    Global_Variables.SYSTEMSERVICE_OPENCREATE : UDINT (4097760 32)
    Global_Variables.SYSTEMSERVICE_OPENREAD : UDINT (4097792 32)
    Global_Variables.SYSTEMSERVICE_OPENWRITE : UDINT (4097824 32)
    Global_Variables.SYSTEMSERVICE_REG_HKEYLOCALMACHINE : UDINT (4098400 32)
    Global_Variables.SYSTEMSERVICE_RMDIR : UDINT (4098368 32)
    Global_Variables.SYSTEMSERVICE_SENDEMAIL : UDINT (4098432 32)
    Global_Variables.SYSTEMSERVICE_STARTPROCESS : UDINT (4098496 32)
    Global_Variables.SYSTEMSERVICE_TIMESERVICES : UDINT (4098464 32)
    Global_Variables.SYSTEMSTATEFLAGS_BSOD : BYTE (4098984 8)
    Global_Variables.SYSTEMSTATEFLAGS_RTVIOLATION : BYTE (4098992 8)
    Global_Variables.SYSTEMTIME_DATEDELTA_OFFSET : DWORD (4171808 32)
    Global_Variables.SYSTEMTIME_DATE_AND_TIME_MAX : Tc2_Utilities.T_ULARGE_INTEGER (4172096 64)
    Global_Variables.SYSTEMTIME_DATE_AND_TIME_MAX64 : ULINT (4172416 64)
    Global_Variables.SYSTEMTIME_DATE_AND_TIME_MIN : Tc2_Utilities.T_ULARGE_INTEGER (4172032 64)
    Global_Variables.SYSTEMTIME_DATE_AND_TIME_MIN64 : ULINT (4172352 64)
    Global_Variables.SYSTEMTIME_MAX_MONTHDAYS : ARRAY[0..1] OF WORD (4170960 384)
    Global_Variables.SYSTEMTIME_MAX_YEARSDAY : ARRAY[0..1] OF WORD (4171344 448)
    Global_Variables.SYSTEMTIME_TICKSPERDAY : Tc2_Utilities.T_ULARGE_INTEGER (4171968 64)
    Global_Variables.SYSTEMTIME_TICKSPERDAY64 : ULINT (4172288 64)
    Global_Variables.SYSTEMTIME_TICKSPERMSEC : Tc2_Utilities.T_ULARGE_INTEGER (4171840 64)
    Global_Variables.SYSTEMTIME_TICKSPERMSEC64 : ULINT (4172160 64)
    Global_Variables.SYSTEMTIME_TICKSPERSEC : Tc2_Utilities.T_ULARGE_INTEGER (4171904 64)
    Global_Variables.SYSTEMTIME_TICKSPERSEC64 : ULINT (4172224 64)
    Global_Variables.TCEVENTFLAG_AUTOFMTALL : WORD (4099504 16)
    Global_Variables.TCEVENTFLAG_FMTSELF : WORD (4099440 16)
    Global_Variables.TCEVENTFLAG_LOG : WORD (4099456 16)
    Global_Variables.TCEVENTFLAG_MSGBOX : WORD (4099472 16)
    Global_Variables.TCEVENTFLAG_PRIOCLASS : WORD (4099424 16)
    Global_Variables.TCEVENTFLAG_SRCID : WORD (4099488 16)
    Global_Variables.TCEVENTSTATE_CONFIRMED : WORD (4099568 16)
    Global_Variables.TCEVENTSTATE_INVALID : WORD (4099520 16)
    Global_Variables.TCEVENTSTATE_RESET : WORD (4099552 16)
    Global_Variables.TCEVENTSTATE_RESETCON : WORD (4099584 16)
    Global_Variables.TCEVENTSTATE_SIGNALED : WORD (4099536 16)
    Global_Variables.TCEVENT_FMTPRGSIZE : INT (4099616 16)
    Global_Variables.TCEVENT_SRCNAMESIZE : INT (4099600 16)
    Global_Variables.TIMESERVICE_ADJUSTTIMETORTC : UDINT (4098656 32)
    Global_Variables.TIMESERVICE_DATEANDTIME : UDINT (4098560 32)
    Global_Variables.TIMESERVICE_RTCTIMEDIFF : UDINT (4098624 32)
    Global_Variables.TIMESERVICE_SYSTEMTIMES : UDINT (4098592 32)
    Global_Variables.TIMESERVICE_TIMEZONINFORMATION : UDINT (4098688 32)
    Global_Variables.TcMcGlobal : Tc2_MC2._TCMCGLOBAL (4303776 6976)
    Global_Variables.WEST_EUROPE_TZI : Tc2_Utilities.ST_TimeZoneInformation (4172480 864)
    Global_Variables.eWatchdogConfig : Tc2_System.E_WATCHDOG_TIME_CONFIG (4099632 16)
    Global_Variables.nWatchdogTime : BYTE (4099000 8)
    Global_Version.stLibVersion_Tc2_MC2 : ST_LibVersion (4303488 288)
    Global_Version.stLibVersion_Tc2_Math : ST_LibVersion (4310912 288)
    Global_Version.stLibVersion_Tc2_System : ST_LibVersion (4096000 288)
    Global_Version.stLibVersion_Tc2_Utilities : ST_LibVersion (4100896 288)
    Global_Version.stLibVersion_Tc3_Module : ST_LibVersion (4100288 288)
    Global_Version.stLibVersion_lcls_twincat_motion : ST_LibVersion (4714176 288)
    Interactive.M1 : DUT_MotionStage (4323392 11264)
    Interactive.M1.Axis.NcToPlc : NCTOPLC_AXIS_REF (4324480 2048)
    Interactive.M1.Axis.PlcToNc : PLCTONC_AXIS_REF (4323456 1024)
    Interactive.M1.bBrakeRelease : BOOL (4332440 8)
    Interactive.M1.bHardwareEnable : BOOL (4332448 8)
    Interactive.M1.bHome : BOOL (4332432 8)
    Interactive.M1.bLimitBackwardEnable : BOOL (4332424 8)
    Interactive.M1.bLimitForwardEnable : BOOL (4332416 8)
    Interactive.arrStates : ARRAY[1..15] OF DUT_PositionState (4529792 16320)
    Interactive.bGoHCF : BOOL (4310776 8)
    Interactive.bGoIn : BOOL (4310760 8)
    Interactive.bGoOut : BOOL (4302744 8)
    Interactive.bHCF : BOOL (4310768 8)
    Interactive.bIn : BOOL (4310752 8)
    Interactive.bInit : BOOL (4301032 8)
    Interactive.bOut : BOOL (4302736 8)
    Interactive.fbEpicsInOut : FB_EpicsInOut (4498304 25600)
    Interactive.fbGoBad : FB_PositionStateMove (4495744 2560)
    Interactive.fbGoIn : FB_PositionStateMove (4492096 2560)
    Interactive.fbGoOut : FB_PositionStateMove (4488448 2560)
    Interactive.fbMotionStageSim : FB_MotionStageSim (4334656 152704)
    Interactive.fbMotionStageSim.fbMotionStage.fbDriveVirtual.MasterAxis.NcToPlc : NCTOPLC_AXIS_REF (4337216 2048)
    Interactive.fbMotionStageSim.fbMotionStage.fbDriveVirtual.MasterAxis.PlcToNc : PLCTONC_AXIS_REF (4336192 1024)
    Interactive.fbStateManager : FB_PositionStateManager (4523904 5888)
    Interactive.nCounter : UINT (4301040 16)
    Interactive.setState : INT (4323360 16)
    Interactive.stIn : DUT_PositionState (4491008 1088)
    Interactive.stOut : DUT_PositionState (4487360 1088)
    Interactive.stUnsafe : DUT_PositionState (4494656 1088)
    TwinCAT_SystemInfoVarList._AppInfo : PlcAppSystemInfo (4714752 2048)
    TwinCAT_SystemInfoVarList._TaskInfo : ARRAY[1..1] OF PlcTaskSystemInfo (4716800 1024)
    TwinCAT_SystemInfoVarList._TaskOid_PlcTask : OTCID (4717856 32)
    TwinCAT_SystemInfoVarList._TaskPouOid_PlcTask : OTCID (4717824 32)
    TwinCAT_SystemInfoVarList.__PlcTask : _Implicit_Task_Info (4717888 704)

Boxes
-----

NC axes
-------

    4.) 'Library 1':
        Id = 4
        CreateSymbols = 'true'
        AxisType = 1
        AxisFolder = 'Library Axes'
        OtherSettings:AllowMotionCmdToSlave = 'true'
        Enc:EncType = 1

    5.) 'Library 2':
        Id = 5
        CreateSymbols = 'true'
        AxisType = 1
        AxisFolder = 'Library Axes'
        OtherSettings:AllowMotionCmdToSlave = 'true'
        Enc:EncType = 1

Links
-----

    1.) A ('Library Instance', 'PlcTask Inputs^Interactive.M1.Axis.NcToPlc')
          B ('TINC^NC-Task 1 SAF^Axes^Library 1', 'Outputs^ToPlc')
    2.) A ('Library Instance', 'PlcTask Outputs^Interactive.M1.Axis.PlcToNc')
          B ('TINC^NC-Task 1 SAF^Axes^Library 1', 'Inputs^FromPlc')
    3.) A ('Library Instance', 'PlcTask Inputs^BasicTests.Motor.Axis.NcToPlc')
          B ('TINC^NC-Task 1 SAF^Axes^Library 2', 'Outputs^ToPlc')
    4.) A ('Library Instance', 'PlcTask Outputs^BasicTests.Motor.Axis.PlcToNc')
          B ('TINC^NC-Task 1 SAF^Axes^Library 2', 'Inputs^FromPlc')

Pragma lint results
-------------------
```
INFO:pytmc.bin.pragmalint:Total pragmas found: 108 Total linter errors: 0
PLC Project (1): Library
========================


DUTs/DUT_MotionStage.TcDUT (TcPlcObject)
----------------------------------------

    - DUT_MotionStage: Declaration - 32 pragmas


DUTs/DUT_PositionState.TcDUT (TcPlcObject)
------------------------------------------

    - DUT_PositionState: Declaration - 9 pragmas


DUTs/ENUM_EpicsHomeCmd.TcDUT (TcPlcObject)
------------------------------------------

    - ENUM_EpicsHomeCmd: Declaration - 2 pragmas


DUTs/ENUM_EpicsInOut.TcDUT (TcPlcObject)
----------------------------------------

    - ENUM_EpicsInOut: Declaration - 1 pragmas


DUTs/ENUM_EpicsMotorCmd.TcDUT (TcPlcObject)
-------------------------------------------

    - ENUM_EpicsMotorCmd: Declaration - 2 pragmas


DUTs/ENUM_MotionRequest.TcDUT (TcPlcObject)
-------------------------------------------

    - ENUM_MotionRequest: Declaration - 2 pragmas


DUTs/ENUM_StageBrakeMode.TcDUT (TcPlcObject)
--------------------------------------------

    - ENUM_StageBrakeMode: Declaration - 2 pragmas


DUTs/ENUM_StageEnableMode.TcDUT (TcPlcObject)
---------------------------------------------

    - ENUM_StageEnableMode: Declaration - 2 pragmas


DUTs/DUT_MotionPneumaticActuator.TcDUT (TcPlcObject)
----------------------------------------------------

    - DUT_MotionPneumaticActuator: Declaration - 18 pragmas


DUTs/ENUM_PnuematicActuatorPositionState.TcDUT (TcPlcObject)
------------------------------------------------------------

    - ENUM_PnuematicActuatorPositionState: Declaration - 2 pragmas


POUs/Deprecated/FB_StatePTPMove.TcPOU (TcPlcObject)
---------------------------------------------------

    - FB_StatePTPMove: Declaration - 7 pragmas


POUs/Motion/FB_MotionPneumaticActuator.TcPOU (TcPlcObject)
----------------------------------------------------------

    - FB_MotionPneumaticActuator: Declaration - 3 pragmas


POUs/Motion/States/FB_EpicsInOut.TcPOU (TcPlcObject)
----------------------------------------------------

    - FB_EpicsInOut: Declaration - 3 pragmas


POUs/Motion/States/FB_PositionStateManager.TcPOU (TcPlcObject)
--------------------------------------------------------------

    - FB_PositionStateManager: Declaration - 7 pragmas


POUs/Motion/States/FB_PositionStateMove.TcPOU (TcPlcObject)
-----------------------------------------------------------

    - FB_PositionStateMove: Declaration - 9 pragmas


tc_mca_std_lib/POUs/ErrorHandling/DUT_ErrorState.TcDUT (TcPlcObject)
--------------------------------------------------------------------

    - DUT_ErrorState: Declaration - 2 pragmas


tc_mca_std_lib/POUs/ErrorHandling/GVL_ErrorSystem.TcGVL (TcPlcObject)
---------------------------------------------------------------------

    - GVL_ErrorSystem: Declaration - 1 pragmas


UnitTests/Interactive.TcPOU (TcPlcObject)
-----------------------------------------

    - Interactive: Declaration - 1 pragmas


Version/Global_Version.TcGVL (TcPlcObject)
------------------------------------------

    - Global_Version: Declaration - 3 pragmas

```
