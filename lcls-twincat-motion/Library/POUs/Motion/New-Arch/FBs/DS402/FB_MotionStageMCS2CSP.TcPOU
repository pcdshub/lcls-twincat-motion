<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1">
  <POU Name="FB_MotionStageMCS2CSP" Id="{8a1beccb-8ae6-4cef-98b6-1d3261aefb9e}" SpecialFunc="None">
    <Declaration><![CDATA[{attribute 'call_after_init'}
FUNCTION_BLOCK FB_MotionStageMCS2CSP IMPLEMENTS I_DS402GenericDrive
VAR
    {attribute 'no_copy'}
    stPiezoStage  : REFERENCE TO ST_MotionStage;
    bSteModeEnable : BOOL;
    {attribute 'hide'}
    fbLogError  :   FB_LogMotionError;
    // Open Loop Operations
    {attribute 'hide'}
    fbUpdateSteps	:	FB_EcCoESdoWrite;
    {attribute 'hide'}
    fbUpdateStepFreq :	FB_EcCoESdoWrite;
    {attribute 'hide'}
    fbUpdateStepAmp  :	FB_EcCoESdoWrite;
    {attribute 'hide'}
    fbErrorRead	: FB_EcCoESdoRead;
    {attribute 'hide'}
    fbReadFErrWin	: FB_EcCoESdoRead;
    {attribute 'hide'}
    fbReadSoftLimMax	: FB_EcCoESdoRead;
    {attribute 'hide'}
    fbReadSoftLimMin  : FB_EcCoESdoRead;
    {attribute 'hide'}
    fbUpdateFErrorWin: FB_EcCoESdoWrite;
    {attribute 'hide'}
    fbUpdateSoftLimMin: FB_EcCoESdoWrite;
    {attribute 'hide'}
    fbUpdateSoftLimMax: FB_EcCoESdoWrite;
    {attribute 'hide'}
    fbUpdateHomeOffs : FB_EcCoESdoWrite;
    {attribute 'hide'}
    fbUpdateHomeVeloFast : FB_EcCoESdoWrite;
    {attribute 'hide'}
    fbUpdateHomeVeloSlow : FB_EcCoESdoWrite;
    {attribute 'hide'}
    fbUpdateHomeAcc : FB_EcCoESdoWrite;
    {attribute 'hide'}
    eMotionState :E_MoveState;
    {attribute 'hide'}
    eHomeState  : E_MoveState;
    {attribute 'hide'}
    eDriveState : E_DS402DriveState;
    {attribute 'hide'}
    eModule : E_Module;
    {attribute 'hide'}
    eHomeMode: E_EpicsHomeCmd :=E_EpicsHomeCmd.AUTOZERO;
    // Hardware I/O
    stDS402Drive : ST_DS402Drive;
    (* NetId of EtherCAT Master *)
    arNetId         		AT %I*  :   AMSNETID;
    (* Port Number of EtherCAT Slave *)
    nSlaveAddr        		AT %I*  :   UINT;
      // User Configurations data : Default unit is mm
    eEgu  : E_DS402EGU  := E_DS402EGU.MM;
    fScalingFactor  	: LREAL := 0.000001;
    fMaxVelocity  		:   LREAL := 1.0; // mm/s
    fMaxAcceleration 	:  LREAL := 10.0; // mm/s2
    {attribute 'hide'}
    fDefaultScalingFactor 	: LREAL:= 0.000001;
    fFErrWin 				: LREAL := 0.05;
    fHomeVeloFast   : LREAL := 0.4;
    fHomeVeloSlow   : LREAL := 0.4;
    fHomeAcc  : LREAL := 0.8;
    fSoftLimMax : LREAL;
    fSoftLimMin : LREAL;
    // Calibrated motion params : mm operation by default.
    {attribute 'hide'}
    fScaledStandStillPosition : LREAL;
    {attribute 'hide'}
    fScaledMeasuredPosition : LREAL;

    {attribute 'hide'}
    fOverride : LREAL;

  // MCS2 OL PVs
    {attribute 'pytmc' := '
        pv: PLC:nChanStep
        io: io
        field: DESC SmartAct: Open Loop Step Count
    '}
    nChanStep : DINT := 10;

    {attribute 'pytmc' := '
        pv: PLC:nChanStepFreq
        io: io
        field: DESC SmartAct: Open Loop Step Freq
    '}
    nChanStepFreq : UINT := 500;

    {attribute 'pytmc' := '
        pv: PLC:nChanStepAmp
        io: io
        field: DESC SmartAct: Open Loop Step Amp
    '}
    nChanStepAmp  : UINT := 50;

    // timeout for holding actual position ~ 30s
    {attribute 'pytmc' := '
        pv: PLC:nHoldTime
        io: io
        field: DESC SmartAct: Set servo mode hold time
    '}
    nHoldTime : UDINT := 30000;

    // Switch between closed and open loop operation
    {attribute 'pytmc' := '
        pv: PLC:bServo
        io: io
        field: ZNAM DISABLE
        field: ONAM ENABLE
        field: DESC Used to disable close loop mode
    '}
    bServo  : BOOL := TRUE;
    bTest: BOOL;
    {attribute 'hide'}
    eMoveMode :   E_EpicsMotorCmd := E_EpicsMotorCmd.MOVE_ABSOLUTE;
    {attribute 'hide'}
    bWrongParameter : BOOL;
        {attribute 'hide'}
    bDone : BOOL;
    {attribute 'hide'}
    bExecMove : BOOL;
    {attribute 'hide'}
    bExecHome : BOOL;
    {attribute 'hide'}
    bNewMoveReq : BOOL;
    {attribute 'hide'}
    bHomeBusy : BOOL;
    {attribute 'hide'}
    bPrepareDisable : BOOL;
    {attribute 'hide'}
    bStepMoveDone : BOOL;
    {attribute 'hide'}
    bStepMoveBusy : BOOL;
    {attribute 'hide'}
    bStop  : BOOL;
    {attribute 'hide'}
    bOperational  : BOOL;
    {attribute 'hide'}
    bServoOffMode : BOOL ;
    {attribute 'hide'}
    bServoOffparamsSet	: BOOL;
    {attribute 'hide'}
    bServoOffparamsSetDone : BOOL;
    {attribute 'hide'}
    bLimOverride  : BOOL;
    {attribute 'hide'}
    bPositionHold  : BOOL;
    {attribute 'hide'}
    bAxisInStandStillState : BOOL;
    {attribute 'hide'}
    bAxisStoppingState  : BOOL;
    {attribute 'hide'}
    bAxisInDiscreteState  :   BOOL;
    {attribute 'hide'}
    bAxisInErrorStopState : BOOL;
    {attribute 'hide'}
    bAxisInHomeState : BOOL;
    // use this for motion time axis states
    bLocalExec	: BOOL;
    {attribute 'hide'}
    nPiezoErrorCode   : UDINT;
    // Save abd restore encoder value
    {attribute 'hide'}
    bInit	: BOOL;
    {attribute 'hide'}
    bLoad	: BOOL;
    {attribute 'hide'}
    bEncError	: BOOL;
    {attribute 'hide'}
    bSaveDone	: BOOL;
    {attribute 'hide'}
    bAbortDone	: BOOL;
    {attribute 'hide'}
    // axis status -- emulating some NC axis
    {attribute 'hide'}
    bClosedLoopMode   : BOOL;
    {attribute 'hide'}
    bPositiveDirection  :	BOOL;
    {attribute 'hide'}
    bNegativeDirection  :   BOOL;
    {attribute 'hide'}
    bInTargetPosition   :   BOOL;
    {attribute 'hide'}
    bReadErrDone	:   BOOL;
    {attribute 'hide'}
    bFault	:   BOOL;
    {attribute 'hide'}
    bSlowParamReadTimer :   BOOL := TRUE;
    {attribute 'hide'}
    bHomeDone : BOOL;
    {attribute 'hide'}
    bMove : BOOL;
    {attribute 'hide'}
    bUndefined: BOOL;
    {attribute 'hide'}
    bDisabled: BOOL;
    {attribute 'hide'}
    bReadDriveCode: BOOL;
    {attribute 'hide'}
    bStepModeOk: BOOL;
    {attribute 'hide'}
    bHomeModeOk: BOOL;
    {attribute 'hide'}
    bCSPModeOk: BOOL;
    {attribute 'hide'}
    rtTargetReached : R_TRIG;
    {attribute 'hide'}
    rtStopDone: R_TRIG;
    rtExec : R_TRIG;
    {attribute 'hide'}
    rtHomed     : R_TRIG;
    {attribute 'hide'}
    rtMoveCmdShortcut : R_TRIG;
    {attribute 'hide'}
    rtHomeCmdShortcut : R_TRIG;
    {attribute 'hide'}
    rtEnableMode    : R_TRIG;
    {attribute 'hide'}
    rtUserExec      : R_TRIG;
    {attribute 'hide'}
    rtModeChange      : R_TRIG;
    {attribute 'hide'}
    rtMoveDone    : R_TRIG;
    {attribute 'hide'}
    rtEnableDrive : R_TRIG;
    {attribute 'hide'}
    rtNewMoveReq  : R_TRIG;
    {attribute 'hide'}
    ftExec      : F_TRIG;
    {attribute 'hide'}
    ftErrorReadDone  : F_TRIG;
    {attribute 'hide'}
    ftEnableDrive : F_TRIG;
    {attribute 'hide'}
    ftForwardEnabled  : F_TRIG;
    {attribute 'hide'}
    ftBackwardEnabled : F_TRIG;
    {attribute 'hide'}
    ftUpdateStepsDone	:	F_TRIG;
    {attribute 'hide'}
    ftUpdateStepFreqDone :	F_TRIG;
    {attribute 'hide'}
    ftUpdateStepAmpDone  :	F_TRIG;
    {attribute 'hide'}
    rtReadError : R_TRIG;
    {attribute 'hide'}
    rtHomeExec: R_TRIG;
    {attribute 'hide'}
    ftHomeExec : F_TRIG;
    {attribute 'hide'}
    rtHomeDone : R_TRIG;
    {attribute 'hide'}
    ftFErrWinUpdateDone: F_TRIG;
    {attribute 'hide'}
    ftSoftLimMaxUpdateDone: F_TRIG;
    {attribute 'hide'}
    ftSoftLimMinUpdateDone: F_TRIG;
    {attribute 'hide'}
    ftHomeVeloFastUpdateDone: F_TRIG;
    {attribute 'hide'}
    ftHomeAccUpdateDone: F_TRIG;
    {attribute 'hide'}
    ftHomeOffsUpdateDone: F_TRIG;
    {attribute 'hide'}
    rtHomeOffset: R_TRIG;
    {attribute 'hide'}
    rtHomeVeloSlow: R_TRIG;
    {attribute 'hide'}
    ftHomeVeloSlowUpdateDone: F_TRIG;
    {attribute 'hide'}
    rtPPModeOk: R_TRIG;
    {attribute 'hide'}
    rtHomeModeOk: R_TRIG;
    {attribute 'hide'}
    rtStepModeOk: R_TRIG;
    {attribute 'hide'}
    ftStepAmpUpdateDone: F_TRIG;
    {attribute 'hide'}
    ftStepFreqUpdateDone: F_TRIG;
    {attribute 'hide'}
    ftStepUpdateDone: F_TRIG;
    {attribute 'hide'}
    sAmsNetId	: T_AmsNetId;
    {attribute 'hide'}
    nSubIndex	: BYTE := 0;
    {attribute 'hide'}
    nChanFErrWinIdx	: WORD;
    {attribute 'hide'}
    nChanSoftwareLimIdx : WORD;
    {attribute 'hide'}
    nChanMotorLoadIdx : WORD;
    {attribute 'hide'}
    nChanErrorCodeIdx : WORD;
    {attribute 'hide'}
    nChanStepIdx    : WORD;
    {attribute 'hide'}
    nChanStepFreqIdx  : WORD;
    {attribute 'hide'}
    nChanStepAmpIdx : WORD;
    {attribute 'hide'}
    nChanSoftLimitIdx : WORD;
    {attribute 'hide'}
    nChanHomeOffsIdx : WORD;
    {attribute 'hide'}
    nChanHomeVeloIdx : WORD;
    {attribute 'hide'}
    nChanhomeAccIdx : WORD;
    {attribute 'hide'}
    sAmsNetTmp  : STRING;
    {attribute 'hide'}
    nHomeOffs: DINT;
    {attribute 'hide'}
    nRecentSoftLimMax : LINT;
    {attribute 'hide'}
    nRecentSoftLimMin : LINT;
    {attribute 'hide'}
    nSoftLimMin     : LINT;
    {attribute 'hide'}
    nSoftLimMax     : LINT;
    {attribute 'hide'}
    nScalededStepAmp  : UINT;
    {attribute 'hide'}
    nScaledStepFreq   : UINT;
    {attribute 'hide'}
    nChanPrevStepFreq	: UINT;
    {attribute 'hide'}
    nChanPrevStepAmp	: UINT;
    {attribute 'hide'}
    nCounter: UINT;
    {attribute 'hide'}
    nSavedholtime : UDINT;
    {attribute 'hide'}
     nHomeVeloFast : UDINT;
    {attribute 'hide'}
    nHomeVeloSlow  : UDINT;
    {attribute 'hide'}
    nRecentHomeVeloFast : UDINT;
    {attribute 'hide'}
    nRecentHomeVeloSlow : UDINT;
    {attribute 'hide'}
    nHomeAcc : UDINT;
    {attribute 'hide'}
    nRecentHomeAcc : UDINT;
    {attribute 'hide'}
    nScaledTargetVelo : DINT;
    {attribute 'hide'}
    nScaledTargetAcc  : DINT;
    {attribute 'hide'}
    nScaledTargetPosition	: DINT;
    {attribute 'hide'}
    nScaledMaxVelocity	: DINT;
    {attribute 'hide'}
    nScalededMaxAcc : DINT;
    {attribute 'hide'}
    nScaledHomeVelo   : DINT;
    {attribute 'hide'}
    nScaledHomeAcc  : DINT;
    {attribute 'hide'}
    {attribute 'hide'}
    nChanPrevStep	: DINT;
    {attribute 'hide'}
    nfErrWin : DINT;
    {attribute 'hide'}
    nScaledFErrWin : DINT;
    {attribute 'hide'}
    nRecentFErrWin: DINT;
    {attribute 'hide'}
    nHomeOffset : DINT;
    {attribute 'hide'}
    nRecentHomeOffset : DINT;
    {attribute 'hide'}
    nScalededSteps  : DINT;
    {attribute 'hide'}
    nRecentSteps: DINT;
    {attribute 'hide'}
    nRecentStepAmp: UINT;
    {attribute 'hide'}
    nRecentStepFreq: UINT;
    {attribute 'hide'}
    tonAbortStart : TON;
    {attribute 'hide'}
    tonAbortDone : TON;
    {attribute 'hide'}
    tonInit : TON;
    {attribute 'hide'}
    tonFastParamReadTimer: TON;
    {attribute 'hide'}
    tonSyncHoming : TON;
    {attribute 'hide'}
    tonHoldTime     : TON;
    {attribute 'hide'}
    tonServoOffSync   : TON;
    {attribute 'hide'}
    tonSlowParamReadTimer: TON;

    abortTime : TIME := T#800MS;
    {attribute 'hide'}
    tRefreshDelay   : TIME := T#1S;
    {attribute 'hide'}
    rtAbort: R_TRIG;
    btestabortDone: BOOL;
    bfirstAbort: BOOL;
    bSecondAbort: BOOL;
    bThirdAbort: BOOL;
    nAbortCase : UINT;
    rtComfirmNewTarget: R_TRIG;


    fbMcPower : MC_Power;
    bEnable	: BOOL;
    bEnablePositive : BOOL;
    bEnableNegative : BOOL;
    bPowerIsEnabled : BOOL;

    eBufferMode : MC_BufferMode := MC_BufferMode.MC_Aborting;
    // MoveABsolute
    fbMcMoveAbsolute : MC_MoveAbsolute;
    fbMcHalt 		: MC_Halt;
    fTargetPosition	: LREAL;
    fTargetVelocity	: LREAL;
    fTargetAcceleration	: LREAL := 0.0;
    fTargetDeceleration	: LREAL := 0.0;
    fTargetJerk	: LREAL := 0.0;

    rtBusy : R_TRIG;
    ftBusy : F_TRIG;
    rtDone : R_TRIG;
    rtAborted : R_TRIG;
    bCommandMoveAbsolute : BOOL;
    bAborted : BOOL;
    fbMcReset 	: MC_Reset;

    bExecParamsRead: BOOL;
    bExecParamsWrite: BOOL;
    fbMcWriteParameter : MC_WriteParameter;
    bExecute : BOOL;
    nParameterNumber : MC_AxisParameter;
    fParameterValue	: LREAL;


    // MC_ReadParameterSet Output
    fbMcReadParams: MC_ReadParameterSet;

    bNcParamsReadInit   : BOOL;
    NCParamsTimer : TON;
    bAxisParametersInit : BOOL;

    bRecentEnPosLagStatus : BOOL;
// save and restore
    fbSetPos: MC_SetPosition;
    bClearPositionLag : BOOL := TRUE;

    nLatchErrId : BOOL;
    bRestoreDone 	: BOOL;
    bRestoreError 	: BOOL;
    nRestoreErrorID : UDINT;
    // save and Restore
    RestoreTimer: TON;
    bRestoreInit: BOOL;
    bRestoreLoad: BOOL;
    nLatchError: UDINT;
    nMaxRetries: UINT := 10;
    nCurrTries: UINT := 0;
    bRestoreWaitRetry: BOOL;
    tonRestoreRetry: TON;
    tRefreshTime : TIME := T#1S;
    rtStepMove: R_TRIG;
END_VAR


VAR CONSTANT
    {attribute 'hide'}
    nChanSoftLimitBase  : WORD := 16#200E;
    {attribute 'hide'}
    nHomeOffsetBase   : WORD := 16#607C;
    {attribute 'hide'}
    nHomingSpeedBase  : WORD := 16#6099;
    {attribute 'hide'}
    nhomingAccBase    : WORD := 16#609a;
    {attribute 'hide'}
    nErrorCodeBase    : WORD := 16#603f;
    {attribute 'hide'}
    nFErrWinBase    : WORD := 16#6065;
    // this true for SmartAct MCS2 and E-727.
    {attribute 'hide'}
    nChanOfsBase  : WORD := 16#800;
    // DS 402 Motor encoder defective code : this is needed for save and restore.
    {attribute 'hide'}
    nEncErrorCode : WORD := 16#7300;
    {attribute 'hide'}
    nSoftLimBase  : WORD := 16#200e;
    {attribute 'hide'}
    nOlStepBase   : WORD := 16#2022;
    {attribute 'hide'}
    nOlStepAmpBase  : WORD := 16#2023;
    {attribute 'hide'}
    nOlStepFreqBase : WORD := 16#2024;

END_VAR

VAR PERSISTENT
    bSaved: BOOL;
    fSavedPosition: LREAL;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[IF NOT __ISVALIDREF(stPiezoStage) THEN
    RETURN;
END_IF
// Done once after init
IF bInit THEN
    (*Mandatory must be unique for each MCS2 axis *)
    stPiezoStage.nMotionAxisID := stPiezoStage.Axis.NcToPlc.AxisId;
    bInit := FALSE;
END_IF

// Check for the plc shortcut commands
// Used for testing or to circumvent motor record issues
rtMoveCmdShortcut(CLK:=stPiezoStage.bMoveCmd);
rtHomeCmdShortcut(CLK:=stPiezoStage.bHomeCmd);

// Execute on rising edge
IF rtMoveCmdShortcut.Q AND NOT stPiezoStage.bExecute THEN
    stPiezoStage.bExecute:=TRUE;
    IF bServo THEN
        // Close loop CSP mode
        stPiezoStage.nCommand:=E_EpicsMotorCmd.MOVE_ABSOLUTE;
    ELSE
        // Open Loop Step Mode
        stPiezoStage.nCommand:=E_EpicsMotorCmd.JOG;
    END_IF

    // attempting to move an axis without homing first?
    IF stPiezoStage.nHomingMode <> E_EpicsHomeCmd.NONE AND NOT stPiezoStage.bHomed THEN
        // one can just set bHome here even though no homing was done?
        stPiezoStage.sErrorMessage:='Axis homing mode set, but homing routine pending';
    END_IF

ELSIF rtHomeCmdShortcut.Q AND NOT stPiezoStage.bExecute THEN
    stPiezoStage.bExecute:= NOT ( stPiezoStage.nCmdData = E_EpicsHomeCmd.ABSOLUTE_SET ) OR NOT ( stPiezoStage.nCmdData = E_EpicsHomeCmd.NONE);
    stPiezoStage.nCommand:=E_EpicsMotorCmd.HOME;
    // Automatically fill the correct nCmdData for homing
    stPiezoStage.nCmdData:=stPiezoStage.nHomingMode;
END_IF

// Handle main execs .  Rising on bMoved should be the ntry point
// bu this is not the case in production its a rising on bExecute.
rtUserExec(CLK:=stPiezoStage.bExecute);
// if a Move/Home Goal is comfirmed and there is no persistant
// error conditions, then we have a valid move request.
bNewMoveReq S= NOT stPiezoStage.bBusy AND rtUserExec.Q AND NOT stPiezoStage.bError;
// this Move request is valid till an error occurs or the currently move is done
bNewMoveReq R= NOT stPiezoStage.bExecute OR stPiezoStage.bError;
bPrepareDisable R= bNewMoveReq;
// define this R_TRIG to comfirm a new move request.
rtNewMoveReq(CLK:=bNewMoveReq);
// Moves are automatically allowed if no safety hooks. Otherwise, some other code will set this.
stPiezoStage.bSafetyReady S= stPiezoStage.bPowerSelf;

// Transition to DURING_MOTION drive mode
rtEnableMode(CLK:=(stPiezoStage.nEnableMode = E_StageEnableMode.DURING_MOTION));
// Handle auto-enable timing
CASE stPiezoStage.nEnableMode OF
    E_StageEnableMode.ALWAYS:
        stPiezoStage.bEnable:=TRUE;
    E_StageEnableMode.DURING_MOTION:
        IF rtEnableMode.Q THEN
            stPiezoStage.bEnable := FALSE;
        END_IF
        // Power only enabled with a new move request
        IF rtNewMoveReq.Q THEN
            stPiezoStage.bEnable S= stPiezoStage.bSafetyReady;
        END_IF
END_CASE

Interlock();

bLocalExec:= NOT stPiezoStage.bError AND stPiezoStage.bExecute AND stPiezoStage.bAllEnable AND stPiezoStage.bEnableDone AND stPiezoStage.bSafetyReady;
//
bExecHome:=bLocalExec AND stPiezoStage.nCommand = 10;
bExecMove:=bLocalExec AND NOT bExecHome;

ModeOperation();

// When we start, set the busy/done appropriately
// CLose loop control using NC
rtExec(CLK:=bLocalExec);
IF rtExec.Q THEN
    stPiezoStage.bDone := FALSE;
END_IF

// Step Mode Manual control
IF rtNewMoveReq.Q THEN
        // override ongoing holding.
    bPositionHold := FALSE;
    tonHoldTime.IN:=FALSE;
    // clear the stop bit from previous interruption
    IF bStepModeOk THEN
        bSteModeEnable := stPiezoStage.bEnable;
        stDS402Drive.nDS402DriveControl.8 := 0;
    END_IF
END_IF

// We've got the rising edge clear this flags.
stPiezoStage.bMoveCmd:=FALSE;
stPiezoStage.bHomeCmd:=FALSE;

// updated axis status
stPiezoStage.Axis.ReadStatus();

// Get a definitive bEnabled reading
CASE stPiezoStage.Axis.Status.MotionState OF
    // We are not enabled if there is an issue
    MC_AXISSTATE_UNDEFINED, MC_AXISSTATE_DISABLED, MC_AXISSTATE_ERRORSTOP:
        stPiezoStage.bEnableDone := FALSE;
    ELSE
        stPiezoStage.bEnableDone := TRUE;
END_CASE
//
THIS^.Reset();
// Try to clear any faults if they are present by setting bit 7 of the Control Word.
IF stPiezoStage.bReset THEN
    stPiezoStage.bReset:=FALSE;
    stPiezoStage.bExecute:=FALSE;
    stPiezoStage.bError := FALSE;
    stPiezoStage.nErrorId := 0;
    stPiezoStage.sErrorMessage:='';
    stPiezoStage.sCustomErrorMessage:='';
    stPiezoStage.bEnable:=FALSE;
END_IF
//
IF NOT bStepModeOk THEN
    stDS402Drive.nDS402DriveControl := stDS402Drive.nDS402DriveControlNC;
END_IF

CASE stPiezoStage.nCommand  OF

    E_EpicsMotorCmd.MOVE_ABSOLUTE:;

        bCommandMoveAbsolute := bExecMove AND fbMcPower.Status AND bCSPModeOk;
        IF fbMcMoveAbsolute.Done THEN
            bPositionHold := TRUE;
            tonHoldTime.IN:=TRUE;
        END_IF

    E_EpicsMotorCmd.HOME:;
        IF THIS^.stPiezoStage.stAxisParameters.bCtrlEnablePosDiffControl.0 THEN
            bRecentEnPosLagStatus := THIS^.stPiezoStage.stAxisParameters.bCtrlEnablePosDiffControl.0;
            WriteParameterNC( Execute:=bExecHome,
                            ParameterNumber:=MC_AxisParameter.AxisEnPositionLagMonitoring,
                              ParameterValue:=0 );
        END_IF
        Home();
    E_EpicsMotorCmd.JOG:
        // Override power enable
        bSteModeEnable := bSteModeEnable AND bServoOffparamsSetDone AND NOT bWrongParameter;
        THIS^.StepMove(Enable:=bSteModeEnable);

END_CASE

THIS^.Halt();
THIS^.Power();
THIS^.MoveAbsolute();
//

stPiezoStage.bBusy:=bHomeBusy OR fbMcMoveAbsolute.Busy OR bStepMoveBusy;

// user override aka stop FROM EPICS ?
// Check done moving via user stop, Target Position Monitoring, or from homing.
// set/reset stPiezoStage.bDone after move absolute/Relative
rtMoveDone(CLK:=fbMcMoveAbsolute.Done OR bStepMoveDone);
rtHomeDone(CLK:=bHomeDone);
rtStopDone(CLK:=fbMcHalt.Done OR bLimOverride);
rtAborted(CLK:=fbMcMoveAbsolute.CommandAborted);
IF rtAborted.Q OR rtStopDone.Q OR rtMoveDone.Q OR rtHomeDone.Q THEN
    IF NOT stPiezoStage.bDone THEN
          stPiezoStage.bHomed := bHomeDone;
        bMove := FALSE;
        bStop := FALSE;
        stPiezoStage.bExecute:=FALSE;
        bCommandMoveAbsolute := FALSE;
        stPiezoStage.bDone := fbMcMoveAbsolute.Done OR bHomeDone OR bStepMoveDone;
        IF bHomeDone THEN
            WriteParameterNC( 	Execute:=bRecentEnPosLagStatus,
                                ParameterNumber:=MC_AxisParameter.AxisEnPositionLagMonitoring,
                                  ParameterValue:=BOOL_TO_LREAL(bRecentEnPosLagStatus) );
        END_IF
        // Release the endstop override
        bLimOverride := FALSE;
    END_IF
END_IF
(* hold position with closed loop operation active before timeout *)
tonHoldTime(PT:=UDINT_TO_TIME(nHoldTime));

IF tonHoldTime.Q THEN
    bPositionHold := FALSE;
    tonHoldTime.IN:=FALSE;
    // open loop mode is not compatible with MC_Power, MC _Halt...
    // thus we want get axis standstill to clear the enable bit.
    IF bStepModeOk THEN
        THIS^.stPiezoStage.bEnable := FALSE;
        stDS402Drive.nDS402DriveControl := 6;
    END_IF
END_IF

//Handle auto-disable timing
bPrepareDisable S= stPiezoStage.nEnableMode = E_StageEnableMode.DURING_MOTION AND ftExec.Q;
// Delay the disable until we reach standstill, else brake issues or other race conditions
IF bPrepareDisable AND stPiezoStage.Axis.Status.StandStill THEN
    IF NOT bPositionHold THEN
        bPrepareDisable:=FALSE;
        stPiezoStage.bEnable:=FALSE;
    END_IF
END_IF
(*
    Error from functions and Nc
    The error will send to EPICS interface based on predifined
    priority: axis, power, backlash, absoluteMove, etc...
*)
IF fbMcPower.Error AND fbMcPower.Active THEN
    stPiezoStage.bError:=fbMcPower.Error;
    stPiezoStage.nErrorId:=fbMcPower.ErrorID;
ELSIF fbMcMoveAbsolute.Error THEN
    stPiezoStage.bError:=fbMcMoveAbsolute.Error;
    stPiezoStage.nErrorId:=fbMcMoveAbsolute.ErrorID;
ELSIF fbMcHalt.Error AND fbMcHalt.Active THEN
    stPiezoStage.bError:=fbMcHalt.Error;
    stPiezoStage.nErrorId:=fbMcHalt.ErrorID;
ELSIF fbMcReset.Error  THEN
    stPiezoStage.bError:=fbMcReset.Error;
    stPiezoStage.nErrorId:=fbMcReset.ErrorID;
ELSE
    IF stPiezoStage.bBusy THEN
        stPiezoStage.sErrorMessage := '';
        stPiezoStage.sCustomErrorMessage := '';
    END_IF
END_IF;
// update encoder value and calibrated position
ScaleEncRawValue();
//
ExposedParameters(Enable:=TRUE, tRefreshDelay:=T#2S);
//
// Open Loop Motion paramters Update
UpdateServoOffMotionParams(Enable:=stPiezoStage.bAxisParamsInit AND NOT stPiezoStage.bBusy AND bStepModeOk);
UpdateDriveMonitoringParams(Enable:=stPiezoStage.bAxisParamsInit AND NOT stPiezoStage.bBusy);
// Save and restore as long as not an absolute encoder
PersistParameters( bEnable:=stPiezoStage.nHomingMode <> E_EpicsHomeCmd.NONE);

IF stPiezoStage.bError  THEN
    stPiezoStage.bBusy := FALSE;
    stPiezoStage.bDone := FALSE;
    stPiezoStage.bEnable := FALSE;

END_IF

ReadDriveCodes();

IF stPiezoStage.sCustomErrorMessage <> ''
    AND stPiezoStage.sErrorMessage = '' THEN
    stPiezoStage.sErrorMessage := stPiezoStage.sCustomErrorMessage;
END_IF

RestoreParameters();

UpdateEpicsStatus();
]]></ST>
    </Implementation>
    <Method Name="ExposedParameters" Id="{bfdcb735-2f35-43ca-9b4a-eca418143c19}">
      <Declaration><![CDATA[METHOD PUBLIC  ExposedParameters
VAR_INPUT
    Enable : BOOL;
    tRefreshDelay: TIME;
END_VAR

]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Periodic update of NC parameters
NCParamsTimer( IN:=Enable AND NOT bExecParamsRead, PT:=tRefreshDelay);
bExecParamsRead S= NCParamsTimer.Q;
fbMcReadParams(
    Parameter:=stPiezoStage.stAxisParameters,
    Axis:=stPiezoStage.Axis,
    Execute:= bExecParamsRead );

// Copy axis parameters that we want to expose to the EPICS layer.
stPiezoStage.stAxisParametersExposed.bCtrlEnablePosDiffControl     := stPiezoStage.stAxisParameters.bCtrlEnablePosDiffControl;
stPiezoStage.stAxisParametersExposed.bEncEnableSoftEndMaxControl   := stPiezoStage.stAxisParameters.bEncEnableSoftEndMaxControl;
stPiezoStage.stAxisParametersExposed.bEncEnableSoftEndMinControl   := stPiezoStage.stAxisParameters.bEncEnableSoftEndMinControl;
stPiezoStage.stAxisParametersExposed.fAccelerationMax              := stPiezoStage.stAxisParameters.fAccelerationMax;
stPiezoStage.stAxisParametersExposed.fCtrlPosDiffMax               := stPiezoStage.stAxisParameters.fCtrlPosDiffMax;
stPiezoStage.stAxisParametersExposed.fCtrlPosDiffMaxTime           := stPiezoStage.stAxisParameters.fCtrlPosDiffMaxTime;
stPiezoStage.stAxisParametersExposed.fDecelerationMax              := stPiezoStage.stAxisParameters.fDecelerationMax;
stPiezoStage.stAxisParametersExposed.fEncSoftEndMax                := stPiezoStage.stAxisParameters.fEncSoftEndMax;
stPiezoStage.stAxisParametersExposed.fEncSoftEndMin                := stPiezoStage.stAxisParameters.fEncSoftEndMin;
stPiezoStage.stAxisParametersExposed.fVeloMaximum                  := stPiezoStage.stAxisParameters.fVeloMaximum;
stPiezoStage.stAxisParametersExposed.fEncOffset               		:= stPiezoStage.stAxisParameters.fEncOffset;
stPiezoStage.stAxisParametersExposed.fEncScaleFactorInternal       := stPiezoStage.stAxisParameters.fEncScaleFactorInternal;

bExecParamsRead R= fbMcReadParams.Done OR fbMcReadParams.Error;
stPiezoStage.bAxisParamsInit S= fbMcReadParams.Done;]]></ST>
      </Implementation>
    </Method>
    <Method Name="FB_Init" Id="{a8134580-303c-4b2f-8942-be52670189d3}">
      <Declaration><![CDATA[//FB_Init is always available implicitly and it is used primarily for initialization.
//The return value is not evaluated. For a specific influence, you can also declare the
//methods explicitly and provide additional code there with the standard initialization
//code. You can evaluate the return value.
METHOD FB_Init: BOOL
VAR_INPUT
    bInitRetains: BOOL; // TRUE: the retain variables are initialized (reset warm / reset cold)
    bInCopyCode: BOOL;  // TRUE: the instance will be copied to the copy code afterward (online change)
    stPiezoStage		:	REFERENCE TO ST_MotionStage;
    eModule : E_Module;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[THIS^.stPiezoStage REF= stPiezoStage;
THIS^.eModule := eModule;

]]></ST>
      </Implementation>
    </Method>
    <Method Name="Halt" Id="{6287ad75-ad53-4d78-9e75-75537e8950c5}">
      <Declaration><![CDATA[METHOD Halt : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[//
ftExec(CLK:=stPiezoStage.bExecute);
//ftError(CLK:=stPiezoStage.bError);
// Halt is always a user stop but not an interlock event or a reset, but not a warning condition
bStop := ftExec.Q AND ((bHomeBusy AND (stPiezoStage.nCommand=10))
                    OR(fbMcMoveAbsolute.Busy AND (stPiezoStage.nCommand=3)));

fbMcHalt(
    Axis := stPiezoStage.Axis,
    Execute := bStop AND bCSPModeOk,
    Deceleration := stPiezoStage.fDeceleration,
    BufferMode := eBufferMode,
);]]></ST>
      </Implementation>
    </Method>
    <Method Name="Home" Id="{30e09e6f-3e19-461e-88df-b1cd53b15969}">
      <Declaration><![CDATA[METHOD PUBLIC Home]]></Declaration>
      <Implementation>
        <ST><![CDATA[tonSyncHoming(PT:=T#150MS);
CASE eHomeMode OF
    E_EpicsHomeCmd.AUTOZERO:
        bMove S=  bExecHome;
    E_EpicsHomeCmd.NONE:
        bMove := FALSE;
        bHomeBusy :=  bExecHome;
        bHomeDone := NOT  bExecHome;
    ELSE
        bMove := FALSE;
END_CASE

IF bMove THEN
    CASE eHomeState OF
        // Wait for a rising edge
        E_MoveState.IDLING:
            IF bExecHome AND bHomeModeOk THEN
                bHomeDone := FALSE;
                bHomeBusy := TRUE;
                stPiezoStage.bDone := FALSE;
                bInTargetPosition:=FALSE;
                tonSyncHoming.IN := TRUE;
                stDS402Drive.nDS402DriveControl.4:=TRUE;
                eHomeState := E_MoveState.INIT;
            END_IF
        E_MoveState.INIT:
            IF tonSyncHoming.Q THEN
                tonSyncHoming.IN := FALSE;
                eHomeState:=E_MoveState.STARTED;
            END_IF

        E_MoveState.STARTED :
            // this is a comfirmation that routine is ongoing
            IF NOT stDS402Drive.stDS402DriveStatus.TargetReached
                AND NOT stDS402Drive.stDS402DriveStatus.Bit13_OpModeSpecific THEN
                bHomeBusy:=TRUE;
                bHomeDone:=FALSE;
                eHomeState:=E_MoveState.IN_PROGRESS;
            END_IF

        E_MoveState.IN_PROGRESS :

        IF bStop THEN
          bHomeBusy:=FALSE;
          eHomeState:=E_MoveState.INTERRUPTED;

        // Genral Motion error i.e Following error ?
        ELSIF stDS402Drive.stDS402DriveStatus.Bit13_OpModeSpecific
                OR stDS402Drive.stDS402DriveStatus.WarningCondition THEN
            stPiezoStage.bError := TRUE;
            eHomeState:=E_MoveState.ERROR;

        // Reached
        ELSIF stDS402Drive.stDS402DriveStatus.TargetReached
            AND stDS402Drive.stDS402DriveStatus.Bit12_OpModeSpecific
            AND NOT stDS402Drive.stDS402DriveStatus.Bit13_OpModeSpecific THEN
           eHomeState:=E_MoveState.DONE;
        END_IF
        E_MoveState.INTERRUPTED:
            tonHoldTime.IN:=TRUE;
            bPositionHold := TRUE;
            IF NOT bAxisStoppingState THEN
                eHomeState:=E_MoveState.IDLING;
            END_IF

        E_MoveState.DONE:
            bHomeBusy:=FALSE;
            tonSyncHoming.IN := FALSE;
            tonHoldTime.IN := TRUE;
            bPositionHold := TRUE;
            bHomeDone:=TRUE;
            stPiezoStage.fPosition:=0.0;
            eHomeState:=E_MoveState.IDLING;
        E_MoveState.ERROR:
            bHomeDone:=FALSE;
            bHomeBusy:= FALSE;
            IF bWrongParameter THEN
                stPiezoStage.sCustomErrorMessage:='Invalid motion Parameters';
                bWrongParameter := FALSE;
                stPiezoStage.bError := TRUE;
            END_IF
            IF NOT stPiezoStage.bError THEN
                eHomeState:=E_MoveState.IDLING;
            END_IF
    END_CASE
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="Interlock" Id="{b0516fc0-3ac5-4a37-a4b7-b21194f9b805}">
      <Declaration><![CDATA[METHOD PUBLIC Interlock

VAR
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Positive or Negative direction
bPositiveDirection:=stPiezoStage.bBusy AND stPiezoStage.fPosDiff > 0;
bNegativeDirection:=stPiezoStage.bBusy AND stPiezoStage.fPosDiff < 0;

// For SmartAct MCS2 these limit are range and enstop limits. however a single bit in the status is used
// bLimOverride  : act as an override after limit was hit to allow reverse movement
stPiezoStage.bLimitForwardEnable :=  bLimOverride OR NOT( bPositiveDirection AND stDS402Drive.stDS402DriveStatus.InternalLimitActive );
stPiezoStage.bLimitBackwardEnable := bLimOverride OR NOT( bNegativeDirection AND stDS402Drive.stDS402DriveStatus.InternalLimitActive );

// use falling trigger to avoid spaming  sErrorMessage
ftForwardEnabled(CLK:=stPiezoStage.bLimitForwardEnable);
ftBackwardEnabled(CLK:=stPiezoStage.bLimitBackwardEnable);

IF  NOT bHomeBusy AND ftForwardEnabled.Q THEN
    // Not an error, just a warning
    stPiezoStage.sCustomErrorMessage:='Cannot move past positive limit.';
    bLimOverride := TRUE;
END_IF

IF NOT bHomeBusy AND ftBackwardEnabled.Q THEN
    // Not an error, just a warning
    stPiezoStage.sCustomErrorMessage:='Cannot move past Negative limit.';
    bLimOverride := TRUE;
END_IF

IF NOT stPiezoStage.bError AND stPiezoStage.bExecute AND NOT stPiezoStage.bUserEnable THEN
    stPiezoStage.bError := TRUE;
    stPiezoStage.nErrorId := 1;
    stPiezoStage.sCustomErrorMessage := 'Move requested, but user enable is disabled!';
END_IF

// Update all enable booleans
SetEnables();]]></ST>
      </Implementation>
    </Method>
    <Method Name="ModeOperation" Id="{101f52ed-fac5-4fd9-b68c-696a0d98bf98}">
      <Declaration><![CDATA[(*Switch the drive mod eof Operation
  Servo On: Profil Positioning or HOME
  Servo Off : STEP mode
*)
METHOD ModeOperation
]]></Declaration>
      <Implementation>
        <ST><![CDATA[rtPPModeOk(CLK:=( stDS402Drive.nModeOfOperationDisplay=E_DS402OpMode.CSP));
rtHomeModeOk(CLK:=( stDS402Drive.nModeOfOperationDisplay=E_DS402OpMode.HOME));
rtStepModeOk(CLK:=( stDS402Drive.nModeOfOperationDisplay=E_DS402OpMode.MCS2_OL_STEP_MODE));
// transition to close loop mode
IF rtPPModeOk.Q THEN
    bStepModeOk := FALSE;
    bHomeModeOk := FALSE;
    bCSPModeOk := TRUE;
ELSIF rtHomeModeOk.Q THEN
    bStepModeOk := FALSE;
    bHomeModeOk := TRUE;
    bCSPModeOk := FALSE;
ELSIF rtStepModeOk.Q THEN
    bStepModeOk := TRUE;
    bHomeModeOk := FALSE;
    bCSPModeOk := FALSE;
        bServo := FALSE;
END_IF

IF NOT bFault AND bServo AND rtUserExec.Q AND stPiezoStage.bHomeCmd THEN
    IF (stDS402Drive.nModeOfOperationDisplay<>E_DS402OpMode.HOME) THEN
        stDS402Drive.nModeOfOperation := E_DS402OpMode.HOME;
    ELSE
        bHomeModeOk := TRUE;
    END_IF
ELSIF NOT bFault AND bServo AND rtUserExec.Q THEN
    IF (stDS402Drive.nModeOfOperationDisplay<>E_DS402OpMode.CSP) THEN
        stDS402Drive.nModeOfOperation := E_DS402OpMode.CSP;
    ELSE
        bCSPModeOk := TRUE;
    END_IF
ELSIF NOT bFault AND NOT bServo AND rtUserExec.Q THEN
    IF (stDS402Drive.nModeOfOperationDisplay<>E_DS402OpMode.MCS2_OL_STEP_MODE) THEN
        stDS402Drive.nModeOfOperation := E_DS402OpMode.MCS2_OL_STEP_MODE;
    ELSE
        bStepModeOk := TRUE;
    END_IF
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="MoveAbsolute" Id="{c9986ba7-a025-4f1a-8312-93dc4112a24c}">
      <Declaration><![CDATA[METHOD PUBLIC  MoveAbsolute
]]></Declaration>
      <Implementation>
        <ST><![CDATA[
fbMcMoveAbsolute(
    Axis := stPiezoStage.Axis,
    Execute := bCommandMoveAbsolute,
    Position := stPiezoStage.fPosition,
    Velocity := stPiezoStage.fVelocity,
    Acceleration := stPiezoStage.fAcceleration,
    Deceleration := stPiezoStage.fDeceleration,
    Jerk := fTargetJerk,
    BufferMode := eBufferMode,
);]]></ST>
      </Implementation>
    </Method>
    <Method Name="PersistParameters" Id="{827e19b0-eb90-45f1-a0f0-e397f2f834ae}">
      <Declaration><![CDATA[METHOD PersistParameters
VAR_INPUT
    bEnable	: BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Save Encoder position
// needs some pre-conditions to use persistent storage
IF bEnable THEN
    // Check ST_MotionStage for an encoder error (range 0x44nn)
    bEncError:= stPiezoStage.Axis.Status.Error AND  ( stPiezoStage.Axis.Status.ErrorID  >= 16#4400  AND stPiezoStage.Axis.Status.ErrorID <= 16#44FF );
    // Do not save if we're currently loading or if there is an encoder error
    IF NOT bRestoreLoad AND NOT bEncError AND NOT bRestoreWaitRetry THEN
        fSavedPosition := stPiezoStage.Axis.NcToPlc.ActPos;
        // This persistent variable lets us check if anything was saved
        // It will be TRUE at startup if we have saved values
        bSaved := TRUE;
        (*
            use this with a timer of a change threshold on the fActPosition
            to trigger a save from this PLC program. otherwise this will be a spamming
            persistence, filling up the disk.
        *)
        //iPersistentDataStorage.TriggerWriteOfPersistentData := bSaveEnabled;
    END_IF
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="PostInit" Id="{7af64fe1-72e2-4a67-9fd4-3933db27c0b4}">
      <Declaration><![CDATA[{attribute 'call_after_init'}
(*	eModule: Mandatory must be unique for each MCS2 axis
    clears startup errors or warnings. the process is completed at run time
    SDO update of Drive and open Loop parameter Indexes based on module number
*)
METHOD PostInit
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[(* SDO update of Drive and open Loop parameter Indexes based on module number*)
nChanErrorCodeIdx	:= nErrorCodeBase		+ ((eModule-1) * nChanOfsBase);
nChanFErrWinIdx		:= nFErrWinBase 		+ ((eModule-1) * nChanOfsBase);
nChanSoftLimitIdx	:= nChanSoftLimitBase 	+ ((eModule-1) * nChanOfsBase);
nChanHomeOffsIdx 	:= nHomeOffsetBase 		+ ((eModule-1) * nChanOfsBase);
nChanHomeVeloIdx 	:= nHomingSpeedBase	 	+ ((eModule-1) * nChanOfsBase);
nChanhomeAccIdx 	:= nhomingAccBase 		+ ((eModule-1) * nChanOfsBase);
nChanStepIdx    	:= nOlStepBase 			+ ((eModule-1) * nChanOfsBase);
nChanStepFreqIdx  := nOlStepFreqBase 		+ ((eModule-1) * nChanOfsBase);
nChanStepAmpIdx 	:= nOlStepAmpBase 		+ ((eModule-1) * nChanOfsBase);
bInit := TRUE;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="Power" Id="{f641a677-a472-4a34-a0e0-f26f3662273e}">
      <Declaration><![CDATA[METHOD Power : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[fbMcPower(
    Axis := stPiezoStage.Axis,
    Enable := stPiezoStage.bAllEnable AND bCSPModeOk,
    Enable_Positive := stPiezoStage.bAllForwardEnable,
    Enable_Negative := stPiezoStage.bAllBackwardEnable,
    Override := 100.0,
    BufferMode := eBufferMode,
    (*Enabled*)

);]]></ST>
      </Implementation>
    </Method>
    <Method Name="ReadDriveCodes" Id="{c8b026c7-a02a-444a-a6c8-2fcd1b30b9c5}">
      <Declaration><![CDATA[(* Read Drive error codes after a motion or fault condition occured *)
METHOD ReadDriveCodes : BOOL

]]></Declaration>
      <Implementation>
        <ST><![CDATA[fbErrorRead( sNetId:= sAmsNetId,
             nSlaveAddr:=nSlaveAddr,
             nIndex:=nChanErrorCodeIdx,
             nSubIndex :=nSubIndex,
             pDstBuf:= ADR(nPiezoErrorCode),
             cbBufLen:=SIZEOF(nPiezoErrorCode),
             bExecute:= stPiezoStage.bError );

ftErrorReadDone(CLK:=fbErrorRead.bBusy);
IF ftErrorReadDone.Q THEN
    IF 	NOT fbErrorRead.bError AND nPiezoErrorCode <> 0 THEN
        stPiezoStage.nErrorId := nPiezoErrorCode;
    END_IF
    stPiezoStage.sErrorMessage := F_MotionErrorCodeLookup(nErrorId:=stPiezoStage.nErrorId);
    fbLogError( stMotionStage:=stPiezoStage, bEnable:=stPiezoStage.bError);
END_IF

]]></ST>
      </Implementation>
    </Method>
    <Method Name="ReadDriveParams" Id="{04b89b3a-63ea-4113-a627-dc81de4ad155}">
      <Declaration><![CDATA[(*Read Piezo drive Motion parameters*)
METHOD ReadDriveParams : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Periodic update of NC parameters
NCParamsTimer( IN:=bEnable AND NOT bExecParamsRead, PT:=tRefreshDelay);
bExecParamsRead S= NCParamsTimer.Q;
fbMcReadParams(
    Parameter:=stPiezoStage.stAxisParameters,
    Axis:=stPiezoStage.Axis,
    Execute:= bExecParamsRead );

// Copy axis parameters that we want to expose to the EPICS layer.
stPiezoStage.stAxisParametersExposed.bCtrlEnablePosDiffControl     := stPiezoStage.stAxisParameters.bCtrlEnablePosDiffControl;
stPiezoStage.stAxisParametersExposed.bEncEnableSoftEndMaxControl   := stPiezoStage.stAxisParameters.bEncEnableSoftEndMaxControl;
stPiezoStage.stAxisParametersExposed.bEncEnableSoftEndMinControl   := stPiezoStage.stAxisParameters.bEncEnableSoftEndMinControl;
stPiezoStage.stAxisParametersExposed.fAccelerationMax              := stPiezoStage.stAxisParameters.fAccelerationMax;
stPiezoStage.stAxisParametersExposed.fCtrlPosDiffMax               := stPiezoStage.stAxisParameters.fCtrlPosDiffMax;
stPiezoStage.stAxisParametersExposed.fCtrlPosDiffMaxTime           := stPiezoStage.stAxisParameters.fCtrlPosDiffMaxTime;
stPiezoStage.stAxisParametersExposed.fDecelerationMax              := stPiezoStage.stAxisParameters.fDecelerationMax;
stPiezoStage.stAxisParametersExposed.fEncSoftEndMax                := stPiezoStage.stAxisParameters.fEncSoftEndMax;
stPiezoStage.stAxisParametersExposed.fEncSoftEndMin                := stPiezoStage.stAxisParameters.fEncSoftEndMin;
stPiezoStage.stAxisParametersExposed.fVeloMaximum                  := stPiezoStage.stAxisParameters.fVeloMaximum;
stPiezoStage.stAxisParametersExposed.fEncOffset               		:= stPiezoStage.stAxisParameters.fEncOffset;
stPiezoStage.stAxisParametersExposed.fEncScaleFactorInternal       := stPiezoStage.stAxisParameters.fEncScaleFactorInternal;

bExecParamsRead R= fbMcReadParams.Done OR fbMcReadParams.Error;
stPiezoStage.bAxisParamsInit S= fbMcReadParams.Done;]]></ST>
      </Implementation>
    </Method>
    <Method Name="Reset" Id="{643b4736-0a43-4a18-8f6b-8a2439ed5e6f}">
      <Declaration><![CDATA[METHOD Reset : BOOL
]]></Declaration>
      <Implementation>
        <ST><![CDATA[fbMcReset(
    Axis := stPiezoStage.Axis,
    Execute := stPiezoStage.bReset (* AND Axis.Status.Error*),
);]]></ST>
      </Implementation>
    </Method>
    <Method Name="RestoreParameters" Id="{8335d215-fac8-43bf-97f2-e08acc164700}">
      <Declaration><![CDATA[METHOD RestoreParameters
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Trigger a load if anything was saved at all
IF NOT bRestoreInit THEN
    bRestoreInit := TRUE;
    bRestoreLoad S= bSaved;
    fbSetPos.Options.ClearPositionLag := TRUE;
END_IF

// Set our position if bRestoreLoad is true
fbSetPos( Axis:=stPiezoStage.Axis, Execute:=bRestoreLoad, Position:=fSavedPosition);

// Only load once, at startup
bRestoreLoad R= fbSetPos.Done OR fbSetPos.Error;

IF fbSetPos.Error THEN
    // Keep the error latched, it can disappear if Execute is set to FALSE
    nLatchError := fbSetPos.ErrorID;
    nCurrTries := nCurrTries + 1;
    IF nCurrTries >= nMaxRetries THEN
    // Alert the user that something has gone wrong
    stPiezoStage.bError := TRUE;
    stPiezoStage.nErrorId := nLatchError;
    stPiezoStage.sCustomErrorMessage := 'Error loading previously saved position.';
    ELSE
        // Reset the FB for the next retry
        fbSetPos( Axis:=stPiezoStage.Axis, Execute:=bRestoreLoad, Position:=fSavedPosition);
        // Try again
        bRestoreWaitRetry := TRUE;
    END_IF
ELSE
    IF NOT bRestoreDone THEN
        stPiezoStage.fPosition := fSavedPosition;
    END_IF
    THIS^.bRestoreDone := TRUE;
END_IF

tonRestoreRetry( IN := bRestoreWaitRetry, PT := T#100MS);
bRestoreLoad S= tonRestoreRetry.Q;
bRestoreWaitRetry R= tonRestoreRetry.Q;]]></ST>
      </Implementation>
    </Method>
    <Method Name="ScaleDriveParams" Id="{b413f5fa-ba01-446e-8e58-be0ddf41b7f7}">
      <Declaration><![CDATA[METHOD ScaleDriveParams
]]></Declaration>
      <Implementation>
        <ST><![CDATA[nScaledFErrWin:=LREAL_TO_DINT((stPiezoStage.stAxisParameters.fCtrlPosDiffMax / MAX(stPiezoStage.stAxisParameters.fEncScaleFactorInternal, fDefaultScalingFactor)));
nSoftLimMax := LREAL_TO_DINT((stPiezoStage.stAxisParameters.fEncSoftEndMax / MAX(stPiezoStage.stAxisParameters.fEncScaleFactorInternal, fDefaultScalingFactor)));
nSoftLimMin := LREAL_TO_DINT((stPiezoStage.stAxisParameters.fEncSoftEndMin / MAX(stPiezoStage.stAxisParameters.fEncScaleFactorInternal, fDefaultScalingFactor)));]]></ST>
      </Implementation>
    </Method>
    <Method Name="ScaleEncRawValue" Id="{769f98a6-388a-461f-854a-93b1758d578f}">
      <Declaration><![CDATA[METHOD ScaleEncRawValue
VAR_INPUT
  //  bEnable: BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[(* SmartACT: The encoder count from the Piezo drive is not a raw count from the embeded actuator device
   we get a calibrated nm value. thus the use of abs() since this value is signed.
   PI: to be discovered *)
IF stPiezoStage.nRawEncoderDINT <> 0 THEN
    stPiezoStage.nEncoderCount:=DINT_TO_UDINT(ABS(stPiezoStage.nRawEncoderDINT));
ELSE
    stPiezoStage.nEncoderCount:=0;
END_IF

// calibrated encoder readback
fScaledMeasuredPosition:=DINT_TO_REAL(stPiezoStage.nRawEncoderDINT) * MAX(fscalingFactor, fDefaultScalingFactor);
//stPiezoStage.fPosDiff:=ABS(stPiezoStage.fPosition) - ABS(fScaledMeasuredPosition);
stPiezoStage.fPosDiff:=stPiezoStage.fPosition - fScaledMeasuredPosition;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="ScaleHomeMotionParams" Id="{2c5b56b0-7eaa-4a13-8084-de781b4be994}">
      <Declaration><![CDATA[(*Scale Home Move parameters*)
METHOD ScaleHomeMotionParams
]]></Declaration>
      <Implementation>
        <ST><![CDATA[nHomeVeloFast := LREAL_TO_UDINT((stPiezoStage.stAxisParameters.fRefVeloSearch / MAX(stPiezoStage.stAxisParameters.fEncScaleFactorInternal, fDefaultScalingFactor)));
nHomeVeloSlow := LREAL_TO_UDINT((stPiezoStage.stAxisParameters.fRefVeloSync / MAX(stPiezoStage.stAxisParameters.fEncScaleFactorInternal, fDefaultScalingFactor)));
nHomeAcc := LREAL_TO_UDINT((THIS^.fHomeAcc / MAX(stPiezoStage.stAxisParameters.fEncScaleFactorInternal, fDefaultScalingFactor)));
nHomeOffset := LREAL_TO_DINT((stPiezoStage.fHomePosition / MAX(stPiezoStage.stAxisParameters.fEncScaleFactorInternal, fDefaultScalingFactor)));
]]></ST>
      </Implementation>
    </Method>
    <Method Name="ScaleServoOffMotionParams" Id="{78ce5a79-ef3b-44af-a794-7ac04154475b}">
      <Declaration><![CDATA[(*Scaled Open Loop Step mode motion parameters*)
METHOD ScaleServoOffMotionParams
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF 	nChanStepAmp = 0
    OR nChanStepFreq = 0 THEN
    bWrongParameter := TRUE;
ELSE
    nScalededSteps:=LIMIT(-100000, nChanStep, 100000);
    nScalededStepAmp:=REAL_TO_UINT(LIMIT(1, nChanStepAmp, 100) * 655.35);
    nScaledStepFreq:=REAL_TO_UINT(LIMIT(1.0, nChanStepFreq, 1000.0));
    bWrongParameter := FALSE;
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="ScaleServoOnMotionParams" Id="{5254f6ed-ad88-4355-8b1a-4b3573416d58}">
      <Declaration><![CDATA[(*Scaled Close Loop motion parameters*)
METHOD ScaleServoOnMotionParams : BOOL;
VAR_INPUT
END_VAR


]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF stPiezoStage.fVelocity = 0 OR stPiezoStage.fAcceleration = 0 THEN
    bWrongParameter := TRUE;
    ScaleServoOnMotionParams := FALSE;
ELSE
    // All drive paramters must be express in mm, mm/s, mm/s2
    nScaledMaxVelocity:=LREAL_TO_DINT((fMaxVelocity / MAX(fscalingFactor, fDefaultScalingFactor)));
    nScalededMaxAcc:=LREAL_TO_DINT(fMaxAcceleration /  MAX(fscalingFactor, fDefaultScalingFactor));
    // Target Position, velocity and accelerations
    stDS402Drive.nTargetPosition:=LREAL_TO_DINT (stPiezoStage.fPosition / MAX(fscalingFactor, fDefaultScalingFactor));

    stDS402Drive.nProfilVelocity:=LIMIT(0, LREAL_TO_DINT (stPiezoStage.fVelocity / MAX(fscalingFactor, fDefaultScalingFactor)), nScaledMaxVelocity);
    stDS402Drive.nProfilAcceleration:=LIMIT(0, LREAL_TO_DINT (stPiezoStage.fAcceleration / MAX(fscalingFactor, fDefaultScalingFactor)), nScalededMaxAcc) ;
    stDS402Drive.nProfilDecceleration:=stDS402Drive.nProfilAcceleration;
    bWrongParameter := FALSE;
    ScaleServoOnMotionParams := TRUE;
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="SetEnables" Id="{28f7e94e-bad4-40ca-b34a-f8da453343cc}">
      <Declaration><![CDATA[METHOD SetEnables
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[stPiezoStage.bAllForwardEnable:=stPiezoStage.bLimitForwardEnable AND (stPiezoStage.bGantryForwardEnable OR NOT stPiezoStage.bGantryAxis) AND stPiezoStage.stEPSForwardEnable.bEPS_OK;
stPiezoStage.bAllBackwardEnable:=stPiezoStage.bLimitBackwardEnable AND (stPiezoStage.bGantryBackwardEnable OR NOT stPiezoStage.bGantryAxis) AND stPiezoStage.stEPSBackwardEnable.bEPS_OK;

stPiezoStage.bAllEnable:=stPiezoStage.bEnable AND stPiezoStage.bHardwareEnable AND stPiezoStage.stEPSPowerEnable.bEPS_OK;
stPiezoStage.bAllEnable R= NOT stPiezoStage.bUserEnable;]]></ST>
      </Implementation>
    </Method>
    <Method Name="StateMachine" Id="{08b990dd-982c-4d9b-9ed0-d47355966885}">
      <Declaration><![CDATA[METHOD StateMachine
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[(*Operation enbaled*)
IF stDS402Drive.stDS402DriveStatus.ReadyToSwitchOn
    AND stDS402Drive.stDS402DriveStatus.SwitchedOn
    AND stDS402Drive.stDS402DriveStatus.OperationEnabled
    AND NOT stDS402Drive.stDS402DriveStatus.Fault
    AND stDS402Drive.stDS402DriveStatus.VoltageEnabled
    AND stDS402Drive.stDS402DriveStatus.QuickStopActive
    AND NOT stDS402Drive.stDS402DriveStatus.SwitchOnDisabled THEN
         bFault := FALSE;
        bOperational:=TRUE;
ELSIF  NOT stDS402Drive.stDS402DriveStatus.ReadyToSwitchOn
    AND NOT stDS402Drive.stDS402DriveStatus.SwitchedOn
    AND NOT stDS402Drive.stDS402DriveStatus.OperationEnabled
    AND stDS402Drive.stDS402DriveStatus.Fault
    AND stDS402Drive.stDS402DriveStatus.VoltageEnabled
    AND NOT stDS402Drive.stDS402DriveStatus.QuickStopActive
    AND NOT stDS402Drive.stDS402DriveStatus.SwitchOnDisabled THEN
    bFault := TRUE;
END_IF

IF eDriveState<>E_DS402DriveState.OPERATION_ENABLED THEN
    bOperational:=FALSE;
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="StepMove" Id="{74869c9c-654c-4a5a-9a50-bfad55265981}">
      <Declaration><![CDATA[METHOD  StepMove
VAR_INPUT
    Enable : BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[rtStepMove(CLK:=Enable);
CASE eMotionState OF
    E_MoveState.IDLING:;
        // Motion states
        IF rtStepMove.Q THEN
            // enter move discrete or continous here:
            bStepMoveBusy := TRUE;
            bStepMoveDone := FALSE;
            stPiezoStage.bDone:=FALSE;
            bSteModeEnable := FALSE;
            stDS402Drive.nDS402DriveControl:=15;
            eMotionState:=E_MoveState.INIT;
        END_IF
    E_MoveState.INIT:
            stDS402Drive.nDS402DriveControl:=31;
            IF stPiezoStage.bError THEN
                eMotionState:=E_MoveState.ERROR;
            ELSE
                    stDS402Drive.nDS402DriveControl:=31;
                    eMotionState:=E_MoveState.IN_PROGRESS;
            END_IF

    E_MoveState.IN_PROGRESS:
        IF bStop THEN
            bStepMoveBusy:=FALSE;
            eMotionState:=E_MoveState.INTERRUPTED;
            // Genral Motion error i.e Following error ?
        ELSIF stDS402Drive.stDS402DriveStatus.Bit13_OpModeSpecific THEN
            stPiezoStage.bError := TRUE;
            eMotionState:=E_MoveState.ERROR;
        ELSE
            // Reached ?
            IF 	bStepModeOk
                AND stDS402Drive.stDS402DriveStatus.TargetReached
                 AND NOT stDS402Drive.stDS402DriveStatus.Bit12_OpModeSpecific THEN
                      eMotionState:=E_MoveState.REACHED;
            END_IF
        END_IF

    E_MoveState.INTERRUPTED:
        tonHoldTime.IN:=TRUE;
        bPositionHold := TRUE;
        stDS402Drive.nDS402DriveControl.8 := 1;
        eMotionState:=E_MoveState.IDLING;

    E_MoveState.REACHED:
        // Release the endstop override
        bLimOverride := FALSE;
        bStepMoveBusy:=FALSE;
        tonHoldTime.IN := TRUE;
        bPositionHold := TRUE;
        bStepMoveDone:=TRUE;
        stDS402Drive.nDS402DriveControl:=15;
        IF stPiezoStage.bDone THEN
            eMotionState:=E_MoveState.IDLING;
        END_IF
    E_MoveState.ERROR:
        bStepMoveBusy:=FALSE;
        bStepMoveDone:=FALSE;
        IF bWrongParameter THEN
            stPiezoStage.sCustomErrorMessage:='Invalid motion Parameters';
            bWrongParameter := FALSE;
            stPiezoStage.bError := TRUE;
        END_IF
        IF NOT stPiezoStage.bError THEN
            eMotionState:=E_MoveState.IDLING;
        END_IF
END_CASE]]></ST>
      </Implementation>
    </Method>
    <Method Name="UpdateDriveMonitoringParams" Id="{bba7eb59-9b08-4212-8ebb-7515fbf84d2c}">
      <Declaration><![CDATA[(*	Drive parameters update
    Mirror NC axis parameters configurations to those of MCS2 drive
    1- Following error
    2- Home Speeds
    3- Home Acceleration
    4- SoftLimits
*)
METHOD UpdateDriveMonitoringParams
VAR_INPUT
    Enable : BOOL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF Enable THEN

    (*	Drive parameters update
        Mirror NC axis parameters configurations to those of MCS2 drive
        1- Following error.
        2- SoftLimits
        3-Position Range
    *)
  // add some safety here for  0 div.
  ScaleDriveParams();
  ScaleHomeMotionParams ();

  fbUpdateFErrorWin(
    sNetId     := THIS^.stPiezoStage.stAxisParameters.sAmsNetId,
    nSlaveAddr := nSlaveAddr,
    nIndex     := nChanFErrWinIdx,
    nSubIndex  := 0,
    pSrcBuf    := ADR(nScaledFErrWin),
    cbBufLen   := SIZEOF(nScaledFErrWin),
    bExecute   := (nScaledFErrWin <> nRecentFErrWin)
  );
  fbUpdateSoftLimMin(
    sNetId     := THIS^.stPiezoStage.stAxisParameters.sAmsNetId,
    nSlaveAddr := nSlaveAddr,
    nIndex     := nChanSoftLimitIdx,
    nSubIndex  := 1,
    pSrcBuf    := ADR(nSoftLimMin),
    cbBufLen   := SIZEOF(nSoftLimMin),
    bExecute   := (nSoftLimMin <> nRecentSoftLimMin)
  );
  fbUpdateSoftLimMax(
    sNetId     := THIS^.stPiezoStage.stAxisParameters.sAmsNetId,
    nSlaveAddr := nSlaveAddr,
    nIndex     := nChanSoftLimitIdx,
    nSubIndex  := 2,
    pSrcBuf    := ADR(nSoftLimMax),
    cbBufLen   := SIZEOF(nSoftLimMax),
    bExecute   := (nSoftLimMax <> nRecentSoftLimMax)
    );
  fbUpdateHomeVeloFast(
    sNetId     := THIS^.stPiezoStage.stAxisParameters.sAmsNetId,
    nSlaveAddr := nSlaveAddr,
    nIndex     := nChanHomeVeloIdx,
    nSubIndex  := 1,
    pSrcBuf    := ADR(nHomeVeloFast),
    cbBufLen   := SIZEOF(nHomeVeloFast),
    bExecute   := (nHomeVeloFast <> nRecentHomeVeloFast)
  );
  fbUpdateHomeVeloSlow(
    sNetId     := THIS^.stPiezoStage.stAxisParameters.sAmsNetId,
    nSlaveAddr := nSlaveAddr,
    nIndex     := nChanHomeVeloIdx,
    nSubIndex  := 2,
    pSrcBuf    := ADR(nHomeVeloSlow),
    cbBufLen   := SIZEOF(nHomeVeloSlow),
    bExecute   := (nHomeVeloSlow <> nRecentHomeVeloSlow)
  );
  fbUpdateHomeAcc(
    sNetId     := THIS^.stPiezoStage.stAxisParameters.sAmsNetId,
    nSlaveAddr := nSlaveAddr,
    nIndex     := nChanhomeAccIdx,
    nSubIndex  := 0,
    pSrcBuf    := ADR(nHomeAcc),
    cbBufLen   := SIZEOF(nHomeAcc),
    bExecute   := (nHomeAcc <> nRecentHomeAcc)
  );

  fbUpdateHomeOffs(
    sNetId     := THIS^.stPiezoStage.stAxisParameters.sAmsNetId,
    nSlaveAddr := nSlaveAddr,
    nIndex     := nChanHomeOffsIdx,
    nSubIndex  := 0,
    pSrcBuf    := ADR(nHomeOffset),
    cbBufLen   := SIZEOF(nHomeOffset),
    bExecute   := (nHomeOffset <> nRecentHomeOffset)
  );

  ftFErrWinUpdateDone(CLK:=fbUpdateFErrorWin.bBusy);
  ftSoftLimMaxUpdateDone(CLK:=fbUpdateSoftLimMax.bBusy);
  ftSoftLimMinUpdateDone(CLK:=fbUpdateSoftLimMin.bBusy);
  ftHomeVeloFastUpdateDone(CLK:=fbUpdateHomeVeloFast.bBusy);
  ftHomeVeloSlowUpdateDone(CLK:=fbUpdateHomeVeloFast.bBusy);
  ftHomeAccUpdateDone(CLK:=fbUpdateHomeAcc.bBusy);
  ftHomeOffsUpdateDone(CLK:=fbUpdateHomeOffs.bBusy);

    IF ftFErrWinUpdateDone.Q OR ftSoftLimMaxUpdateDone.Q
        OR ftSoftLimMinUpdateDone.Q OR ftHomeVeloFastUpdateDone.Q
        OR ftHomeAccUpdateDone.Q OR ftHomeOffsUpdateDone.Q OR ftHomeVeloSlowUpdateDone.Q THEN
        IF fbUpdateFErrorWin.bError THEN
           stPiezoStage.bError := fbUpdateFErrorWin.bError;
           stPiezoStage.nErrorId := fbUpdateFErrorWin.nErrId;
        ELSIF fbUpdateSoftLimMin.bError THEN
           stPiezoStage.bError := fbUpdateSoftLimMin.bError;
           stPiezoStage.nErrorId := fbUpdateSoftLimMin.nErrId;
        ELSIF fbUpdateSoftLimMax.bError THEN
           stPiezoStage.bError := fbUpdateSoftLimMax.bError;
           stPiezoStage.nErrorId := fbUpdateSoftLimMax.nErrId;
        ELSIF fbUpdateHomeVeloFast.bError THEN
           stPiezoStage.bError := fbUpdateHomeVeloFast.bError;
           stPiezoStage.nErrorId := fbUpdateHomeVeloFast.nErrId;
        ELSIF fbUpdateHomeVeloSlow.bError THEN
           stPiezoStage.bError := fbUpdateHomeVeloSlow.bError;
           stPiezoStage.nErrorId := fbUpdateHomeVeloSlow.nErrId;
        ELSIF fbUpdateHomeAcc.bError THEN
           stPiezoStage.bError := fbUpdateHomeAcc.bError;
           stPiezoStage.nErrorId := fbUpdateHomeAcc.nErrId;
        ELSIF fbUpdateHomeOffs.bError THEN
           stPiezoStage.bError := fbUpdateHomeOffs.bError;
           stPiezoStage.nErrorId := fbUpdateHomeOffs.nErrId;
        ELSE
           nRecentFErrWin := nScaledFErrWin;
           nRecentSoftLimMax := nSoftLimMax;
           nRecentSoftLimMin := nSoftLimMin;
           nRecentHomeVeloFast :=nHomeVeloFast;
           nRecentHomeVeloSlow := nHomeVeloSlow;
           nRecentHomeAcc := nHomeAcc;
           nRecentHomeOffset := nHomeOffs;
        END_IF
        fbUpdateFErrorWin.bExecute := FALSE;
        fbUpdateSoftLimMin.bExecute := FALSE;
        fbUpdateSoftLimMax.bExecute := FALSE;
        fbUpdateHomeVeloFast.bExecute := FALSE;
        fbUpdateHomeVeloSlow.bExecute := FALSE;
        fbUpdateHomeAcc.bExecute := FALSE;
        fbUpdateHomeOffs.bExecute := FALSE;
    END_IF
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="UpdateEpicsStatus" Id="{dc90c8f8-9d88-4ab9-9dc0-f90cd21b81fc}">
      <Declaration><![CDATA[METHOD UpdateEpicsStatus
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[//////////////////////////////////////////////////////////////////
// Transfer NC parameter status to EPICS
//////////////////////////////////////////////////////////////////
stPiezoStage.stAxisStatus.bEnable:=stPiezoStage.bAllEnable;
stPiezoStage.stAxisStatus.bEnabled:=stPiezoStage.bEnableDone; // account for PowerEnable from power block
stPiezoStage.stAxisStatus.bError:=stPiezoStage.bError;
stPiezoStage.stAxisStatus.bHomeSensor:=stPiezoStage.bHome;
stPiezoStage.stAxisStatus.bLimitBwd:=stPiezoStage.bAllBackwardEnable;
stPiezoStage.stAxisStatus.bLimitFwd:=stPiezoStage.bAllForwardEnable;
stPiezoStage.stAxisStatus.bReset:=stPiezoStage.bReset;
stPiezoStage.stAxisStatus.fAcceleration:=stPiezoStage.fAcceleration;
stPiezoStage.stAxisStatus.fActDiff:=stPiezoStage.Axis.NcToPlc.PosDiff;
stPiezoStage.stAxisStatus.fActPosition:=stPiezoStage.Axis.NcToPlc.ActPos;
stPiezoStage.stAxisStatus.fActVelocity:=stPiezoStage.Axis.NcToPlc.ActVelo;
stPiezoStage.stAxisStatus.fDeceleration:=stPiezoStage.Axis.NcToPlc.ActAcc;
stPiezoStage.stAxisStatus.fOverride:=THIS^.fbMcPower.Override;
stPiezoStage.stAxisStatus.fPosition:=stPiezoStage.fPosition;
stPiezoStage.stAxisStatus.fVelocity:=stPiezoStage.fVelocity;
stPiezoStage.stAxisStatus.nCmdData:=INT_TO_UINT(stPiezoStage.nCmdData);  //Or nCmdDataLocal
stPiezoStage.stAxisStatus.nCommand:=INT_TO_UINT(stPiezoStage.nCommand);  //Or nCommandLocal
stPiezoStage.stAxisStatus.nErrorId:=stPiezoStage.nErrorId;
stPiezoStage.stAxisStatus.bBusy:=stPiezoStage.bBusy;
stPiezoStage.stAxisStatus.bHomed:=stPiezoStage.bHomed;
stPiezoStage.stAxisStatus.bExecute:=bLocalExec;
stPiezoStage.stAxisStatus.nCommand:=3; // If this is not 3, the IOC stops updating positions during homing


]]></ST>
      </Implementation>
    </Method>
    <Method Name="UpdateServoOffMotionParams" Id="{4e8302eb-f6c2-4802-bf37-2e40ea9fd85c}">
      <Declaration><![CDATA[(*	MCS2 OL Step parameters update
    1- Step
    2- Step Amplitude
    3- StepFreq
*)
METHOD UpdateServoOffMotionParams
VAR_INPUT
    Enable : BOOL;
END_VAR

]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF Enable THEN
  ScaleServoOffMotionParams();
  fbUpdateSteps(
    sNetId     := THIS^.stPiezoStage.stAxisParameters.sAmsNetId,
    nSlaveAddr := nSlaveAddr,
    nIndex     := nChanStepIdx,
    nSubIndex  := 0,
    pSrcBuf    := ADR(nScalededSteps),
    cbBufLen   := SIZEOF(nChanStep),
    bExecute   := (THIS^.nScalededSteps <> THIS^.nRecentSteps)
  );
  fbUpdateStepAmp(
    sNetId     := THIS^.stPiezoStage.stAxisParameters.sAmsNetId,
    nSlaveAddr := nSlaveAddr,
    nIndex     := nChanStepAmpIdx,
    nSubIndex  := 0,
    pSrcBuf    := ADR(nScalededStepAmp),
    cbBufLen   := SIZEOF(nChanStepAmp),
    bExecute   := (THIS^.nScalededStepAmp <> THIS^.nRecentStepAmp)
  );
  fbUpdateStepFreq(
    sNetId     := THIS^.stPiezoStage.stAxisParameters.sAmsNetId,
    nSlaveAddr := nSlaveAddr,
    nIndex     := nChanStepFreqIdx,
    nSubIndex  := 0,
    pSrcBuf    := ADR(nScaledStepFreq),
    cbBufLen   := SIZEOF(nChanStepFreq),
    bExecute   := (THIS^.nScaledStepFreq <> THIS^.nRecentStepFreq)
  );
  ftStepUpdateDone(CLK:=fbUpdateSteps.bBusy);
  ftStepAmpUpdateDone(CLK:=fbUpdateStepAmp.bBusy);
  ftStepFreqUpdateDone(CLK:=fbUpdateStepFreq.bBusy);

    bServoOffparamsSetDone R= fbUpdateSteps.bBusy OR fbUpdateStepAmp.bBusy OR fbUpdateStepFreq.bBusy;
  IF ftStepUpdateDone.Q
        OR ftStepAmpUpdateDone.Q
        OR ftStepFreqUpdateDone.Q THEN
    IF fbUpdateSteps.bError THEN
            THIS^.stPiezoStage.bError := fbUpdateSteps.bError;
            THIS^.stPiezoStage.nErrorId := fbUpdateSteps.nErrId;
        ELSIF fbUpdateStepFreq.bError THEN
                THIS^.stPiezoStage.bError := fbUpdateStepFreq.bError;
                THIS^.stPiezoStage.nErrorId := fbUpdateStepFreq.nErrId;
        ELSIF fbUpdateStepAmp.bError THEN
                THIS^.stPiezoStage.bError := fbUpdateStepAmp.bError;
                THIS^.stPiezoStage.nErrorId := fbUpdateStepAmp.nErrId;
    ELSE
            THIS^.nRecentSteps := THIS^.nScalededSteps;
            THIS^.nRecentStepAmp := THIS^.nScalededStepAmp;
            THIS^.nRecentStepFreq := THIS^.nScaledStepFreq;
            bServoOffparamsSetDone S= TRUE;
    END_IF
        fbUpdateSteps.bExecute := FALSE;
        fbUpdateStepFreq.bExecute := FALSE;
        fbUpdateStepAmp.bExecute := FALSE;
    END_IF
END_IF
]]></ST>
      </Implementation>
    </Method>
    <Method Name="WriteParameterNC" Id="{a04e1bd8-55ae-495c-bca4-be27f11603b4}">
      <Declaration><![CDATA[METHOD WriteParameterNC
VAR_INPUT
    Execute:BOOL;
    ParameterNumber : MC_AxisParameter;
    ParameterValue	: LREAL;
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[(*Do not change a moving axis parameter*)
fbMcWriteParameter(	Axis:=stPiezoStage.Axis,
                    Execute:=(Execute AND stPiezoStage.Axis.Status.NotMoving),
                    ParameterNumber:=ParameterNumber,
                    Value:=ParameterValue
                  );

// Reset execute after when done successfull or after abort reset
// this way the done and error condition is latched till next move or global reset.
]]></ST>
      </Implementation>
    </Method>
  </POU>
</TcPlcObject>